// *** WARNING: this file was generated by the Lumi IDL Compiler (LUMIDL). ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package apigateway

import (
    "errors"

    pbempty "github.com/golang/protobuf/ptypes/empty"
    pbstruct "github.com/golang/protobuf/ptypes/struct"
    "golang.org/x/net/context"

    "github.com/pulumi/lumi/pkg/resource"
    "github.com/pulumi/lumi/pkg/resource/plugin"
    "github.com/pulumi/lumi/pkg/tokens"
    "github.com/pulumi/lumi/pkg/util/contract"
    "github.com/pulumi/lumi/pkg/util/mapper"
    "github.com/pulumi/lumi/sdk/go/pkg/lumirpc"
)

/* Marshalable Integration structure(s) */

// Integration is a marshalable representation of its corresponding IDL type.
type Integration struct {
    Type IntegrationType `lumi:"type"`
    CacheKeyParameters *[]string `lumi:"cacheKeyParameters,optional"`
    CacheNamespace *string `lumi:"cacheNamespace,optional"`
    Credentials *string `lumi:"credentials,optional"`
    IntegrationHTTPMethod *string `lumi:"integrationHTTPMethod,optional"`
    IntegrationResponse *[]IntegrationResponse `lumi:"integrationResponse,optional"`
    PassthroughBehavior *PassthroughBehavior `lumi:"passthroughBehavior,optional"`
    RequestParameters *map[string]string `lumi:"requestParameters,optional"`
    RequestTemplates *map[string]string `lumi:"requestTemplates,optional"`
    URI *string `lumi:"uri,optional"`
}

// Integration's properties have constants to make dealing with diffs and property bags easier.
const (
    Integration_Type = "type"
    Integration_CacheKeyParameters = "cacheKeyParameters"
    Integration_CacheNamespace = "cacheNamespace"
    Integration_Credentials = "credentials"
    Integration_IntegrationHTTPMethod = "integrationHTTPMethod"
    Integration_IntegrationResponse = "integrationResponse"
    Integration_PassthroughBehavior = "passthroughBehavior"
    Integration_RequestParameters = "requestParameters"
    Integration_RequestTemplates = "requestTemplates"
    Integration_URI = "uri"
)

/* Marshalable IntegrationResponse structure(s) */

// IntegrationResponse is a marshalable representation of its corresponding IDL type.
type IntegrationResponse struct {
    ResponseParameters *map[string]string `lumi:"responseParameters,optional"`
    ResponseTemplates *map[string]string `lumi:"responseTemplates,optional"`
    SelectionPattern *string `lumi:"selectionPattern,optional"`
    StatusCode *string `lumi:"statusCode,optional"`
}

// IntegrationResponse's properties have constants to make dealing with diffs and property bags easier.
const (
    IntegrationResponse_ResponseParameters = "responseParameters"
    IntegrationResponse_ResponseTemplates = "responseTemplates"
    IntegrationResponse_SelectionPattern = "selectionPattern"
    IntegrationResponse_StatusCode = "statusCode"
)

/* RPC stubs for Method resource provider */

// MethodToken is the type token corresponding to the Method package type.
const MethodToken = tokens.Type("aws:apigateway/method:Method")

// MethodProviderOps is a pluggable interface for Method-related management functionality.
type MethodProviderOps interface {
    Check(ctx context.Context, obj *Method) ([]error, error)
    Create(ctx context.Context, obj *Method) (resource.ID, error)
    Get(ctx context.Context, id resource.ID) (*Method, error)
    InspectChange(ctx context.Context,
        id resource.ID, old *Method, new *Method, diff *resource.ObjectDiff) ([]string, error)
    Update(ctx context.Context,
        id resource.ID, old *Method, new *Method, diff *resource.ObjectDiff) error
    Delete(ctx context.Context, id resource.ID) error
}

// MethodProvider is a dynamic gRPC-based plugin for managing Method resources.
type MethodProvider struct {
    ops MethodProviderOps
}

// NewMethodProvider allocates a resource provider that delegates to a ops instance.
func NewMethodProvider(ops MethodProviderOps) lumirpc.ResourceProviderServer {
    contract.Assert(ops != nil)
    return &MethodProvider{ops: ops}
}

func (p *MethodProvider) Check(
    ctx context.Context, req *lumirpc.CheckRequest) (*lumirpc.CheckResponse, error) {
    contract.Assert(req.GetType() == string(MethodToken))
    obj, _, err := p.Unmarshal(req.GetProperties())
    if err != nil {
        return plugin.NewCheckResponse(err), nil
    }
    if failures, err := p.ops.Check(ctx, obj); err != nil {
        return nil, err
    } else if len(failures) > 0 {
        return plugin.NewCheckResponse(resource.NewErrors(failures)), nil
    }
    return plugin.NewCheckResponse(nil), nil
}

func (p *MethodProvider) Name(
    ctx context.Context, req *lumirpc.NameRequest) (*lumirpc.NameResponse, error) {
    contract.Assert(req.GetType() == string(MethodToken))
    obj, _, err := p.Unmarshal(req.GetProperties())
    if err != nil {
        return nil, err
    }
    if obj.Name == nil || *obj.Name == "" {
        if req.Unknowns[Method_Name] {
            return nil, errors.New("Name property cannot be computed from unknown outputs")
        }
        return nil, errors.New("Name property cannot be empty")
    }
    return &lumirpc.NameResponse{Name: *obj.Name}, nil
}

func (p *MethodProvider) Create(
    ctx context.Context, req *lumirpc.CreateRequest) (*lumirpc.CreateResponse, error) {
    contract.Assert(req.GetType() == string(MethodToken))
    obj, _, err := p.Unmarshal(req.GetProperties())
    if err != nil {
        return nil, err
    }
    id, err := p.ops.Create(ctx, obj)
    if err != nil {
        return nil, err
    }
    return &lumirpc.CreateResponse{Id: string(id)}, nil
}

func (p *MethodProvider) Get(
    ctx context.Context, req *lumirpc.GetRequest) (*lumirpc.GetResponse, error) {
    contract.Assert(req.GetType() == string(MethodToken))
    id := resource.ID(req.GetId())
    obj, err := p.ops.Get(ctx, id)
    if err != nil {
        return nil, err
    }
    return &lumirpc.GetResponse{
        Properties: plugin.MarshalProperties(
            nil, resource.NewPropertyMap(obj), plugin.MarshalOptions{}),
    }, nil
}

func (p *MethodProvider) InspectChange(
    ctx context.Context, req *lumirpc.InspectChangeRequest) (*lumirpc.InspectChangeResponse, error) {
    contract.Assert(req.GetType() == string(MethodToken))
    id := resource.ID(req.GetId())
    old, oldprops, err := p.Unmarshal(req.GetOlds())
    if err != nil {
        return nil, err
    }
    new, newprops, err := p.Unmarshal(req.GetNews())
    if err != nil {
        return nil, err
    }
    var replaces []string
    diff := oldprops.Diff(newprops)
    if diff != nil {
        if diff.Changed("name") {
            replaces = append(replaces, "name")
        }
    }
    more, err := p.ops.InspectChange(ctx, id, old, new, diff)
    if err != nil {
        return nil, err
    }
    return &lumirpc.InspectChangeResponse{
        Replaces: append(replaces, more...),
    }, err
}

func (p *MethodProvider) Update(
    ctx context.Context, req *lumirpc.UpdateRequest) (*pbempty.Empty, error) {
    contract.Assert(req.GetType() == string(MethodToken))
    id := resource.ID(req.GetId())
    old, oldprops, err := p.Unmarshal(req.GetOlds())
    if err != nil {
        return nil, err
    }
    new, newprops, err := p.Unmarshal(req.GetNews())
    if err != nil {
        return nil, err
    }
    diff := oldprops.Diff(newprops)
    if err := p.ops.Update(ctx, id, old, new, diff); err != nil {
        return nil, err
    }
    return &pbempty.Empty{}, nil
}

func (p *MethodProvider) Delete(
    ctx context.Context, req *lumirpc.DeleteRequest) (*pbempty.Empty, error) {
    contract.Assert(req.GetType() == string(MethodToken))
    id := resource.ID(req.GetId())
    if err := p.ops.Delete(ctx, id); err != nil {
        return nil, err
    }
    return &pbempty.Empty{}, nil
}

func (p *MethodProvider) Unmarshal(
    v *pbstruct.Struct) (*Method, resource.PropertyMap, error) {
    var obj Method
    props := plugin.UnmarshalProperties(nil, v, plugin.MarshalOptions{RawResources: true})
    return &obj, props, mapper.MapIU(props.Mappable(), &obj)
}

/* Marshalable Method structure(s) */

// Method is a marshalable representation of its corresponding IDL type.
type Method struct {
    Name *string `lumi:"name,optional"`
    HTTPMethod string `lumi:"httpMethod"`
    APIResource resource.ID `lumi:"apiResource"`
    RestAPI resource.ID `lumi:"restAPI"`
    APIKeyRequired *bool `lumi:"apiKeyRequired,optional"`
    AuthorizationType *AuthorizationType `lumi:"authorizationType,optional"`
    Authorizer *resource.ID `lumi:"authorizer,optional"`
    Integration *Integration `lumi:"integration,optional"`
    MethodResponses *[]MethodResponse `lumi:"methodResponses,optional"`
    RequestModels *map[string]resource.ID `lumi:"requestModels,optional"`
    RequestParameters *map[string]bool `lumi:"requestParameters,optional"`
}

// Method's properties have constants to make dealing with diffs and property bags easier.
const (
    Method_Name = "name"
    Method_HTTPMethod = "httpMethod"
    Method_APIResource = "apiResource"
    Method_RestAPI = "restAPI"
    Method_APIKeyRequired = "apiKeyRequired"
    Method_AuthorizationType = "authorizationType"
    Method_Authorizer = "authorizer"
    Method_Integration = "integration"
    Method_MethodResponses = "methodResponses"
    Method_RequestModels = "requestModels"
    Method_RequestParameters = "requestParameters"
)

/* Marshalable MethodResponse structure(s) */

// MethodResponse is a marshalable representation of its corresponding IDL type.
type MethodResponse struct {
    StatusCode string `lumi:"statusCode"`
    ResponseModels *map[string]resource.ID `lumi:"responseModels,optional"`
    ResponseParameters *map[string]bool `lumi:"responseParameters,optional"`
}

// MethodResponse's properties have constants to make dealing with diffs and property bags easier.
const (
    MethodResponse_StatusCode = "statusCode"
    MethodResponse_ResponseModels = "responseModels"
    MethodResponse_ResponseParameters = "responseParameters"
)

/* Marshalable MethodSetting structure(s) */

// MethodSetting is a marshalable representation of its corresponding IDL type.
type MethodSetting struct {
    CacheDataEncrypted *bool `lumi:"cacheDataEncrypted,optional"`
    CacheTTLInSeconds *float64 `lumi:"cacheTTLInSeconds,optional"`
    CachingEnabled *bool `lumi:"cachingEnabled,optional"`
    DataTraceEnabled *bool `lumi:"dataTraceEnabled,optional"`
    HTTPMethod *string `lumi:"httpMethod,optional"`
    LoggingLevel *LoggingLevel `lumi:"loggingLevel,optional"`
    MetricsEnabled *bool `lumi:"metricsEnabled,optional"`
    ResourcePath *string `lumi:"resourcePath,optional"`
    ThrottlingBurstLimit *float64 `lumi:"throttlingBurstLimit,optional"`
    ThrottlingRateLimit *float64 `lumi:"throttlingRateLimit,optional"`
}

// MethodSetting's properties have constants to make dealing with diffs and property bags easier.
const (
    MethodSetting_CacheDataEncrypted = "cacheDataEncrypted"
    MethodSetting_CacheTTLInSeconds = "cacheTTLInSeconds"
    MethodSetting_CachingEnabled = "cachingEnabled"
    MethodSetting_DataTraceEnabled = "dataTraceEnabled"
    MethodSetting_HTTPMethod = "httpMethod"
    MethodSetting_LoggingLevel = "loggingLevel"
    MethodSetting_MetricsEnabled = "metricsEnabled"
    MethodSetting_ResourcePath = "resourcePath"
    MethodSetting_ThrottlingBurstLimit = "throttlingBurstLimit"
    MethodSetting_ThrottlingRateLimit = "throttlingRateLimit"
)

/* Typedefs */

type (
    AuthorizationType string
    IntegrationType string
    LoggingLevel string
    PassthroughBehavior string
)

/* Constants */

const (
    AWSIAMAuthorization AuthorizationType = "AWS_IAM"
    AWSIntegration IntegrationType = "AWS"
    AWSProxyIntegration IntegrationType = "AWS_PROXY"
    CognitoAuthorization AuthorizationType = "COGNITO_USER_POOLS"
    CustomAuthorization AuthorizationType = "CUSTOM"
    HTTPIntegration IntegrationType = "HTTP"
    HTTPProxyIntegration IntegrationType = "HTTP_PROXY"
    LoggingErrorLevel LoggingLevel = "ERROR"
    LoggingInfoLevel LoggingLevel = "INFO"
    LoggingOff LoggingLevel = "OFF"
    MockIntegration IntegrationType = "MOCK"
    NoAuthorization AuthorizationType = "NONE"
    PassthroughNever PassthroughBehavior = "NEVER"
    PassthroughWhenNoMatch PassthroughBehavior = "WHEN_NO_MATCH"
    PassthroughWhenNoTemplates PassthroughBehavior = "WHEN_NO_TEMPLATES"
)


