// Copyright 2026-2026, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"

	jen "github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
)

func main() {
	os.Exit(run())
}

func run() int {
	if len(os.Args) < 2 {
		fmt.Fprintln(os.Stderr, "Usage: go run ./sdk/go/tools/automation <path-to-specification.json>")
		return 1
	}

	specPath, err := filepath.Abs(os.Args[1])
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to resolve specification path: %v\n", err)
		return 1
	}

	specBytes, err := os.ReadFile(specPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to read specification: %v\n", err)
		return 1
	}

	var spec Structure
	if err := json.Unmarshal(specBytes, &spec); err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse specification: %v\n", err)
		return 1
	}

	outputDir := filepath.Join(".", "output")
	if err := os.MkdirAll(outputDir, 0o755); err != nil {
		fmt.Fprintf(os.Stderr, "failed to create output directory: %v\n", err)
		return 1
	}

	file := jen.NewFile("auto")
	file.HeaderComment("Code generated by sdk/go/tools/automation; DO NOT EDIT.")
	if base := filepath.Base(specPath); base != "" {
		file.HeaderComment("Source: " + base)
	}

	if err := generateOptionsTypes(file, spec); err != nil {
		fmt.Fprintf(os.Stderr, "failed to generate options types: %v\n", err)
		return 1
	}

	var buf bytes.Buffer
	if err := file.Render(&buf); err != nil {
		fmt.Fprintf(os.Stderr, "failed to render generated file: %v\n", err)
		return 1
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "warning: gofmt failed, writing unformatted code: %v\n", err)
		formatted = buf.Bytes()
	}

	outputPath := filepath.Join(outputDir, "options.go")
	if err := os.WriteFile(outputPath, formatted, 0o600); err != nil {
		fmt.Fprintf(os.Stderr, "failed to write output: %v\n", err)
		return 1
	}

	return 0
}

// generateOptionsTypes walks the CLI specification tree and emits a flattened
// "Options" struct for every command and menu.
func generateOptionsTypes(file *jen.File, root Structure) error {
	return walkStructure(file, root, nil, nil)
}

// walkStructure recursively descends the CLI tree, aggregating flags and
// emitting a Go struct per command/menu.
func walkStructure(
	file *jen.File,
	node Structure,
	breadcrumbs []string,
	inherited map[string]Flag,
) error {
	command := "pulumi"
	if len(breadcrumbs) > 0 {
		command = command + " " + strings.Join(breadcrumbs, " ")
	}
	typeName := toPascal(command) + "Options"

	// Merge inherited and local flags, with local flags winning on conflicts.
	flags := make(map[string]Flag, len(inherited)+len(node.Flags))
	for k, v := range inherited {
		flags[k] = v
	}
	for k, v := range node.Flags {
		flags[k] = v
	}

	if err := writeOptionsStruct(file, command, typeName, flags); err != nil {
		return err
	}

	if node.Type == "menu" && len(node.Commands) > 0 {
		// Ensure deterministic ordering for generated types.
		names := make([]string, 0, len(node.Commands))
		for name := range node.Commands {
			names = append(names, name)
		}
		sort.Strings(names)

		for _, name := range names {
			child := node.Commands[name]
			if err := walkStructure(file, child, append(breadcrumbs, name), flags); err != nil {
				return err
			}
		}
	}

	return nil
}

func writeOptionsStruct(
	file *jen.File,
	command, typeName string,
	flags map[string]Flag,
) error {
	file.Comment(fmt.Sprintf("%s are options for the `%s` command.", typeName, command))

	// Sort flags by their canonical name for stable output.
	names := make([]string, 0, len(flags))
	for name := range flags {
		names = append(names, name)
	}
	sort.Strings(names)

	file.Type().Id(typeName).StructFunc(func(g *jen.Group) {
		for _, name := range names {
			flag := flags[name]

			goType, err := convertType(flag.Type, flag.Repeatable)
			if err != nil {
				// propagate the error via panic; generateOptionsTypes will surface it.
				panic(err)
			}

			fieldName := strcase.ToCamel(flag.Name)

			if flag.Description != "" {
				g.Comment(flag.Description)
			}

			g.Id(fieldName).Add(goType)
		}
	})

	return nil
}

// convertType maps specification flag types onto appropriate Go types.
func convertType(typ string, repeatable bool) (jen.Code, error) {
	var base *jen.Statement

	switch typ {
	case "string":
		base = jen.Id("string")
	case "boolean":
		base = jen.Id("bool")
	case "int":
		base = jen.Id("int")
	default:
		return nil, fmt.Errorf("unknown flag type: %s", typ)
	}

	if repeatable {
		return jen.Index().Add(base), nil
	}
	return base, nil
}

// toPascal converts an arbitrary command path (for example,
// "pulumi config env add") into a PascalCase identifier (for example,
// "PulumiConfigEnvAdd") using strcase.
func toPascal(s string) string {
	s = strings.TrimSpace(s)
	if s == "" {
		return ""
	}
	s = strings.ReplaceAll(s, " ", "_")
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, "/", "_")
	return strcase.ToCamel(s)
}
