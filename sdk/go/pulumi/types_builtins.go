// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by "generate.go"; DO NOT EDIT.

//nolint:lll
package pulumi

import (
	"context"
	"errors"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var archiveType = reflect.TypeOf((*Archive)(nil)).Elem()

// ArchiveInput is an input type that accepts Archive and ArchiveOutput values.
type ArchiveInput interface {
	Input

	ToArchiveOutput() ArchiveOutput
	ToArchiveOutputWithContext(ctx context.Context) ArchiveOutput
}

// ElementType returns the element type of this Input (Archive).
func (*archive) ElementType() reflect.Type {
	return archiveType
}

func (in *archive) ToOutput(ctx context.Context) pulumix.Output[Archive] {
	return pulumix.Output[Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in *archive) ToArchiveOutput() ArchiveOutput {
	return ToOutput(in).(ArchiveOutput)
}

func (in *archive) ToArchiveOutputWithContext(ctx context.Context) ArchiveOutput {
	return ToOutputWithContext(ctx, in).(ArchiveOutput)
}

func (in *archive) ToAssetOrArchiveOutput() AssetOrArchiveOutput {
	return in.ToAssetOrArchiveOutputWithContext(context.Background())
}

func (in *archive) ToAssetOrArchiveOutputWithContext(ctx context.Context) AssetOrArchiveOutput {
	return in.ToArchiveOutputWithContext(ctx).ToAssetOrArchiveOutputWithContext(ctx)
}

// ArchiveOutput is an Output that returns Archive values.
type ArchiveOutput struct{ *OutputState }

func (ArchiveOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveOutput) ToOutput(ctx context.Context) pulumix.Output[Archive] {
	return pulumix.Output[Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (Archive).
func (ArchiveOutput) ElementType() reflect.Type {
	return archiveType
}

func (o ArchiveOutput) ToArchiveOutput() ArchiveOutput {
	return o
}

func (o ArchiveOutput) ToArchiveOutputWithContext(ctx context.Context) ArchiveOutput {
	return o
}

func (o ArchiveOutput) ToAssetOrArchiveOutput() AssetOrArchiveOutput {
	return o.ToAssetOrArchiveOutputWithContext(context.Background())
}

func (o ArchiveOutput) ToAssetOrArchiveOutputWithContext(ctx context.Context) AssetOrArchiveOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Archive) AssetOrArchive {
		return (AssetOrArchive)(v)
	}).(AssetOrArchiveOutput)
}

var archiveArrayType = reflect.TypeOf((*[]Archive)(nil)).Elem()

// ArchiveArrayInput is an input type that accepts ArchiveArray and ArchiveArrayOutput values.
type ArchiveArrayInput interface {
	Input

	ToArchiveArrayOutput() ArchiveArrayOutput
	ToArchiveArrayOutputWithContext(ctx context.Context) ArchiveArrayOutput
}

// ArchiveArray is an input type for []ArchiveInput values.
type ArchiveArray []ArchiveInput

// ElementType returns the element type of this Input ([]Archive).
func (ArchiveArray) ElementType() reflect.Type {
	return archiveArrayType
}

func (in ArchiveArray) ToOutput(ctx context.Context) pulumix.Output[[]Archive] {
	return pulumix.Output[[]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveArray) ToArchiveArrayOutput() ArchiveArrayOutput {
	return ToOutput(in).(ArchiveArrayOutput)
}

func (in ArchiveArray) ToArchiveArrayOutputWithContext(ctx context.Context) ArchiveArrayOutput {
	return ToOutputWithContext(ctx, in).(ArchiveArrayOutput)
}

// ArchiveArrayOutput is an Output that returns []Archive values.
type ArchiveArrayOutput struct{ *OutputState }

func (ArchiveArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]Archive] {
	return pulumix.Output[[]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]Archive).
func (ArchiveArrayOutput) ElementType() reflect.Type {
	return archiveArrayType
}

func (o ArchiveArrayOutput) ToArchiveArrayOutput() ArchiveArrayOutput {
	return o
}

func (o ArchiveArrayOutput) ToArchiveArrayOutputWithContext(ctx context.Context) ArchiveArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o ArchiveArrayOutput) Index(i IntInput) ArchiveOutput {
	return All(o, i).ApplyT(func(vs []any) Archive {
		arr := vs[0].([]Archive)
		idx := vs[1].(int)
		var ret Archive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(ArchiveOutput)
}

func ToArchiveArray(in []Archive) ArchiveArray {
	a := make(ArchiveArray, len(in))
	for i, v := range in {
		a[i] = (v)
	}
	return a
}

func ToArchiveArrayOutput(in []ArchiveOutput) ArchiveArrayOutput {
	a := make(ArchiveArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToArchiveArrayOutput()
}

var archiveMapType = reflect.TypeOf((*map[string]Archive)(nil)).Elem()

// ArchiveMapInput is an input type that accepts ArchiveMap and ArchiveMapOutput values.
type ArchiveMapInput interface {
	Input

	ToArchiveMapOutput() ArchiveMapOutput
	ToArchiveMapOutputWithContext(ctx context.Context) ArchiveMapOutput
}

// ArchiveMap is an input type for map[string]ArchiveInput values.
type ArchiveMap map[string]ArchiveInput

// ElementType returns the element type of this Input (map[string]Archive).
func (ArchiveMap) ElementType() reflect.Type {
	return archiveMapType
}

func (in ArchiveMap) ToOutput(ctx context.Context) pulumix.Output[map[string]Archive] {
	return pulumix.Output[map[string]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveMap) ToArchiveMapOutput() ArchiveMapOutput {
	return ToOutput(in).(ArchiveMapOutput)
}

func (in ArchiveMap) ToArchiveMapOutputWithContext(ctx context.Context) ArchiveMapOutput {
	return ToOutputWithContext(ctx, in).(ArchiveMapOutput)
}

// ArchiveMapOutput is an Output that returns map[string]Archive values.
type ArchiveMapOutput struct{ *OutputState }

func (ArchiveMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]Archive] {
	return pulumix.Output[map[string]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]Archive).
func (ArchiveMapOutput) ElementType() reflect.Type {
	return archiveMapType
}

func (o ArchiveMapOutput) ToArchiveMapOutput() ArchiveMapOutput {
	return o
}

func (o ArchiveMapOutput) ToArchiveMapOutputWithContext(ctx context.Context) ArchiveMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o ArchiveMapOutput) MapIndex(k StringInput) ArchiveOutput {
	return All(o, k).ApplyT(func(vs []any) Archive {
		return vs[0].(map[string]Archive)[vs[1].(string)]
	}).(ArchiveOutput)
}

func ToArchiveMap(in map[string]Archive) ArchiveMap {
	m := make(ArchiveMap)
	for k, v := range in {
		m[k] = (v)
	}
	return m
}

func ToArchiveMapOutput(in map[string]ArchiveOutput) ArchiveMapOutput {
	m := make(ArchiveMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToArchiveMapOutput()
}

var archiveArrayMapType = reflect.TypeOf((*map[string][]Archive)(nil)).Elem()

// ArchiveArrayMapInput is an input type that accepts ArchiveArrayMap and ArchiveArrayMapOutput values.
type ArchiveArrayMapInput interface {
	Input

	ToArchiveArrayMapOutput() ArchiveArrayMapOutput
	ToArchiveArrayMapOutputWithContext(ctx context.Context) ArchiveArrayMapOutput
}

// ArchiveArrayMap is an input type for map[string]ArchiveArrayInput values.
type ArchiveArrayMap map[string]ArchiveArrayInput

// ElementType returns the element type of this Input (map[string][]Archive).
func (ArchiveArrayMap) ElementType() reflect.Type {
	return archiveArrayMapType
}

func (in ArchiveArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]Archive] {
	return pulumix.Output[map[string][]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveArrayMap) ToArchiveArrayMapOutput() ArchiveArrayMapOutput {
	return ToOutput(in).(ArchiveArrayMapOutput)
}

func (in ArchiveArrayMap) ToArchiveArrayMapOutputWithContext(ctx context.Context) ArchiveArrayMapOutput {
	return ToOutputWithContext(ctx, in).(ArchiveArrayMapOutput)
}

// ArchiveArrayMapOutput is an Output that returns map[string][]Archive values.
type ArchiveArrayMapOutput struct{ *OutputState }

func (ArchiveArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]Archive] {
	return pulumix.Output[map[string][]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]Archive).
func (ArchiveArrayMapOutput) ElementType() reflect.Type {
	return archiveArrayMapType
}

func (o ArchiveArrayMapOutput) ToArchiveArrayMapOutput() ArchiveArrayMapOutput {
	return o
}

func (o ArchiveArrayMapOutput) ToArchiveArrayMapOutputWithContext(ctx context.Context) ArchiveArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o ArchiveArrayMapOutput) MapIndex(k StringInput) ArchiveArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []Archive {
		return vs[0].(map[string][]Archive)[vs[1].(string)]
	}).(ArchiveArrayOutput)
}

func ToArchiveArrayMap(in map[string][]Archive) ArchiveArrayMap {
	m := make(ArchiveArrayMap)
	for k, v := range in {
		m[k] = ToArchiveArray(v)
	}
	return m
}

func ToArchiveArrayMapOutput(in map[string]ArchiveArrayOutput) ArchiveArrayMapOutput {
	m := make(ArchiveArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToArchiveArrayMapOutput()
}

var archiveMapArrayType = reflect.TypeOf((*[]map[string]Archive)(nil)).Elem()

// ArchiveMapArrayInput is an input type that accepts ArchiveMapArray and ArchiveMapArrayOutput values.
type ArchiveMapArrayInput interface {
	Input

	ToArchiveMapArrayOutput() ArchiveMapArrayOutput
	ToArchiveMapArrayOutputWithContext(ctx context.Context) ArchiveMapArrayOutput
}

// ArchiveMapArray is an input type for []ArchiveMapInput values.
type ArchiveMapArray []ArchiveMapInput

// ElementType returns the element type of this Input ([]map[string]Archive).
func (ArchiveMapArray) ElementType() reflect.Type {
	return archiveMapArrayType
}

func (in ArchiveMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]Archive] {
	return pulumix.Output[[]map[string]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveMapArray) ToArchiveMapArrayOutput() ArchiveMapArrayOutput {
	return ToOutput(in).(ArchiveMapArrayOutput)
}

func (in ArchiveMapArray) ToArchiveMapArrayOutputWithContext(ctx context.Context) ArchiveMapArrayOutput {
	return ToOutputWithContext(ctx, in).(ArchiveMapArrayOutput)
}

// ArchiveMapArrayOutput is an Output that returns []map[string]Archive values.
type ArchiveMapArrayOutput struct{ *OutputState }

func (ArchiveMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]Archive] {
	return pulumix.Output[[]map[string]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]Archive).
func (ArchiveMapArrayOutput) ElementType() reflect.Type {
	return archiveMapArrayType
}

func (o ArchiveMapArrayOutput) ToArchiveMapArrayOutput() ArchiveMapArrayOutput {
	return o
}

func (o ArchiveMapArrayOutput) ToArchiveMapArrayOutputWithContext(ctx context.Context) ArchiveMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o ArchiveMapArrayOutput) Index(i IntInput) ArchiveMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]Archive {
		arr := vs[0].([]map[string]Archive)
		idx := vs[1].(int)
		var ret map[string]Archive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(ArchiveMapOutput)
}

func ToArchiveMapArray(in []map[string]Archive) ArchiveMapArray {
	a := make(ArchiveMapArray, len(in))
	for i, v := range in {
		a[i] = ToArchiveMap(v)
	}
	return a
}

func ToArchiveMapArrayOutput(in []ArchiveMapOutput) ArchiveMapArrayOutput {
	a := make(ArchiveMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToArchiveMapArrayOutput()
}

var archiveMapMapType = reflect.TypeOf((*map[string]map[string]Archive)(nil)).Elem()

// ArchiveMapMapInput is an input type that accepts ArchiveMapMap and ArchiveMapMapOutput values.
type ArchiveMapMapInput interface {
	Input

	ToArchiveMapMapOutput() ArchiveMapMapOutput
	ToArchiveMapMapOutputWithContext(ctx context.Context) ArchiveMapMapOutput
}

// ArchiveMapMap is an input type for map[string]ArchiveMapInput values.
type ArchiveMapMap map[string]ArchiveMapInput

// ElementType returns the element type of this Input (map[string]map[string]Archive).
func (ArchiveMapMap) ElementType() reflect.Type {
	return archiveMapMapType
}

func (in ArchiveMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]Archive] {
	return pulumix.Output[map[string]map[string]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveMapMap) ToArchiveMapMapOutput() ArchiveMapMapOutput {
	return ToOutput(in).(ArchiveMapMapOutput)
}

func (in ArchiveMapMap) ToArchiveMapMapOutputWithContext(ctx context.Context) ArchiveMapMapOutput {
	return ToOutputWithContext(ctx, in).(ArchiveMapMapOutput)
}

// ArchiveMapMapOutput is an Output that returns map[string]map[string]Archive values.
type ArchiveMapMapOutput struct{ *OutputState }

func (ArchiveMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]Archive] {
	return pulumix.Output[map[string]map[string]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]Archive).
func (ArchiveMapMapOutput) ElementType() reflect.Type {
	return archiveMapMapType
}

func (o ArchiveMapMapOutput) ToArchiveMapMapOutput() ArchiveMapMapOutput {
	return o
}

func (o ArchiveMapMapOutput) ToArchiveMapMapOutputWithContext(ctx context.Context) ArchiveMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o ArchiveMapMapOutput) MapIndex(k StringInput) ArchiveMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]Archive {
		return vs[0].(map[string]map[string]Archive)[vs[1].(string)]
	}).(ArchiveMapOutput)
}

func ToArchiveMapMap(in map[string]map[string]Archive) ArchiveMapMap {
	m := make(ArchiveMapMap)
	for k, v := range in {
		m[k] = ToArchiveMap(v)
	}
	return m
}

func ToArchiveMapMapOutput(in map[string]ArchiveMapOutput) ArchiveMapMapOutput {
	m := make(ArchiveMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToArchiveMapMapOutput()
}

var archiveArrayArrayType = reflect.TypeOf((*[][]Archive)(nil)).Elem()

// ArchiveArrayArrayInput is an input type that accepts ArchiveArrayArray and ArchiveArrayArrayOutput values.
type ArchiveArrayArrayInput interface {
	Input

	ToArchiveArrayArrayOutput() ArchiveArrayArrayOutput
	ToArchiveArrayArrayOutputWithContext(ctx context.Context) ArchiveArrayArrayOutput
}

// ArchiveArrayArray is an input type for []ArchiveArrayInput values.
type ArchiveArrayArray []ArchiveArrayInput

// ElementType returns the element type of this Input ([][]Archive).
func (ArchiveArrayArray) ElementType() reflect.Type {
	return archiveArrayArrayType
}

func (in ArchiveArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][]Archive] {
	return pulumix.Output[[][]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveArrayArray) ToArchiveArrayArrayOutput() ArchiveArrayArrayOutput {
	return ToOutput(in).(ArchiveArrayArrayOutput)
}

func (in ArchiveArrayArray) ToArchiveArrayArrayOutputWithContext(ctx context.Context) ArchiveArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(ArchiveArrayArrayOutput)
}

// ArchiveArrayArrayOutput is an Output that returns [][]Archive values.
type ArchiveArrayArrayOutput struct{ *OutputState }

func (ArchiveArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][]Archive] {
	return pulumix.Output[[][]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][]Archive).
func (ArchiveArrayArrayOutput) ElementType() reflect.Type {
	return archiveArrayArrayType
}

func (o ArchiveArrayArrayOutput) ToArchiveArrayArrayOutput() ArchiveArrayArrayOutput {
	return o
}

func (o ArchiveArrayArrayOutput) ToArchiveArrayArrayOutputWithContext(ctx context.Context) ArchiveArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o ArchiveArrayArrayOutput) Index(i IntInput) ArchiveArrayOutput {
	return All(o, i).ApplyT(func(vs []any) []Archive {
		arr := vs[0].([][]Archive)
		idx := vs[1].(int)
		var ret []Archive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(ArchiveArrayOutput)
}

func ToArchiveArrayArray(in [][]Archive) ArchiveArrayArray {
	a := make(ArchiveArrayArray, len(in))
	for i, v := range in {
		a[i] = ToArchiveArray(v)
	}
	return a
}

func ToArchiveArrayArrayOutput(in []ArchiveArrayOutput) ArchiveArrayArrayOutput {
	a := make(ArchiveArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToArchiveArrayArrayOutput()
}

var archiveArrayMapMapType = reflect.TypeOf((*map[string]map[string][]Archive)(nil)).Elem()

// ArchiveArrayMapMapInput is an input type that accepts ArchiveArrayMapMap and ArchiveArrayMapMapOutput values.
type ArchiveArrayMapMapInput interface {
	Input

	ToArchiveArrayMapMapOutput() ArchiveArrayMapMapOutput
	ToArchiveArrayMapMapOutputWithContext(ctx context.Context) ArchiveArrayMapMapOutput
}

// ArchiveArrayMapMap is an input type for map[string]ArchiveArrayMapInput values.
type ArchiveArrayMapMap map[string]ArchiveArrayMapInput

// ElementType returns the element type of this Input (map[string]map[string][]Archive).
func (ArchiveArrayMapMap) ElementType() reflect.Type {
	return archiveArrayMapMapType
}

func (in ArchiveArrayMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]Archive] {
	return pulumix.Output[map[string]map[string][]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveArrayMapMap) ToArchiveArrayMapMapOutput() ArchiveArrayMapMapOutput {
	return ToOutput(in).(ArchiveArrayMapMapOutput)
}

func (in ArchiveArrayMapMap) ToArchiveArrayMapMapOutputWithContext(ctx context.Context) ArchiveArrayMapMapOutput {
	return ToOutputWithContext(ctx, in).(ArchiveArrayMapMapOutput)
}

// ArchiveArrayMapMapOutput is an Output that returns map[string]map[string][]Archive values.
type ArchiveArrayMapMapOutput struct{ *OutputState }

func (ArchiveArrayMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveArrayMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]Archive] {
	return pulumix.Output[map[string]map[string][]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string][]Archive).
func (ArchiveArrayMapMapOutput) ElementType() reflect.Type {
	return archiveArrayMapMapType
}

func (o ArchiveArrayMapMapOutput) ToArchiveArrayMapMapOutput() ArchiveArrayMapMapOutput {
	return o
}

func (o ArchiveArrayMapMapOutput) ToArchiveArrayMapMapOutputWithContext(ctx context.Context) ArchiveArrayMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o ArchiveArrayMapMapOutput) MapIndex(k StringInput) ArchiveArrayMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string][]Archive {
		return vs[0].(map[string]map[string][]Archive)[vs[1].(string)]
	}).(ArchiveArrayMapOutput)
}

func ToArchiveArrayMapMap(in map[string]map[string][]Archive) ArchiveArrayMapMap {
	m := make(ArchiveArrayMapMap)
	for k, v := range in {
		m[k] = ToArchiveArrayMap(v)
	}
	return m
}

func ToArchiveArrayMapMapOutput(in map[string]ArchiveArrayMapOutput) ArchiveArrayMapMapOutput {
	m := make(ArchiveArrayMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToArchiveArrayMapMapOutput()
}

var archiveMapArrayMapType = reflect.TypeOf((*map[string][]map[string]Archive)(nil)).Elem()

// ArchiveMapArrayMapInput is an input type that accepts ArchiveMapArrayMap and ArchiveMapArrayMapOutput values.
type ArchiveMapArrayMapInput interface {
	Input

	ToArchiveMapArrayMapOutput() ArchiveMapArrayMapOutput
	ToArchiveMapArrayMapOutputWithContext(ctx context.Context) ArchiveMapArrayMapOutput
}

// ArchiveMapArrayMap is an input type for map[string]ArchiveMapArrayInput values.
type ArchiveMapArrayMap map[string]ArchiveMapArrayInput

// ElementType returns the element type of this Input (map[string][]map[string]Archive).
func (ArchiveMapArrayMap) ElementType() reflect.Type {
	return archiveMapArrayMapType
}

func (in ArchiveMapArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]Archive] {
	return pulumix.Output[map[string][]map[string]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveMapArrayMap) ToArchiveMapArrayMapOutput() ArchiveMapArrayMapOutput {
	return ToOutput(in).(ArchiveMapArrayMapOutput)
}

func (in ArchiveMapArrayMap) ToArchiveMapArrayMapOutputWithContext(ctx context.Context) ArchiveMapArrayMapOutput {
	return ToOutputWithContext(ctx, in).(ArchiveMapArrayMapOutput)
}

// ArchiveMapArrayMapOutput is an Output that returns map[string][]map[string]Archive values.
type ArchiveMapArrayMapOutput struct{ *OutputState }

func (ArchiveMapArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveMapArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]Archive] {
	return pulumix.Output[map[string][]map[string]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]map[string]Archive).
func (ArchiveMapArrayMapOutput) ElementType() reflect.Type {
	return archiveMapArrayMapType
}

func (o ArchiveMapArrayMapOutput) ToArchiveMapArrayMapOutput() ArchiveMapArrayMapOutput {
	return o
}

func (o ArchiveMapArrayMapOutput) ToArchiveMapArrayMapOutputWithContext(ctx context.Context) ArchiveMapArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o ArchiveMapArrayMapOutput) MapIndex(k StringInput) ArchiveMapArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []map[string]Archive {
		return vs[0].(map[string][]map[string]Archive)[vs[1].(string)]
	}).(ArchiveMapArrayOutput)
}

func ToArchiveMapArrayMap(in map[string][]map[string]Archive) ArchiveMapArrayMap {
	m := make(ArchiveMapArrayMap)
	for k, v := range in {
		m[k] = ToArchiveMapArray(v)
	}
	return m
}

func ToArchiveMapArrayMapOutput(in map[string]ArchiveMapArrayOutput) ArchiveMapArrayMapOutput {
	m := make(ArchiveMapArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToArchiveMapArrayMapOutput()
}

var archiveMapMapArrayType = reflect.TypeOf((*[]map[string]map[string]Archive)(nil)).Elem()

// ArchiveMapMapArrayInput is an input type that accepts ArchiveMapMapArray and ArchiveMapMapArrayOutput values.
type ArchiveMapMapArrayInput interface {
	Input

	ToArchiveMapMapArrayOutput() ArchiveMapMapArrayOutput
	ToArchiveMapMapArrayOutputWithContext(ctx context.Context) ArchiveMapMapArrayOutput
}

// ArchiveMapMapArray is an input type for []ArchiveMapMapInput values.
type ArchiveMapMapArray []ArchiveMapMapInput

// ElementType returns the element type of this Input ([]map[string]map[string]Archive).
func (ArchiveMapMapArray) ElementType() reflect.Type {
	return archiveMapMapArrayType
}

func (in ArchiveMapMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]Archive] {
	return pulumix.Output[[]map[string]map[string]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveMapMapArray) ToArchiveMapMapArrayOutput() ArchiveMapMapArrayOutput {
	return ToOutput(in).(ArchiveMapMapArrayOutput)
}

func (in ArchiveMapMapArray) ToArchiveMapMapArrayOutputWithContext(ctx context.Context) ArchiveMapMapArrayOutput {
	return ToOutputWithContext(ctx, in).(ArchiveMapMapArrayOutput)
}

// ArchiveMapMapArrayOutput is an Output that returns []map[string]map[string]Archive values.
type ArchiveMapMapArrayOutput struct{ *OutputState }

func (ArchiveMapMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveMapMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]Archive] {
	return pulumix.Output[[]map[string]map[string]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]map[string]Archive).
func (ArchiveMapMapArrayOutput) ElementType() reflect.Type {
	return archiveMapMapArrayType
}

func (o ArchiveMapMapArrayOutput) ToArchiveMapMapArrayOutput() ArchiveMapMapArrayOutput {
	return o
}

func (o ArchiveMapMapArrayOutput) ToArchiveMapMapArrayOutputWithContext(ctx context.Context) ArchiveMapMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o ArchiveMapMapArrayOutput) Index(i IntInput) ArchiveMapMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]map[string]Archive {
		arr := vs[0].([]map[string]map[string]Archive)
		idx := vs[1].(int)
		var ret map[string]map[string]Archive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(ArchiveMapMapOutput)
}

func ToArchiveMapMapArray(in []map[string]map[string]Archive) ArchiveMapMapArray {
	a := make(ArchiveMapMapArray, len(in))
	for i, v := range in {
		a[i] = ToArchiveMapMap(v)
	}
	return a
}

func ToArchiveMapMapArrayOutput(in []ArchiveMapMapOutput) ArchiveMapMapArrayOutput {
	a := make(ArchiveMapMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToArchiveMapMapArrayOutput()
}

var archiveArrayMapArrayType = reflect.TypeOf((*[]map[string][]Archive)(nil)).Elem()

// ArchiveArrayMapArrayInput is an input type that accepts ArchiveArrayMapArray and ArchiveArrayMapArrayOutput values.
type ArchiveArrayMapArrayInput interface {
	Input

	ToArchiveArrayMapArrayOutput() ArchiveArrayMapArrayOutput
	ToArchiveArrayMapArrayOutputWithContext(ctx context.Context) ArchiveArrayMapArrayOutput
}

// ArchiveArrayMapArray is an input type for []ArchiveArrayMapInput values.
type ArchiveArrayMapArray []ArchiveArrayMapInput

// ElementType returns the element type of this Input ([]map[string][]Archive).
func (ArchiveArrayMapArray) ElementType() reflect.Type {
	return archiveArrayMapArrayType
}

func (in ArchiveArrayMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]Archive] {
	return pulumix.Output[[]map[string][]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveArrayMapArray) ToArchiveArrayMapArrayOutput() ArchiveArrayMapArrayOutput {
	return ToOutput(in).(ArchiveArrayMapArrayOutput)
}

func (in ArchiveArrayMapArray) ToArchiveArrayMapArrayOutputWithContext(ctx context.Context) ArchiveArrayMapArrayOutput {
	return ToOutputWithContext(ctx, in).(ArchiveArrayMapArrayOutput)
}

// ArchiveArrayMapArrayOutput is an Output that returns []map[string][]Archive values.
type ArchiveArrayMapArrayOutput struct{ *OutputState }

func (ArchiveArrayMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveArrayMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]Archive] {
	return pulumix.Output[[]map[string][]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string][]Archive).
func (ArchiveArrayMapArrayOutput) ElementType() reflect.Type {
	return archiveArrayMapArrayType
}

func (o ArchiveArrayMapArrayOutput) ToArchiveArrayMapArrayOutput() ArchiveArrayMapArrayOutput {
	return o
}

func (o ArchiveArrayMapArrayOutput) ToArchiveArrayMapArrayOutputWithContext(ctx context.Context) ArchiveArrayMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o ArchiveArrayMapArrayOutput) Index(i IntInput) ArchiveArrayMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string][]Archive {
		arr := vs[0].([]map[string][]Archive)
		idx := vs[1].(int)
		var ret map[string][]Archive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(ArchiveArrayMapOutput)
}

func ToArchiveArrayMapArray(in []map[string][]Archive) ArchiveArrayMapArray {
	a := make(ArchiveArrayMapArray, len(in))
	for i, v := range in {
		a[i] = ToArchiveArrayMap(v)
	}
	return a
}

func ToArchiveArrayMapArrayOutput(in []ArchiveArrayMapOutput) ArchiveArrayMapArrayOutput {
	a := make(ArchiveArrayMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToArchiveArrayMapArrayOutput()
}

var archiveArrayArrayMapType = reflect.TypeOf((*map[string][][]Archive)(nil)).Elem()

// ArchiveArrayArrayMapInput is an input type that accepts ArchiveArrayArrayMap and ArchiveArrayArrayMapOutput values.
type ArchiveArrayArrayMapInput interface {
	Input

	ToArchiveArrayArrayMapOutput() ArchiveArrayArrayMapOutput
	ToArchiveArrayArrayMapOutputWithContext(ctx context.Context) ArchiveArrayArrayMapOutput
}

// ArchiveArrayArrayMap is an input type for map[string]ArchiveArrayArrayInput values.
type ArchiveArrayArrayMap map[string]ArchiveArrayArrayInput

// ElementType returns the element type of this Input (map[string][][]Archive).
func (ArchiveArrayArrayMap) ElementType() reflect.Type {
	return archiveArrayArrayMapType
}

func (in ArchiveArrayArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][][]Archive] {
	return pulumix.Output[map[string][][]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveArrayArrayMap) ToArchiveArrayArrayMapOutput() ArchiveArrayArrayMapOutput {
	return ToOutput(in).(ArchiveArrayArrayMapOutput)
}

func (in ArchiveArrayArrayMap) ToArchiveArrayArrayMapOutputWithContext(ctx context.Context) ArchiveArrayArrayMapOutput {
	return ToOutputWithContext(ctx, in).(ArchiveArrayArrayMapOutput)
}

// ArchiveArrayArrayMapOutput is an Output that returns map[string][][]Archive values.
type ArchiveArrayArrayMapOutput struct{ *OutputState }

func (ArchiveArrayArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveArrayArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][][]Archive] {
	return pulumix.Output[map[string][][]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][][]Archive).
func (ArchiveArrayArrayMapOutput) ElementType() reflect.Type {
	return archiveArrayArrayMapType
}

func (o ArchiveArrayArrayMapOutput) ToArchiveArrayArrayMapOutput() ArchiveArrayArrayMapOutput {
	return o
}

func (o ArchiveArrayArrayMapOutput) ToArchiveArrayArrayMapOutputWithContext(ctx context.Context) ArchiveArrayArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o ArchiveArrayArrayMapOutput) MapIndex(k StringInput) ArchiveArrayArrayOutput {
	return All(o, k).ApplyT(func(vs []any) [][]Archive {
		return vs[0].(map[string][][]Archive)[vs[1].(string)]
	}).(ArchiveArrayArrayOutput)
}

func ToArchiveArrayArrayMap(in map[string][][]Archive) ArchiveArrayArrayMap {
	m := make(ArchiveArrayArrayMap)
	for k, v := range in {
		m[k] = ToArchiveArrayArray(v)
	}
	return m
}

func ToArchiveArrayArrayMapOutput(in map[string]ArchiveArrayArrayOutput) ArchiveArrayArrayMapOutput {
	m := make(ArchiveArrayArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToArchiveArrayArrayMapOutput()
}

var archiveArrayArrayArrayType = reflect.TypeOf((*[][][]Archive)(nil)).Elem()

// ArchiveArrayArrayArrayInput is an input type that accepts ArchiveArrayArrayArray and ArchiveArrayArrayArrayOutput values.
type ArchiveArrayArrayArrayInput interface {
	Input

	ToArchiveArrayArrayArrayOutput() ArchiveArrayArrayArrayOutput
	ToArchiveArrayArrayArrayOutputWithContext(ctx context.Context) ArchiveArrayArrayArrayOutput
}

// ArchiveArrayArrayArray is an input type for []ArchiveArrayArrayInput values.
type ArchiveArrayArrayArray []ArchiveArrayArrayInput

// ElementType returns the element type of this Input ([][][]Archive).
func (ArchiveArrayArrayArray) ElementType() reflect.Type {
	return archiveArrayArrayArrayType
}

func (in ArchiveArrayArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][][]Archive] {
	return pulumix.Output[[][][]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveArrayArrayArray) ToArchiveArrayArrayArrayOutput() ArchiveArrayArrayArrayOutput {
	return ToOutput(in).(ArchiveArrayArrayArrayOutput)
}

func (in ArchiveArrayArrayArray) ToArchiveArrayArrayArrayOutputWithContext(ctx context.Context) ArchiveArrayArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(ArchiveArrayArrayArrayOutput)
}

// ArchiveArrayArrayArrayOutput is an Output that returns [][][]Archive values.
type ArchiveArrayArrayArrayOutput struct{ *OutputState }

func (ArchiveArrayArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveArrayArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][][]Archive] {
	return pulumix.Output[[][][]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][][]Archive).
func (ArchiveArrayArrayArrayOutput) ElementType() reflect.Type {
	return archiveArrayArrayArrayType
}

func (o ArchiveArrayArrayArrayOutput) ToArchiveArrayArrayArrayOutput() ArchiveArrayArrayArrayOutput {
	return o
}

func (o ArchiveArrayArrayArrayOutput) ToArchiveArrayArrayArrayOutputWithContext(ctx context.Context) ArchiveArrayArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o ArchiveArrayArrayArrayOutput) Index(i IntInput) ArchiveArrayArrayOutput {
	return All(o, i).ApplyT(func(vs []any) [][]Archive {
		arr := vs[0].([][][]Archive)
		idx := vs[1].(int)
		var ret [][]Archive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(ArchiveArrayArrayOutput)
}

func ToArchiveArrayArrayArray(in [][][]Archive) ArchiveArrayArrayArray {
	a := make(ArchiveArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = ToArchiveArrayArray(v)
	}
	return a
}

func ToArchiveArrayArrayArrayOutput(in []ArchiveArrayArrayOutput) ArchiveArrayArrayArrayOutput {
	a := make(ArchiveArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToArchiveArrayArrayArrayOutput()
}

var archiveMapMapMapType = reflect.TypeOf((*map[string]map[string]map[string]Archive)(nil)).Elem()

// ArchiveMapMapMapInput is an input type that accepts ArchiveMapMapMap and ArchiveMapMapMapOutput values.
type ArchiveMapMapMapInput interface {
	Input

	ToArchiveMapMapMapOutput() ArchiveMapMapMapOutput
	ToArchiveMapMapMapOutputWithContext(ctx context.Context) ArchiveMapMapMapOutput
}

// ArchiveMapMapMap is an input type for map[string]ArchiveMapMapInput values.
type ArchiveMapMapMap map[string]ArchiveMapMapInput

// ElementType returns the element type of this Input (map[string]map[string]map[string]Archive).
func (ArchiveMapMapMap) ElementType() reflect.Type {
	return archiveMapMapMapType
}

func (in ArchiveMapMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]Archive] {
	return pulumix.Output[map[string]map[string]map[string]Archive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArchiveMapMapMap) ToArchiveMapMapMapOutput() ArchiveMapMapMapOutput {
	return ToOutput(in).(ArchiveMapMapMapOutput)
}

func (in ArchiveMapMapMap) ToArchiveMapMapMapOutputWithContext(ctx context.Context) ArchiveMapMapMapOutput {
	return ToOutputWithContext(ctx, in).(ArchiveMapMapMapOutput)
}

// ArchiveMapMapMapOutput is an Output that returns map[string]map[string]map[string]Archive values.
type ArchiveMapMapMapOutput struct{ *OutputState }

func (ArchiveMapMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArchiveMapMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]Archive] {
	return pulumix.Output[map[string]map[string]map[string]Archive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]map[string]Archive).
func (ArchiveMapMapMapOutput) ElementType() reflect.Type {
	return archiveMapMapMapType
}

func (o ArchiveMapMapMapOutput) ToArchiveMapMapMapOutput() ArchiveMapMapMapOutput {
	return o
}

func (o ArchiveMapMapMapOutput) ToArchiveMapMapMapOutputWithContext(ctx context.Context) ArchiveMapMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o ArchiveMapMapMapOutput) MapIndex(k StringInput) ArchiveMapMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]map[string]Archive {
		return vs[0].(map[string]map[string]map[string]Archive)[vs[1].(string)]
	}).(ArchiveMapMapOutput)
}

func ToArchiveMapMapMap(in map[string]map[string]map[string]Archive) ArchiveMapMapMap {
	m := make(ArchiveMapMapMap)
	for k, v := range in {
		m[k] = ToArchiveMapMap(v)
	}
	return m
}

func ToArchiveMapMapMapOutput(in map[string]ArchiveMapMapOutput) ArchiveMapMapMapOutput {
	m := make(ArchiveMapMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToArchiveMapMapMapOutput()
}

var assetType = reflect.TypeOf((*Asset)(nil)).Elem()

// AssetInput is an input type that accepts Asset and AssetOutput values.
type AssetInput interface {
	Input

	ToAssetOutput() AssetOutput
	ToAssetOutputWithContext(ctx context.Context) AssetOutput
}

// ElementType returns the element type of this Input (Asset).
func (*asset) ElementType() reflect.Type {
	return assetType
}

func (in *asset) ToOutput(ctx context.Context) pulumix.Output[Asset] {
	return pulumix.Output[Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in *asset) ToAssetOutput() AssetOutput {
	return ToOutput(in).(AssetOutput)
}

func (in *asset) ToAssetOutputWithContext(ctx context.Context) AssetOutput {
	return ToOutputWithContext(ctx, in).(AssetOutput)
}

func (in *asset) ToAssetOrArchiveOutput() AssetOrArchiveOutput {
	return in.ToAssetOrArchiveOutputWithContext(context.Background())
}

func (in *asset) ToAssetOrArchiveOutputWithContext(ctx context.Context) AssetOrArchiveOutput {
	return in.ToAssetOutputWithContext(ctx).ToAssetOrArchiveOutputWithContext(ctx)
}

// AssetOutput is an Output that returns Asset values.
type AssetOutput struct{ *OutputState }

func (AssetOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOutput) ToOutput(ctx context.Context) pulumix.Output[Asset] {
	return pulumix.Output[Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (Asset).
func (AssetOutput) ElementType() reflect.Type {
	return assetType
}

func (o AssetOutput) ToAssetOutput() AssetOutput {
	return o
}

func (o AssetOutput) ToAssetOutputWithContext(ctx context.Context) AssetOutput {
	return o
}

func (o AssetOutput) ToAssetOrArchiveOutput() AssetOrArchiveOutput {
	return o.ToAssetOrArchiveOutputWithContext(context.Background())
}

func (o AssetOutput) ToAssetOrArchiveOutputWithContext(ctx context.Context) AssetOrArchiveOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Asset) AssetOrArchive {
		return (AssetOrArchive)(v)
	}).(AssetOrArchiveOutput)
}

var assetArrayType = reflect.TypeOf((*[]Asset)(nil)).Elem()

// AssetArrayInput is an input type that accepts AssetArray and AssetArrayOutput values.
type AssetArrayInput interface {
	Input

	ToAssetArrayOutput() AssetArrayOutput
	ToAssetArrayOutputWithContext(ctx context.Context) AssetArrayOutput
}

// AssetArray is an input type for []AssetInput values.
type AssetArray []AssetInput

// ElementType returns the element type of this Input ([]Asset).
func (AssetArray) ElementType() reflect.Type {
	return assetArrayType
}

func (in AssetArray) ToOutput(ctx context.Context) pulumix.Output[[]Asset] {
	return pulumix.Output[[]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetArray) ToAssetArrayOutput() AssetArrayOutput {
	return ToOutput(in).(AssetArrayOutput)
}

func (in AssetArray) ToAssetArrayOutputWithContext(ctx context.Context) AssetArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetArrayOutput)
}

// AssetArrayOutput is an Output that returns []Asset values.
type AssetArrayOutput struct{ *OutputState }

func (AssetArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]Asset] {
	return pulumix.Output[[]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]Asset).
func (AssetArrayOutput) ElementType() reflect.Type {
	return assetArrayType
}

func (o AssetArrayOutput) ToAssetArrayOutput() AssetArrayOutput {
	return o
}

func (o AssetArrayOutput) ToAssetArrayOutputWithContext(ctx context.Context) AssetArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetArrayOutput) Index(i IntInput) AssetOutput {
	return All(o, i).ApplyT(func(vs []any) Asset {
		arr := vs[0].([]Asset)
		idx := vs[1].(int)
		var ret Asset
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetOutput)
}

func ToAssetArray(in []Asset) AssetArray {
	a := make(AssetArray, len(in))
	for i, v := range in {
		a[i] = (v)
	}
	return a
}

func ToAssetArrayOutput(in []AssetOutput) AssetArrayOutput {
	a := make(AssetArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToAssetArrayOutput()
}

var assetMapType = reflect.TypeOf((*map[string]Asset)(nil)).Elem()

// AssetMapInput is an input type that accepts AssetMap and AssetMapOutput values.
type AssetMapInput interface {
	Input

	ToAssetMapOutput() AssetMapOutput
	ToAssetMapOutputWithContext(ctx context.Context) AssetMapOutput
}

// AssetMap is an input type for map[string]AssetInput values.
type AssetMap map[string]AssetInput

// ElementType returns the element type of this Input (map[string]Asset).
func (AssetMap) ElementType() reflect.Type {
	return assetMapType
}

func (in AssetMap) ToOutput(ctx context.Context) pulumix.Output[map[string]Asset] {
	return pulumix.Output[map[string]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetMap) ToAssetMapOutput() AssetMapOutput {
	return ToOutput(in).(AssetMapOutput)
}

func (in AssetMap) ToAssetMapOutputWithContext(ctx context.Context) AssetMapOutput {
	return ToOutputWithContext(ctx, in).(AssetMapOutput)
}

// AssetMapOutput is an Output that returns map[string]Asset values.
type AssetMapOutput struct{ *OutputState }

func (AssetMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]Asset] {
	return pulumix.Output[map[string]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]Asset).
func (AssetMapOutput) ElementType() reflect.Type {
	return assetMapType
}

func (o AssetMapOutput) ToAssetMapOutput() AssetMapOutput {
	return o
}

func (o AssetMapOutput) ToAssetMapOutputWithContext(ctx context.Context) AssetMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetMapOutput) MapIndex(k StringInput) AssetOutput {
	return All(o, k).ApplyT(func(vs []any) Asset {
		return vs[0].(map[string]Asset)[vs[1].(string)]
	}).(AssetOutput)
}

func ToAssetMap(in map[string]Asset) AssetMap {
	m := make(AssetMap)
	for k, v := range in {
		m[k] = (v)
	}
	return m
}

func ToAssetMapOutput(in map[string]AssetOutput) AssetMapOutput {
	m := make(AssetMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToAssetMapOutput()
}

var assetArrayMapType = reflect.TypeOf((*map[string][]Asset)(nil)).Elem()

// AssetArrayMapInput is an input type that accepts AssetArrayMap and AssetArrayMapOutput values.
type AssetArrayMapInput interface {
	Input

	ToAssetArrayMapOutput() AssetArrayMapOutput
	ToAssetArrayMapOutputWithContext(ctx context.Context) AssetArrayMapOutput
}

// AssetArrayMap is an input type for map[string]AssetArrayInput values.
type AssetArrayMap map[string]AssetArrayInput

// ElementType returns the element type of this Input (map[string][]Asset).
func (AssetArrayMap) ElementType() reflect.Type {
	return assetArrayMapType
}

func (in AssetArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]Asset] {
	return pulumix.Output[map[string][]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetArrayMap) ToAssetArrayMapOutput() AssetArrayMapOutput {
	return ToOutput(in).(AssetArrayMapOutput)
}

func (in AssetArrayMap) ToAssetArrayMapOutputWithContext(ctx context.Context) AssetArrayMapOutput {
	return ToOutputWithContext(ctx, in).(AssetArrayMapOutput)
}

// AssetArrayMapOutput is an Output that returns map[string][]Asset values.
type AssetArrayMapOutput struct{ *OutputState }

func (AssetArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]Asset] {
	return pulumix.Output[map[string][]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]Asset).
func (AssetArrayMapOutput) ElementType() reflect.Type {
	return assetArrayMapType
}

func (o AssetArrayMapOutput) ToAssetArrayMapOutput() AssetArrayMapOutput {
	return o
}

func (o AssetArrayMapOutput) ToAssetArrayMapOutputWithContext(ctx context.Context) AssetArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetArrayMapOutput) MapIndex(k StringInput) AssetArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []Asset {
		return vs[0].(map[string][]Asset)[vs[1].(string)]
	}).(AssetArrayOutput)
}

func ToAssetArrayMap(in map[string][]Asset) AssetArrayMap {
	m := make(AssetArrayMap)
	for k, v := range in {
		m[k] = ToAssetArray(v)
	}
	return m
}

func ToAssetArrayMapOutput(in map[string]AssetArrayOutput) AssetArrayMapOutput {
	m := make(AssetArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToAssetArrayMapOutput()
}

var assetMapArrayType = reflect.TypeOf((*[]map[string]Asset)(nil)).Elem()

// AssetMapArrayInput is an input type that accepts AssetMapArray and AssetMapArrayOutput values.
type AssetMapArrayInput interface {
	Input

	ToAssetMapArrayOutput() AssetMapArrayOutput
	ToAssetMapArrayOutputWithContext(ctx context.Context) AssetMapArrayOutput
}

// AssetMapArray is an input type for []AssetMapInput values.
type AssetMapArray []AssetMapInput

// ElementType returns the element type of this Input ([]map[string]Asset).
func (AssetMapArray) ElementType() reflect.Type {
	return assetMapArrayType
}

func (in AssetMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]Asset] {
	return pulumix.Output[[]map[string]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetMapArray) ToAssetMapArrayOutput() AssetMapArrayOutput {
	return ToOutput(in).(AssetMapArrayOutput)
}

func (in AssetMapArray) ToAssetMapArrayOutputWithContext(ctx context.Context) AssetMapArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetMapArrayOutput)
}

// AssetMapArrayOutput is an Output that returns []map[string]Asset values.
type AssetMapArrayOutput struct{ *OutputState }

func (AssetMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]Asset] {
	return pulumix.Output[[]map[string]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]Asset).
func (AssetMapArrayOutput) ElementType() reflect.Type {
	return assetMapArrayType
}

func (o AssetMapArrayOutput) ToAssetMapArrayOutput() AssetMapArrayOutput {
	return o
}

func (o AssetMapArrayOutput) ToAssetMapArrayOutputWithContext(ctx context.Context) AssetMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetMapArrayOutput) Index(i IntInput) AssetMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]Asset {
		arr := vs[0].([]map[string]Asset)
		idx := vs[1].(int)
		var ret map[string]Asset
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetMapOutput)
}

func ToAssetMapArray(in []map[string]Asset) AssetMapArray {
	a := make(AssetMapArray, len(in))
	for i, v := range in {
		a[i] = ToAssetMap(v)
	}
	return a
}

func ToAssetMapArrayOutput(in []AssetMapOutput) AssetMapArrayOutput {
	a := make(AssetMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToAssetMapArrayOutput()
}

var assetMapMapType = reflect.TypeOf((*map[string]map[string]Asset)(nil)).Elem()

// AssetMapMapInput is an input type that accepts AssetMapMap and AssetMapMapOutput values.
type AssetMapMapInput interface {
	Input

	ToAssetMapMapOutput() AssetMapMapOutput
	ToAssetMapMapOutputWithContext(ctx context.Context) AssetMapMapOutput
}

// AssetMapMap is an input type for map[string]AssetMapInput values.
type AssetMapMap map[string]AssetMapInput

// ElementType returns the element type of this Input (map[string]map[string]Asset).
func (AssetMapMap) ElementType() reflect.Type {
	return assetMapMapType
}

func (in AssetMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]Asset] {
	return pulumix.Output[map[string]map[string]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetMapMap) ToAssetMapMapOutput() AssetMapMapOutput {
	return ToOutput(in).(AssetMapMapOutput)
}

func (in AssetMapMap) ToAssetMapMapOutputWithContext(ctx context.Context) AssetMapMapOutput {
	return ToOutputWithContext(ctx, in).(AssetMapMapOutput)
}

// AssetMapMapOutput is an Output that returns map[string]map[string]Asset values.
type AssetMapMapOutput struct{ *OutputState }

func (AssetMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]Asset] {
	return pulumix.Output[map[string]map[string]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]Asset).
func (AssetMapMapOutput) ElementType() reflect.Type {
	return assetMapMapType
}

func (o AssetMapMapOutput) ToAssetMapMapOutput() AssetMapMapOutput {
	return o
}

func (o AssetMapMapOutput) ToAssetMapMapOutputWithContext(ctx context.Context) AssetMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetMapMapOutput) MapIndex(k StringInput) AssetMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]Asset {
		return vs[0].(map[string]map[string]Asset)[vs[1].(string)]
	}).(AssetMapOutput)
}

func ToAssetMapMap(in map[string]map[string]Asset) AssetMapMap {
	m := make(AssetMapMap)
	for k, v := range in {
		m[k] = ToAssetMap(v)
	}
	return m
}

func ToAssetMapMapOutput(in map[string]AssetMapOutput) AssetMapMapOutput {
	m := make(AssetMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToAssetMapMapOutput()
}

var assetArrayArrayType = reflect.TypeOf((*[][]Asset)(nil)).Elem()

// AssetArrayArrayInput is an input type that accepts AssetArrayArray and AssetArrayArrayOutput values.
type AssetArrayArrayInput interface {
	Input

	ToAssetArrayArrayOutput() AssetArrayArrayOutput
	ToAssetArrayArrayOutputWithContext(ctx context.Context) AssetArrayArrayOutput
}

// AssetArrayArray is an input type for []AssetArrayInput values.
type AssetArrayArray []AssetArrayInput

// ElementType returns the element type of this Input ([][]Asset).
func (AssetArrayArray) ElementType() reflect.Type {
	return assetArrayArrayType
}

func (in AssetArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][]Asset] {
	return pulumix.Output[[][]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetArrayArray) ToAssetArrayArrayOutput() AssetArrayArrayOutput {
	return ToOutput(in).(AssetArrayArrayOutput)
}

func (in AssetArrayArray) ToAssetArrayArrayOutputWithContext(ctx context.Context) AssetArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetArrayArrayOutput)
}

// AssetArrayArrayOutput is an Output that returns [][]Asset values.
type AssetArrayArrayOutput struct{ *OutputState }

func (AssetArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][]Asset] {
	return pulumix.Output[[][]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][]Asset).
func (AssetArrayArrayOutput) ElementType() reflect.Type {
	return assetArrayArrayType
}

func (o AssetArrayArrayOutput) ToAssetArrayArrayOutput() AssetArrayArrayOutput {
	return o
}

func (o AssetArrayArrayOutput) ToAssetArrayArrayOutputWithContext(ctx context.Context) AssetArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetArrayArrayOutput) Index(i IntInput) AssetArrayOutput {
	return All(o, i).ApplyT(func(vs []any) []Asset {
		arr := vs[0].([][]Asset)
		idx := vs[1].(int)
		var ret []Asset
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetArrayOutput)
}

func ToAssetArrayArray(in [][]Asset) AssetArrayArray {
	a := make(AssetArrayArray, len(in))
	for i, v := range in {
		a[i] = ToAssetArray(v)
	}
	return a
}

func ToAssetArrayArrayOutput(in []AssetArrayOutput) AssetArrayArrayOutput {
	a := make(AssetArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToAssetArrayArrayOutput()
}

var assetArrayMapMapType = reflect.TypeOf((*map[string]map[string][]Asset)(nil)).Elem()

// AssetArrayMapMapInput is an input type that accepts AssetArrayMapMap and AssetArrayMapMapOutput values.
type AssetArrayMapMapInput interface {
	Input

	ToAssetArrayMapMapOutput() AssetArrayMapMapOutput
	ToAssetArrayMapMapOutputWithContext(ctx context.Context) AssetArrayMapMapOutput
}

// AssetArrayMapMap is an input type for map[string]AssetArrayMapInput values.
type AssetArrayMapMap map[string]AssetArrayMapInput

// ElementType returns the element type of this Input (map[string]map[string][]Asset).
func (AssetArrayMapMap) ElementType() reflect.Type {
	return assetArrayMapMapType
}

func (in AssetArrayMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]Asset] {
	return pulumix.Output[map[string]map[string][]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetArrayMapMap) ToAssetArrayMapMapOutput() AssetArrayMapMapOutput {
	return ToOutput(in).(AssetArrayMapMapOutput)
}

func (in AssetArrayMapMap) ToAssetArrayMapMapOutputWithContext(ctx context.Context) AssetArrayMapMapOutput {
	return ToOutputWithContext(ctx, in).(AssetArrayMapMapOutput)
}

// AssetArrayMapMapOutput is an Output that returns map[string]map[string][]Asset values.
type AssetArrayMapMapOutput struct{ *OutputState }

func (AssetArrayMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetArrayMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]Asset] {
	return pulumix.Output[map[string]map[string][]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string][]Asset).
func (AssetArrayMapMapOutput) ElementType() reflect.Type {
	return assetArrayMapMapType
}

func (o AssetArrayMapMapOutput) ToAssetArrayMapMapOutput() AssetArrayMapMapOutput {
	return o
}

func (o AssetArrayMapMapOutput) ToAssetArrayMapMapOutputWithContext(ctx context.Context) AssetArrayMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetArrayMapMapOutput) MapIndex(k StringInput) AssetArrayMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string][]Asset {
		return vs[0].(map[string]map[string][]Asset)[vs[1].(string)]
	}).(AssetArrayMapOutput)
}

func ToAssetArrayMapMap(in map[string]map[string][]Asset) AssetArrayMapMap {
	m := make(AssetArrayMapMap)
	for k, v := range in {
		m[k] = ToAssetArrayMap(v)
	}
	return m
}

func ToAssetArrayMapMapOutput(in map[string]AssetArrayMapOutput) AssetArrayMapMapOutput {
	m := make(AssetArrayMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToAssetArrayMapMapOutput()
}

var assetMapArrayMapType = reflect.TypeOf((*map[string][]map[string]Asset)(nil)).Elem()

// AssetMapArrayMapInput is an input type that accepts AssetMapArrayMap and AssetMapArrayMapOutput values.
type AssetMapArrayMapInput interface {
	Input

	ToAssetMapArrayMapOutput() AssetMapArrayMapOutput
	ToAssetMapArrayMapOutputWithContext(ctx context.Context) AssetMapArrayMapOutput
}

// AssetMapArrayMap is an input type for map[string]AssetMapArrayInput values.
type AssetMapArrayMap map[string]AssetMapArrayInput

// ElementType returns the element type of this Input (map[string][]map[string]Asset).
func (AssetMapArrayMap) ElementType() reflect.Type {
	return assetMapArrayMapType
}

func (in AssetMapArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]Asset] {
	return pulumix.Output[map[string][]map[string]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetMapArrayMap) ToAssetMapArrayMapOutput() AssetMapArrayMapOutput {
	return ToOutput(in).(AssetMapArrayMapOutput)
}

func (in AssetMapArrayMap) ToAssetMapArrayMapOutputWithContext(ctx context.Context) AssetMapArrayMapOutput {
	return ToOutputWithContext(ctx, in).(AssetMapArrayMapOutput)
}

// AssetMapArrayMapOutput is an Output that returns map[string][]map[string]Asset values.
type AssetMapArrayMapOutput struct{ *OutputState }

func (AssetMapArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetMapArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]Asset] {
	return pulumix.Output[map[string][]map[string]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]map[string]Asset).
func (AssetMapArrayMapOutput) ElementType() reflect.Type {
	return assetMapArrayMapType
}

func (o AssetMapArrayMapOutput) ToAssetMapArrayMapOutput() AssetMapArrayMapOutput {
	return o
}

func (o AssetMapArrayMapOutput) ToAssetMapArrayMapOutputWithContext(ctx context.Context) AssetMapArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetMapArrayMapOutput) MapIndex(k StringInput) AssetMapArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []map[string]Asset {
		return vs[0].(map[string][]map[string]Asset)[vs[1].(string)]
	}).(AssetMapArrayOutput)
}

func ToAssetMapArrayMap(in map[string][]map[string]Asset) AssetMapArrayMap {
	m := make(AssetMapArrayMap)
	for k, v := range in {
		m[k] = ToAssetMapArray(v)
	}
	return m
}

func ToAssetMapArrayMapOutput(in map[string]AssetMapArrayOutput) AssetMapArrayMapOutput {
	m := make(AssetMapArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToAssetMapArrayMapOutput()
}

var assetMapMapArrayType = reflect.TypeOf((*[]map[string]map[string]Asset)(nil)).Elem()

// AssetMapMapArrayInput is an input type that accepts AssetMapMapArray and AssetMapMapArrayOutput values.
type AssetMapMapArrayInput interface {
	Input

	ToAssetMapMapArrayOutput() AssetMapMapArrayOutput
	ToAssetMapMapArrayOutputWithContext(ctx context.Context) AssetMapMapArrayOutput
}

// AssetMapMapArray is an input type for []AssetMapMapInput values.
type AssetMapMapArray []AssetMapMapInput

// ElementType returns the element type of this Input ([]map[string]map[string]Asset).
func (AssetMapMapArray) ElementType() reflect.Type {
	return assetMapMapArrayType
}

func (in AssetMapMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]Asset] {
	return pulumix.Output[[]map[string]map[string]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetMapMapArray) ToAssetMapMapArrayOutput() AssetMapMapArrayOutput {
	return ToOutput(in).(AssetMapMapArrayOutput)
}

func (in AssetMapMapArray) ToAssetMapMapArrayOutputWithContext(ctx context.Context) AssetMapMapArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetMapMapArrayOutput)
}

// AssetMapMapArrayOutput is an Output that returns []map[string]map[string]Asset values.
type AssetMapMapArrayOutput struct{ *OutputState }

func (AssetMapMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetMapMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]Asset] {
	return pulumix.Output[[]map[string]map[string]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]map[string]Asset).
func (AssetMapMapArrayOutput) ElementType() reflect.Type {
	return assetMapMapArrayType
}

func (o AssetMapMapArrayOutput) ToAssetMapMapArrayOutput() AssetMapMapArrayOutput {
	return o
}

func (o AssetMapMapArrayOutput) ToAssetMapMapArrayOutputWithContext(ctx context.Context) AssetMapMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetMapMapArrayOutput) Index(i IntInput) AssetMapMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]map[string]Asset {
		arr := vs[0].([]map[string]map[string]Asset)
		idx := vs[1].(int)
		var ret map[string]map[string]Asset
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetMapMapOutput)
}

func ToAssetMapMapArray(in []map[string]map[string]Asset) AssetMapMapArray {
	a := make(AssetMapMapArray, len(in))
	for i, v := range in {
		a[i] = ToAssetMapMap(v)
	}
	return a
}

func ToAssetMapMapArrayOutput(in []AssetMapMapOutput) AssetMapMapArrayOutput {
	a := make(AssetMapMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToAssetMapMapArrayOutput()
}

var assetArrayMapArrayType = reflect.TypeOf((*[]map[string][]Asset)(nil)).Elem()

// AssetArrayMapArrayInput is an input type that accepts AssetArrayMapArray and AssetArrayMapArrayOutput values.
type AssetArrayMapArrayInput interface {
	Input

	ToAssetArrayMapArrayOutput() AssetArrayMapArrayOutput
	ToAssetArrayMapArrayOutputWithContext(ctx context.Context) AssetArrayMapArrayOutput
}

// AssetArrayMapArray is an input type for []AssetArrayMapInput values.
type AssetArrayMapArray []AssetArrayMapInput

// ElementType returns the element type of this Input ([]map[string][]Asset).
func (AssetArrayMapArray) ElementType() reflect.Type {
	return assetArrayMapArrayType
}

func (in AssetArrayMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]Asset] {
	return pulumix.Output[[]map[string][]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetArrayMapArray) ToAssetArrayMapArrayOutput() AssetArrayMapArrayOutput {
	return ToOutput(in).(AssetArrayMapArrayOutput)
}

func (in AssetArrayMapArray) ToAssetArrayMapArrayOutputWithContext(ctx context.Context) AssetArrayMapArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetArrayMapArrayOutput)
}

// AssetArrayMapArrayOutput is an Output that returns []map[string][]Asset values.
type AssetArrayMapArrayOutput struct{ *OutputState }

func (AssetArrayMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetArrayMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]Asset] {
	return pulumix.Output[[]map[string][]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string][]Asset).
func (AssetArrayMapArrayOutput) ElementType() reflect.Type {
	return assetArrayMapArrayType
}

func (o AssetArrayMapArrayOutput) ToAssetArrayMapArrayOutput() AssetArrayMapArrayOutput {
	return o
}

func (o AssetArrayMapArrayOutput) ToAssetArrayMapArrayOutputWithContext(ctx context.Context) AssetArrayMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetArrayMapArrayOutput) Index(i IntInput) AssetArrayMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string][]Asset {
		arr := vs[0].([]map[string][]Asset)
		idx := vs[1].(int)
		var ret map[string][]Asset
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetArrayMapOutput)
}

func ToAssetArrayMapArray(in []map[string][]Asset) AssetArrayMapArray {
	a := make(AssetArrayMapArray, len(in))
	for i, v := range in {
		a[i] = ToAssetArrayMap(v)
	}
	return a
}

func ToAssetArrayMapArrayOutput(in []AssetArrayMapOutput) AssetArrayMapArrayOutput {
	a := make(AssetArrayMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToAssetArrayMapArrayOutput()
}

var assetArrayArrayMapType = reflect.TypeOf((*map[string][][]Asset)(nil)).Elem()

// AssetArrayArrayMapInput is an input type that accepts AssetArrayArrayMap and AssetArrayArrayMapOutput values.
type AssetArrayArrayMapInput interface {
	Input

	ToAssetArrayArrayMapOutput() AssetArrayArrayMapOutput
	ToAssetArrayArrayMapOutputWithContext(ctx context.Context) AssetArrayArrayMapOutput
}

// AssetArrayArrayMap is an input type for map[string]AssetArrayArrayInput values.
type AssetArrayArrayMap map[string]AssetArrayArrayInput

// ElementType returns the element type of this Input (map[string][][]Asset).
func (AssetArrayArrayMap) ElementType() reflect.Type {
	return assetArrayArrayMapType
}

func (in AssetArrayArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][][]Asset] {
	return pulumix.Output[map[string][][]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetArrayArrayMap) ToAssetArrayArrayMapOutput() AssetArrayArrayMapOutput {
	return ToOutput(in).(AssetArrayArrayMapOutput)
}

func (in AssetArrayArrayMap) ToAssetArrayArrayMapOutputWithContext(ctx context.Context) AssetArrayArrayMapOutput {
	return ToOutputWithContext(ctx, in).(AssetArrayArrayMapOutput)
}

// AssetArrayArrayMapOutput is an Output that returns map[string][][]Asset values.
type AssetArrayArrayMapOutput struct{ *OutputState }

func (AssetArrayArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetArrayArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][][]Asset] {
	return pulumix.Output[map[string][][]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][][]Asset).
func (AssetArrayArrayMapOutput) ElementType() reflect.Type {
	return assetArrayArrayMapType
}

func (o AssetArrayArrayMapOutput) ToAssetArrayArrayMapOutput() AssetArrayArrayMapOutput {
	return o
}

func (o AssetArrayArrayMapOutput) ToAssetArrayArrayMapOutputWithContext(ctx context.Context) AssetArrayArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetArrayArrayMapOutput) MapIndex(k StringInput) AssetArrayArrayOutput {
	return All(o, k).ApplyT(func(vs []any) [][]Asset {
		return vs[0].(map[string][][]Asset)[vs[1].(string)]
	}).(AssetArrayArrayOutput)
}

func ToAssetArrayArrayMap(in map[string][][]Asset) AssetArrayArrayMap {
	m := make(AssetArrayArrayMap)
	for k, v := range in {
		m[k] = ToAssetArrayArray(v)
	}
	return m
}

func ToAssetArrayArrayMapOutput(in map[string]AssetArrayArrayOutput) AssetArrayArrayMapOutput {
	m := make(AssetArrayArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToAssetArrayArrayMapOutput()
}

var assetArrayArrayArrayType = reflect.TypeOf((*[][][]Asset)(nil)).Elem()

// AssetArrayArrayArrayInput is an input type that accepts AssetArrayArrayArray and AssetArrayArrayArrayOutput values.
type AssetArrayArrayArrayInput interface {
	Input

	ToAssetArrayArrayArrayOutput() AssetArrayArrayArrayOutput
	ToAssetArrayArrayArrayOutputWithContext(ctx context.Context) AssetArrayArrayArrayOutput
}

// AssetArrayArrayArray is an input type for []AssetArrayArrayInput values.
type AssetArrayArrayArray []AssetArrayArrayInput

// ElementType returns the element type of this Input ([][][]Asset).
func (AssetArrayArrayArray) ElementType() reflect.Type {
	return assetArrayArrayArrayType
}

func (in AssetArrayArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][][]Asset] {
	return pulumix.Output[[][][]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetArrayArrayArray) ToAssetArrayArrayArrayOutput() AssetArrayArrayArrayOutput {
	return ToOutput(in).(AssetArrayArrayArrayOutput)
}

func (in AssetArrayArrayArray) ToAssetArrayArrayArrayOutputWithContext(ctx context.Context) AssetArrayArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetArrayArrayArrayOutput)
}

// AssetArrayArrayArrayOutput is an Output that returns [][][]Asset values.
type AssetArrayArrayArrayOutput struct{ *OutputState }

func (AssetArrayArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetArrayArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][][]Asset] {
	return pulumix.Output[[][][]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][][]Asset).
func (AssetArrayArrayArrayOutput) ElementType() reflect.Type {
	return assetArrayArrayArrayType
}

func (o AssetArrayArrayArrayOutput) ToAssetArrayArrayArrayOutput() AssetArrayArrayArrayOutput {
	return o
}

func (o AssetArrayArrayArrayOutput) ToAssetArrayArrayArrayOutputWithContext(ctx context.Context) AssetArrayArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetArrayArrayArrayOutput) Index(i IntInput) AssetArrayArrayOutput {
	return All(o, i).ApplyT(func(vs []any) [][]Asset {
		arr := vs[0].([][][]Asset)
		idx := vs[1].(int)
		var ret [][]Asset
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetArrayArrayOutput)
}

func ToAssetArrayArrayArray(in [][][]Asset) AssetArrayArrayArray {
	a := make(AssetArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = ToAssetArrayArray(v)
	}
	return a
}

func ToAssetArrayArrayArrayOutput(in []AssetArrayArrayOutput) AssetArrayArrayArrayOutput {
	a := make(AssetArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToAssetArrayArrayArrayOutput()
}

var assetMapMapMapType = reflect.TypeOf((*map[string]map[string]map[string]Asset)(nil)).Elem()

// AssetMapMapMapInput is an input type that accepts AssetMapMapMap and AssetMapMapMapOutput values.
type AssetMapMapMapInput interface {
	Input

	ToAssetMapMapMapOutput() AssetMapMapMapOutput
	ToAssetMapMapMapOutputWithContext(ctx context.Context) AssetMapMapMapOutput
}

// AssetMapMapMap is an input type for map[string]AssetMapMapInput values.
type AssetMapMapMap map[string]AssetMapMapInput

// ElementType returns the element type of this Input (map[string]map[string]map[string]Asset).
func (AssetMapMapMap) ElementType() reflect.Type {
	return assetMapMapMapType
}

func (in AssetMapMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]Asset] {
	return pulumix.Output[map[string]map[string]map[string]Asset]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetMapMapMap) ToAssetMapMapMapOutput() AssetMapMapMapOutput {
	return ToOutput(in).(AssetMapMapMapOutput)
}

func (in AssetMapMapMap) ToAssetMapMapMapOutputWithContext(ctx context.Context) AssetMapMapMapOutput {
	return ToOutputWithContext(ctx, in).(AssetMapMapMapOutput)
}

// AssetMapMapMapOutput is an Output that returns map[string]map[string]map[string]Asset values.
type AssetMapMapMapOutput struct{ *OutputState }

func (AssetMapMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetMapMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]Asset] {
	return pulumix.Output[map[string]map[string]map[string]Asset]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]map[string]Asset).
func (AssetMapMapMapOutput) ElementType() reflect.Type {
	return assetMapMapMapType
}

func (o AssetMapMapMapOutput) ToAssetMapMapMapOutput() AssetMapMapMapOutput {
	return o
}

func (o AssetMapMapMapOutput) ToAssetMapMapMapOutputWithContext(ctx context.Context) AssetMapMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetMapMapMapOutput) MapIndex(k StringInput) AssetMapMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]map[string]Asset {
		return vs[0].(map[string]map[string]map[string]Asset)[vs[1].(string)]
	}).(AssetMapMapOutput)
}

func ToAssetMapMapMap(in map[string]map[string]map[string]Asset) AssetMapMapMap {
	m := make(AssetMapMapMap)
	for k, v := range in {
		m[k] = ToAssetMapMap(v)
	}
	return m
}

func ToAssetMapMapMapOutput(in map[string]AssetMapMapOutput) AssetMapMapMapOutput {
	m := make(AssetMapMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToAssetMapMapMapOutput()
}

var assetOrArchiveType = reflect.TypeOf((*AssetOrArchive)(nil)).Elem()

// AssetOrArchiveInput is an input type that accepts AssetOrArchive and AssetOrArchiveOutput values.
type AssetOrArchiveInput interface {
	Input

	ToAssetOrArchiveOutput() AssetOrArchiveOutput
	ToAssetOrArchiveOutputWithContext(ctx context.Context) AssetOrArchiveOutput
}

// AssetOrArchiveOutput is an Output that returns AssetOrArchive values.
type AssetOrArchiveOutput struct{ *OutputState }

func (AssetOrArchiveOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveOutput) ToOutput(ctx context.Context) pulumix.Output[AssetOrArchive] {
	return pulumix.Output[AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (AssetOrArchive).
func (AssetOrArchiveOutput) ElementType() reflect.Type {
	return assetOrArchiveType
}

func (o AssetOrArchiveOutput) ToAssetOrArchiveOutput() AssetOrArchiveOutput {
	return o
}

func (o AssetOrArchiveOutput) ToAssetOrArchiveOutputWithContext(ctx context.Context) AssetOrArchiveOutput {
	return o
}

var assetOrArchiveArrayType = reflect.TypeOf((*[]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveArrayInput is an input type that accepts AssetOrArchiveArray and AssetOrArchiveArrayOutput values.
type AssetOrArchiveArrayInput interface {
	Input

	ToAssetOrArchiveArrayOutput() AssetOrArchiveArrayOutput
	ToAssetOrArchiveArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayOutput
}

// AssetOrArchiveArray is an input type for []AssetOrArchiveInput values.
type AssetOrArchiveArray []AssetOrArchiveInput

// ElementType returns the element type of this Input ([]AssetOrArchive).
func (AssetOrArchiveArray) ElementType() reflect.Type {
	return assetOrArchiveArrayType
}

func (in AssetOrArchiveArray) ToOutput(ctx context.Context) pulumix.Output[[]AssetOrArchive] {
	return pulumix.Output[[]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveArray) ToAssetOrArchiveArrayOutput() AssetOrArchiveArrayOutput {
	return ToOutput(in).(AssetOrArchiveArrayOutput)
}

func (in AssetOrArchiveArray) ToAssetOrArchiveArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveArrayOutput)
}

// AssetOrArchiveArrayOutput is an Output that returns []AssetOrArchive values.
type AssetOrArchiveArrayOutput struct{ *OutputState }

func (AssetOrArchiveArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]AssetOrArchive] {
	return pulumix.Output[[]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]AssetOrArchive).
func (AssetOrArchiveArrayOutput) ElementType() reflect.Type {
	return assetOrArchiveArrayType
}

func (o AssetOrArchiveArrayOutput) ToAssetOrArchiveArrayOutput() AssetOrArchiveArrayOutput {
	return o
}

func (o AssetOrArchiveArrayOutput) ToAssetOrArchiveArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetOrArchiveArrayOutput) Index(i IntInput) AssetOrArchiveOutput {
	return All(o, i).ApplyT(func(vs []any) AssetOrArchive {
		arr := vs[0].([]AssetOrArchive)
		idx := vs[1].(int)
		var ret AssetOrArchive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetOrArchiveOutput)
}

var assetOrArchiveMapType = reflect.TypeOf((*map[string]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveMapInput is an input type that accepts AssetOrArchiveMap and AssetOrArchiveMapOutput values.
type AssetOrArchiveMapInput interface {
	Input

	ToAssetOrArchiveMapOutput() AssetOrArchiveMapOutput
	ToAssetOrArchiveMapOutputWithContext(ctx context.Context) AssetOrArchiveMapOutput
}

// AssetOrArchiveMap is an input type for map[string]AssetOrArchiveInput values.
type AssetOrArchiveMap map[string]AssetOrArchiveInput

// ElementType returns the element type of this Input (map[string]AssetOrArchive).
func (AssetOrArchiveMap) ElementType() reflect.Type {
	return assetOrArchiveMapType
}

func (in AssetOrArchiveMap) ToOutput(ctx context.Context) pulumix.Output[map[string]AssetOrArchive] {
	return pulumix.Output[map[string]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveMap) ToAssetOrArchiveMapOutput() AssetOrArchiveMapOutput {
	return ToOutput(in).(AssetOrArchiveMapOutput)
}

func (in AssetOrArchiveMap) ToAssetOrArchiveMapOutputWithContext(ctx context.Context) AssetOrArchiveMapOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveMapOutput)
}

// AssetOrArchiveMapOutput is an Output that returns map[string]AssetOrArchive values.
type AssetOrArchiveMapOutput struct{ *OutputState }

func (AssetOrArchiveMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]AssetOrArchive] {
	return pulumix.Output[map[string]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]AssetOrArchive).
func (AssetOrArchiveMapOutput) ElementType() reflect.Type {
	return assetOrArchiveMapType
}

func (o AssetOrArchiveMapOutput) ToAssetOrArchiveMapOutput() AssetOrArchiveMapOutput {
	return o
}

func (o AssetOrArchiveMapOutput) ToAssetOrArchiveMapOutputWithContext(ctx context.Context) AssetOrArchiveMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetOrArchiveMapOutput) MapIndex(k StringInput) AssetOrArchiveOutput {
	return All(o, k).ApplyT(func(vs []any) AssetOrArchive {
		return vs[0].(map[string]AssetOrArchive)[vs[1].(string)]
	}).(AssetOrArchiveOutput)
}

var assetOrArchiveArrayMapType = reflect.TypeOf((*map[string][]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveArrayMapInput is an input type that accepts AssetOrArchiveArrayMap and AssetOrArchiveArrayMapOutput values.
type AssetOrArchiveArrayMapInput interface {
	Input

	ToAssetOrArchiveArrayMapOutput() AssetOrArchiveArrayMapOutput
	ToAssetOrArchiveArrayMapOutputWithContext(ctx context.Context) AssetOrArchiveArrayMapOutput
}

// AssetOrArchiveArrayMap is an input type for map[string]AssetOrArchiveArrayInput values.
type AssetOrArchiveArrayMap map[string]AssetOrArchiveArrayInput

// ElementType returns the element type of this Input (map[string][]AssetOrArchive).
func (AssetOrArchiveArrayMap) ElementType() reflect.Type {
	return assetOrArchiveArrayMapType
}

func (in AssetOrArchiveArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]AssetOrArchive] {
	return pulumix.Output[map[string][]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveArrayMap) ToAssetOrArchiveArrayMapOutput() AssetOrArchiveArrayMapOutput {
	return ToOutput(in).(AssetOrArchiveArrayMapOutput)
}

func (in AssetOrArchiveArrayMap) ToAssetOrArchiveArrayMapOutputWithContext(ctx context.Context) AssetOrArchiveArrayMapOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveArrayMapOutput)
}

// AssetOrArchiveArrayMapOutput is an Output that returns map[string][]AssetOrArchive values.
type AssetOrArchiveArrayMapOutput struct{ *OutputState }

func (AssetOrArchiveArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]AssetOrArchive] {
	return pulumix.Output[map[string][]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]AssetOrArchive).
func (AssetOrArchiveArrayMapOutput) ElementType() reflect.Type {
	return assetOrArchiveArrayMapType
}

func (o AssetOrArchiveArrayMapOutput) ToAssetOrArchiveArrayMapOutput() AssetOrArchiveArrayMapOutput {
	return o
}

func (o AssetOrArchiveArrayMapOutput) ToAssetOrArchiveArrayMapOutputWithContext(ctx context.Context) AssetOrArchiveArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetOrArchiveArrayMapOutput) MapIndex(k StringInput) AssetOrArchiveArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []AssetOrArchive {
		return vs[0].(map[string][]AssetOrArchive)[vs[1].(string)]
	}).(AssetOrArchiveArrayOutput)
}

var assetOrArchiveMapArrayType = reflect.TypeOf((*[]map[string]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveMapArrayInput is an input type that accepts AssetOrArchiveMapArray and AssetOrArchiveMapArrayOutput values.
type AssetOrArchiveMapArrayInput interface {
	Input

	ToAssetOrArchiveMapArrayOutput() AssetOrArchiveMapArrayOutput
	ToAssetOrArchiveMapArrayOutputWithContext(ctx context.Context) AssetOrArchiveMapArrayOutput
}

// AssetOrArchiveMapArray is an input type for []AssetOrArchiveMapInput values.
type AssetOrArchiveMapArray []AssetOrArchiveMapInput

// ElementType returns the element type of this Input ([]map[string]AssetOrArchive).
func (AssetOrArchiveMapArray) ElementType() reflect.Type {
	return assetOrArchiveMapArrayType
}

func (in AssetOrArchiveMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]AssetOrArchive] {
	return pulumix.Output[[]map[string]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveMapArray) ToAssetOrArchiveMapArrayOutput() AssetOrArchiveMapArrayOutput {
	return ToOutput(in).(AssetOrArchiveMapArrayOutput)
}

func (in AssetOrArchiveMapArray) ToAssetOrArchiveMapArrayOutputWithContext(ctx context.Context) AssetOrArchiveMapArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveMapArrayOutput)
}

// AssetOrArchiveMapArrayOutput is an Output that returns []map[string]AssetOrArchive values.
type AssetOrArchiveMapArrayOutput struct{ *OutputState }

func (AssetOrArchiveMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]AssetOrArchive] {
	return pulumix.Output[[]map[string]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]AssetOrArchive).
func (AssetOrArchiveMapArrayOutput) ElementType() reflect.Type {
	return assetOrArchiveMapArrayType
}

func (o AssetOrArchiveMapArrayOutput) ToAssetOrArchiveMapArrayOutput() AssetOrArchiveMapArrayOutput {
	return o
}

func (o AssetOrArchiveMapArrayOutput) ToAssetOrArchiveMapArrayOutputWithContext(ctx context.Context) AssetOrArchiveMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetOrArchiveMapArrayOutput) Index(i IntInput) AssetOrArchiveMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]AssetOrArchive {
		arr := vs[0].([]map[string]AssetOrArchive)
		idx := vs[1].(int)
		var ret map[string]AssetOrArchive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetOrArchiveMapOutput)
}

var assetOrArchiveMapMapType = reflect.TypeOf((*map[string]map[string]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveMapMapInput is an input type that accepts AssetOrArchiveMapMap and AssetOrArchiveMapMapOutput values.
type AssetOrArchiveMapMapInput interface {
	Input

	ToAssetOrArchiveMapMapOutput() AssetOrArchiveMapMapOutput
	ToAssetOrArchiveMapMapOutputWithContext(ctx context.Context) AssetOrArchiveMapMapOutput
}

// AssetOrArchiveMapMap is an input type for map[string]AssetOrArchiveMapInput values.
type AssetOrArchiveMapMap map[string]AssetOrArchiveMapInput

// ElementType returns the element type of this Input (map[string]map[string]AssetOrArchive).
func (AssetOrArchiveMapMap) ElementType() reflect.Type {
	return assetOrArchiveMapMapType
}

func (in AssetOrArchiveMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]AssetOrArchive] {
	return pulumix.Output[map[string]map[string]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveMapMap) ToAssetOrArchiveMapMapOutput() AssetOrArchiveMapMapOutput {
	return ToOutput(in).(AssetOrArchiveMapMapOutput)
}

func (in AssetOrArchiveMapMap) ToAssetOrArchiveMapMapOutputWithContext(ctx context.Context) AssetOrArchiveMapMapOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveMapMapOutput)
}

// AssetOrArchiveMapMapOutput is an Output that returns map[string]map[string]AssetOrArchive values.
type AssetOrArchiveMapMapOutput struct{ *OutputState }

func (AssetOrArchiveMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]AssetOrArchive] {
	return pulumix.Output[map[string]map[string]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]AssetOrArchive).
func (AssetOrArchiveMapMapOutput) ElementType() reflect.Type {
	return assetOrArchiveMapMapType
}

func (o AssetOrArchiveMapMapOutput) ToAssetOrArchiveMapMapOutput() AssetOrArchiveMapMapOutput {
	return o
}

func (o AssetOrArchiveMapMapOutput) ToAssetOrArchiveMapMapOutputWithContext(ctx context.Context) AssetOrArchiveMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetOrArchiveMapMapOutput) MapIndex(k StringInput) AssetOrArchiveMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]AssetOrArchive {
		return vs[0].(map[string]map[string]AssetOrArchive)[vs[1].(string)]
	}).(AssetOrArchiveMapOutput)
}

var assetOrArchiveArrayArrayType = reflect.TypeOf((*[][]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveArrayArrayInput is an input type that accepts AssetOrArchiveArrayArray and AssetOrArchiveArrayArrayOutput values.
type AssetOrArchiveArrayArrayInput interface {
	Input

	ToAssetOrArchiveArrayArrayOutput() AssetOrArchiveArrayArrayOutput
	ToAssetOrArchiveArrayArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayArrayOutput
}

// AssetOrArchiveArrayArray is an input type for []AssetOrArchiveArrayInput values.
type AssetOrArchiveArrayArray []AssetOrArchiveArrayInput

// ElementType returns the element type of this Input ([][]AssetOrArchive).
func (AssetOrArchiveArrayArray) ElementType() reflect.Type {
	return assetOrArchiveArrayArrayType
}

func (in AssetOrArchiveArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][]AssetOrArchive] {
	return pulumix.Output[[][]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveArrayArray) ToAssetOrArchiveArrayArrayOutput() AssetOrArchiveArrayArrayOutput {
	return ToOutput(in).(AssetOrArchiveArrayArrayOutput)
}

func (in AssetOrArchiveArrayArray) ToAssetOrArchiveArrayArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveArrayArrayOutput)
}

// AssetOrArchiveArrayArrayOutput is an Output that returns [][]AssetOrArchive values.
type AssetOrArchiveArrayArrayOutput struct{ *OutputState }

func (AssetOrArchiveArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][]AssetOrArchive] {
	return pulumix.Output[[][]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][]AssetOrArchive).
func (AssetOrArchiveArrayArrayOutput) ElementType() reflect.Type {
	return assetOrArchiveArrayArrayType
}

func (o AssetOrArchiveArrayArrayOutput) ToAssetOrArchiveArrayArrayOutput() AssetOrArchiveArrayArrayOutput {
	return o
}

func (o AssetOrArchiveArrayArrayOutput) ToAssetOrArchiveArrayArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetOrArchiveArrayArrayOutput) Index(i IntInput) AssetOrArchiveArrayOutput {
	return All(o, i).ApplyT(func(vs []any) []AssetOrArchive {
		arr := vs[0].([][]AssetOrArchive)
		idx := vs[1].(int)
		var ret []AssetOrArchive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetOrArchiveArrayOutput)
}

var assetOrArchiveArrayMapMapType = reflect.TypeOf((*map[string]map[string][]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveArrayMapMapInput is an input type that accepts AssetOrArchiveArrayMapMap and AssetOrArchiveArrayMapMapOutput values.
type AssetOrArchiveArrayMapMapInput interface {
	Input

	ToAssetOrArchiveArrayMapMapOutput() AssetOrArchiveArrayMapMapOutput
	ToAssetOrArchiveArrayMapMapOutputWithContext(ctx context.Context) AssetOrArchiveArrayMapMapOutput
}

// AssetOrArchiveArrayMapMap is an input type for map[string]AssetOrArchiveArrayMapInput values.
type AssetOrArchiveArrayMapMap map[string]AssetOrArchiveArrayMapInput

// ElementType returns the element type of this Input (map[string]map[string][]AssetOrArchive).
func (AssetOrArchiveArrayMapMap) ElementType() reflect.Type {
	return assetOrArchiveArrayMapMapType
}

func (in AssetOrArchiveArrayMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]AssetOrArchive] {
	return pulumix.Output[map[string]map[string][]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveArrayMapMap) ToAssetOrArchiveArrayMapMapOutput() AssetOrArchiveArrayMapMapOutput {
	return ToOutput(in).(AssetOrArchiveArrayMapMapOutput)
}

func (in AssetOrArchiveArrayMapMap) ToAssetOrArchiveArrayMapMapOutputWithContext(ctx context.Context) AssetOrArchiveArrayMapMapOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveArrayMapMapOutput)
}

// AssetOrArchiveArrayMapMapOutput is an Output that returns map[string]map[string][]AssetOrArchive values.
type AssetOrArchiveArrayMapMapOutput struct{ *OutputState }

func (AssetOrArchiveArrayMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveArrayMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]AssetOrArchive] {
	return pulumix.Output[map[string]map[string][]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string][]AssetOrArchive).
func (AssetOrArchiveArrayMapMapOutput) ElementType() reflect.Type {
	return assetOrArchiveArrayMapMapType
}

func (o AssetOrArchiveArrayMapMapOutput) ToAssetOrArchiveArrayMapMapOutput() AssetOrArchiveArrayMapMapOutput {
	return o
}

func (o AssetOrArchiveArrayMapMapOutput) ToAssetOrArchiveArrayMapMapOutputWithContext(ctx context.Context) AssetOrArchiveArrayMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetOrArchiveArrayMapMapOutput) MapIndex(k StringInput) AssetOrArchiveArrayMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string][]AssetOrArchive {
		return vs[0].(map[string]map[string][]AssetOrArchive)[vs[1].(string)]
	}).(AssetOrArchiveArrayMapOutput)
}

var assetOrArchiveMapArrayMapType = reflect.TypeOf((*map[string][]map[string]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveMapArrayMapInput is an input type that accepts AssetOrArchiveMapArrayMap and AssetOrArchiveMapArrayMapOutput values.
type AssetOrArchiveMapArrayMapInput interface {
	Input

	ToAssetOrArchiveMapArrayMapOutput() AssetOrArchiveMapArrayMapOutput
	ToAssetOrArchiveMapArrayMapOutputWithContext(ctx context.Context) AssetOrArchiveMapArrayMapOutput
}

// AssetOrArchiveMapArrayMap is an input type for map[string]AssetOrArchiveMapArrayInput values.
type AssetOrArchiveMapArrayMap map[string]AssetOrArchiveMapArrayInput

// ElementType returns the element type of this Input (map[string][]map[string]AssetOrArchive).
func (AssetOrArchiveMapArrayMap) ElementType() reflect.Type {
	return assetOrArchiveMapArrayMapType
}

func (in AssetOrArchiveMapArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]AssetOrArchive] {
	return pulumix.Output[map[string][]map[string]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveMapArrayMap) ToAssetOrArchiveMapArrayMapOutput() AssetOrArchiveMapArrayMapOutput {
	return ToOutput(in).(AssetOrArchiveMapArrayMapOutput)
}

func (in AssetOrArchiveMapArrayMap) ToAssetOrArchiveMapArrayMapOutputWithContext(ctx context.Context) AssetOrArchiveMapArrayMapOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveMapArrayMapOutput)
}

// AssetOrArchiveMapArrayMapOutput is an Output that returns map[string][]map[string]AssetOrArchive values.
type AssetOrArchiveMapArrayMapOutput struct{ *OutputState }

func (AssetOrArchiveMapArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveMapArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]AssetOrArchive] {
	return pulumix.Output[map[string][]map[string]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]map[string]AssetOrArchive).
func (AssetOrArchiveMapArrayMapOutput) ElementType() reflect.Type {
	return assetOrArchiveMapArrayMapType
}

func (o AssetOrArchiveMapArrayMapOutput) ToAssetOrArchiveMapArrayMapOutput() AssetOrArchiveMapArrayMapOutput {
	return o
}

func (o AssetOrArchiveMapArrayMapOutput) ToAssetOrArchiveMapArrayMapOutputWithContext(ctx context.Context) AssetOrArchiveMapArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetOrArchiveMapArrayMapOutput) MapIndex(k StringInput) AssetOrArchiveMapArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []map[string]AssetOrArchive {
		return vs[0].(map[string][]map[string]AssetOrArchive)[vs[1].(string)]
	}).(AssetOrArchiveMapArrayOutput)
}

var assetOrArchiveMapMapArrayType = reflect.TypeOf((*[]map[string]map[string]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveMapMapArrayInput is an input type that accepts AssetOrArchiveMapMapArray and AssetOrArchiveMapMapArrayOutput values.
type AssetOrArchiveMapMapArrayInput interface {
	Input

	ToAssetOrArchiveMapMapArrayOutput() AssetOrArchiveMapMapArrayOutput
	ToAssetOrArchiveMapMapArrayOutputWithContext(ctx context.Context) AssetOrArchiveMapMapArrayOutput
}

// AssetOrArchiveMapMapArray is an input type for []AssetOrArchiveMapMapInput values.
type AssetOrArchiveMapMapArray []AssetOrArchiveMapMapInput

// ElementType returns the element type of this Input ([]map[string]map[string]AssetOrArchive).
func (AssetOrArchiveMapMapArray) ElementType() reflect.Type {
	return assetOrArchiveMapMapArrayType
}

func (in AssetOrArchiveMapMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]AssetOrArchive] {
	return pulumix.Output[[]map[string]map[string]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveMapMapArray) ToAssetOrArchiveMapMapArrayOutput() AssetOrArchiveMapMapArrayOutput {
	return ToOutput(in).(AssetOrArchiveMapMapArrayOutput)
}

func (in AssetOrArchiveMapMapArray) ToAssetOrArchiveMapMapArrayOutputWithContext(ctx context.Context) AssetOrArchiveMapMapArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveMapMapArrayOutput)
}

// AssetOrArchiveMapMapArrayOutput is an Output that returns []map[string]map[string]AssetOrArchive values.
type AssetOrArchiveMapMapArrayOutput struct{ *OutputState }

func (AssetOrArchiveMapMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveMapMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]AssetOrArchive] {
	return pulumix.Output[[]map[string]map[string]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]map[string]AssetOrArchive).
func (AssetOrArchiveMapMapArrayOutput) ElementType() reflect.Type {
	return assetOrArchiveMapMapArrayType
}

func (o AssetOrArchiveMapMapArrayOutput) ToAssetOrArchiveMapMapArrayOutput() AssetOrArchiveMapMapArrayOutput {
	return o
}

func (o AssetOrArchiveMapMapArrayOutput) ToAssetOrArchiveMapMapArrayOutputWithContext(ctx context.Context) AssetOrArchiveMapMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetOrArchiveMapMapArrayOutput) Index(i IntInput) AssetOrArchiveMapMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]map[string]AssetOrArchive {
		arr := vs[0].([]map[string]map[string]AssetOrArchive)
		idx := vs[1].(int)
		var ret map[string]map[string]AssetOrArchive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetOrArchiveMapMapOutput)
}

var assetOrArchiveArrayMapArrayType = reflect.TypeOf((*[]map[string][]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveArrayMapArrayInput is an input type that accepts AssetOrArchiveArrayMapArray and AssetOrArchiveArrayMapArrayOutput values.
type AssetOrArchiveArrayMapArrayInput interface {
	Input

	ToAssetOrArchiveArrayMapArrayOutput() AssetOrArchiveArrayMapArrayOutput
	ToAssetOrArchiveArrayMapArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayMapArrayOutput
}

// AssetOrArchiveArrayMapArray is an input type for []AssetOrArchiveArrayMapInput values.
type AssetOrArchiveArrayMapArray []AssetOrArchiveArrayMapInput

// ElementType returns the element type of this Input ([]map[string][]AssetOrArchive).
func (AssetOrArchiveArrayMapArray) ElementType() reflect.Type {
	return assetOrArchiveArrayMapArrayType
}

func (in AssetOrArchiveArrayMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]AssetOrArchive] {
	return pulumix.Output[[]map[string][]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveArrayMapArray) ToAssetOrArchiveArrayMapArrayOutput() AssetOrArchiveArrayMapArrayOutput {
	return ToOutput(in).(AssetOrArchiveArrayMapArrayOutput)
}

func (in AssetOrArchiveArrayMapArray) ToAssetOrArchiveArrayMapArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayMapArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveArrayMapArrayOutput)
}

// AssetOrArchiveArrayMapArrayOutput is an Output that returns []map[string][]AssetOrArchive values.
type AssetOrArchiveArrayMapArrayOutput struct{ *OutputState }

func (AssetOrArchiveArrayMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveArrayMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]AssetOrArchive] {
	return pulumix.Output[[]map[string][]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string][]AssetOrArchive).
func (AssetOrArchiveArrayMapArrayOutput) ElementType() reflect.Type {
	return assetOrArchiveArrayMapArrayType
}

func (o AssetOrArchiveArrayMapArrayOutput) ToAssetOrArchiveArrayMapArrayOutput() AssetOrArchiveArrayMapArrayOutput {
	return o
}

func (o AssetOrArchiveArrayMapArrayOutput) ToAssetOrArchiveArrayMapArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetOrArchiveArrayMapArrayOutput) Index(i IntInput) AssetOrArchiveArrayMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string][]AssetOrArchive {
		arr := vs[0].([]map[string][]AssetOrArchive)
		idx := vs[1].(int)
		var ret map[string][]AssetOrArchive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetOrArchiveArrayMapOutput)
}

var assetOrArchiveArrayArrayMapType = reflect.TypeOf((*map[string][][]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveArrayArrayMapInput is an input type that accepts AssetOrArchiveArrayArrayMap and AssetOrArchiveArrayArrayMapOutput values.
type AssetOrArchiveArrayArrayMapInput interface {
	Input

	ToAssetOrArchiveArrayArrayMapOutput() AssetOrArchiveArrayArrayMapOutput
	ToAssetOrArchiveArrayArrayMapOutputWithContext(ctx context.Context) AssetOrArchiveArrayArrayMapOutput
}

// AssetOrArchiveArrayArrayMap is an input type for map[string]AssetOrArchiveArrayArrayInput values.
type AssetOrArchiveArrayArrayMap map[string]AssetOrArchiveArrayArrayInput

// ElementType returns the element type of this Input (map[string][][]AssetOrArchive).
func (AssetOrArchiveArrayArrayMap) ElementType() reflect.Type {
	return assetOrArchiveArrayArrayMapType
}

func (in AssetOrArchiveArrayArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][][]AssetOrArchive] {
	return pulumix.Output[map[string][][]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveArrayArrayMap) ToAssetOrArchiveArrayArrayMapOutput() AssetOrArchiveArrayArrayMapOutput {
	return ToOutput(in).(AssetOrArchiveArrayArrayMapOutput)
}

func (in AssetOrArchiveArrayArrayMap) ToAssetOrArchiveArrayArrayMapOutputWithContext(ctx context.Context) AssetOrArchiveArrayArrayMapOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveArrayArrayMapOutput)
}

// AssetOrArchiveArrayArrayMapOutput is an Output that returns map[string][][]AssetOrArchive values.
type AssetOrArchiveArrayArrayMapOutput struct{ *OutputState }

func (AssetOrArchiveArrayArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveArrayArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][][]AssetOrArchive] {
	return pulumix.Output[map[string][][]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][][]AssetOrArchive).
func (AssetOrArchiveArrayArrayMapOutput) ElementType() reflect.Type {
	return assetOrArchiveArrayArrayMapType
}

func (o AssetOrArchiveArrayArrayMapOutput) ToAssetOrArchiveArrayArrayMapOutput() AssetOrArchiveArrayArrayMapOutput {
	return o
}

func (o AssetOrArchiveArrayArrayMapOutput) ToAssetOrArchiveArrayArrayMapOutputWithContext(ctx context.Context) AssetOrArchiveArrayArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetOrArchiveArrayArrayMapOutput) MapIndex(k StringInput) AssetOrArchiveArrayArrayOutput {
	return All(o, k).ApplyT(func(vs []any) [][]AssetOrArchive {
		return vs[0].(map[string][][]AssetOrArchive)[vs[1].(string)]
	}).(AssetOrArchiveArrayArrayOutput)
}

var assetOrArchiveArrayArrayArrayType = reflect.TypeOf((*[][][]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveArrayArrayArrayInput is an input type that accepts AssetOrArchiveArrayArrayArray and AssetOrArchiveArrayArrayArrayOutput values.
type AssetOrArchiveArrayArrayArrayInput interface {
	Input

	ToAssetOrArchiveArrayArrayArrayOutput() AssetOrArchiveArrayArrayArrayOutput
	ToAssetOrArchiveArrayArrayArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayArrayArrayOutput
}

// AssetOrArchiveArrayArrayArray is an input type for []AssetOrArchiveArrayArrayInput values.
type AssetOrArchiveArrayArrayArray []AssetOrArchiveArrayArrayInput

// ElementType returns the element type of this Input ([][][]AssetOrArchive).
func (AssetOrArchiveArrayArrayArray) ElementType() reflect.Type {
	return assetOrArchiveArrayArrayArrayType
}

func (in AssetOrArchiveArrayArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][][]AssetOrArchive] {
	return pulumix.Output[[][][]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveArrayArrayArray) ToAssetOrArchiveArrayArrayArrayOutput() AssetOrArchiveArrayArrayArrayOutput {
	return ToOutput(in).(AssetOrArchiveArrayArrayArrayOutput)
}

func (in AssetOrArchiveArrayArrayArray) ToAssetOrArchiveArrayArrayArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveArrayArrayArrayOutput)
}

// AssetOrArchiveArrayArrayArrayOutput is an Output that returns [][][]AssetOrArchive values.
type AssetOrArchiveArrayArrayArrayOutput struct{ *OutputState }

func (AssetOrArchiveArrayArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveArrayArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][][]AssetOrArchive] {
	return pulumix.Output[[][][]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][][]AssetOrArchive).
func (AssetOrArchiveArrayArrayArrayOutput) ElementType() reflect.Type {
	return assetOrArchiveArrayArrayArrayType
}

func (o AssetOrArchiveArrayArrayArrayOutput) ToAssetOrArchiveArrayArrayArrayOutput() AssetOrArchiveArrayArrayArrayOutput {
	return o
}

func (o AssetOrArchiveArrayArrayArrayOutput) ToAssetOrArchiveArrayArrayArrayOutputWithContext(ctx context.Context) AssetOrArchiveArrayArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o AssetOrArchiveArrayArrayArrayOutput) Index(i IntInput) AssetOrArchiveArrayArrayOutput {
	return All(o, i).ApplyT(func(vs []any) [][]AssetOrArchive {
		arr := vs[0].([][][]AssetOrArchive)
		idx := vs[1].(int)
		var ret [][]AssetOrArchive
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(AssetOrArchiveArrayArrayOutput)
}

var assetOrArchiveMapMapMapType = reflect.TypeOf((*map[string]map[string]map[string]AssetOrArchive)(nil)).Elem()

// AssetOrArchiveMapMapMapInput is an input type that accepts AssetOrArchiveMapMapMap and AssetOrArchiveMapMapMapOutput values.
type AssetOrArchiveMapMapMapInput interface {
	Input

	ToAssetOrArchiveMapMapMapOutput() AssetOrArchiveMapMapMapOutput
	ToAssetOrArchiveMapMapMapOutputWithContext(ctx context.Context) AssetOrArchiveMapMapMapOutput
}

// AssetOrArchiveMapMapMap is an input type for map[string]AssetOrArchiveMapMapInput values.
type AssetOrArchiveMapMapMap map[string]AssetOrArchiveMapMapInput

// ElementType returns the element type of this Input (map[string]map[string]map[string]AssetOrArchive).
func (AssetOrArchiveMapMapMap) ElementType() reflect.Type {
	return assetOrArchiveMapMapMapType
}

func (in AssetOrArchiveMapMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]AssetOrArchive] {
	return pulumix.Output[map[string]map[string]map[string]AssetOrArchive]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in AssetOrArchiveMapMapMap) ToAssetOrArchiveMapMapMapOutput() AssetOrArchiveMapMapMapOutput {
	return ToOutput(in).(AssetOrArchiveMapMapMapOutput)
}

func (in AssetOrArchiveMapMapMap) ToAssetOrArchiveMapMapMapOutputWithContext(ctx context.Context) AssetOrArchiveMapMapMapOutput {
	return ToOutputWithContext(ctx, in).(AssetOrArchiveMapMapMapOutput)
}

// AssetOrArchiveMapMapMapOutput is an Output that returns map[string]map[string]map[string]AssetOrArchive values.
type AssetOrArchiveMapMapMapOutput struct{ *OutputState }

func (AssetOrArchiveMapMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o AssetOrArchiveMapMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]AssetOrArchive] {
	return pulumix.Output[map[string]map[string]map[string]AssetOrArchive]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]map[string]AssetOrArchive).
func (AssetOrArchiveMapMapMapOutput) ElementType() reflect.Type {
	return assetOrArchiveMapMapMapType
}

func (o AssetOrArchiveMapMapMapOutput) ToAssetOrArchiveMapMapMapOutput() AssetOrArchiveMapMapMapOutput {
	return o
}

func (o AssetOrArchiveMapMapMapOutput) ToAssetOrArchiveMapMapMapOutputWithContext(ctx context.Context) AssetOrArchiveMapMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o AssetOrArchiveMapMapMapOutput) MapIndex(k StringInput) AssetOrArchiveMapMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]map[string]AssetOrArchive {
		return vs[0].(map[string]map[string]map[string]AssetOrArchive)[vs[1].(string)]
	}).(AssetOrArchiveMapMapOutput)
}

var boolType = reflect.TypeOf((*bool)(nil)).Elem()

// BoolInput is an input type that accepts Bool and BoolOutput values.
type BoolInput interface {
	Input

	ToBoolOutput() BoolOutput
	ToBoolOutputWithContext(ctx context.Context) BoolOutput

	ToBoolPtrOutput() BoolPtrOutput
	ToBoolPtrOutputWithContext(ctx context.Context) BoolPtrOutput
}

// Bool is an input type for bool values.
type Bool bool

// ElementType returns the element type of this Input (bool).
func (Bool) ElementType() reflect.Type {
	return boolType
}

func (in Bool) ToOutput(ctx context.Context) pulumix.Output[bool] {
	return pulumix.Output[bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Bool) ToBoolOutput() BoolOutput {
	return ToOutput(in).(BoolOutput)
}

func (in Bool) ToBoolOutputWithContext(ctx context.Context) BoolOutput {
	return ToOutputWithContext(ctx, in).(BoolOutput)
}

func (in Bool) ToBoolPtrOutput() BoolPtrOutput {
	return in.ToBoolPtrOutputWithContext(context.Background())
}

func (in Bool) ToBoolPtrOutputWithContext(ctx context.Context) BoolPtrOutput {
	return in.ToBoolOutputWithContext(ctx).ToBoolPtrOutputWithContext(ctx)
}

// BoolOutput is an Output that returns bool values.
type BoolOutput struct{ *OutputState }

func (BoolOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolOutput) ToOutput(ctx context.Context) pulumix.Output[bool] {
	return pulumix.Output[bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (bool).
func (BoolOutput) ElementType() reflect.Type {
	return boolType
}

func (o BoolOutput) ToBoolOutput() BoolOutput {
	return o
}

func (o BoolOutput) ToBoolOutputWithContext(ctx context.Context) BoolOutput {
	return o
}

func (o BoolOutput) ToBoolPtrOutput() BoolPtrOutput {
	return o.ToBoolPtrOutputWithContext(context.Background())
}

func (o BoolOutput) ToBoolPtrOutputWithContext(ctx context.Context) BoolPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v bool) *bool {
		return &v
	}).(BoolPtrOutput)
}

var boolPtrType = reflect.TypeOf((**bool)(nil)).Elem()

// BoolPtrInput is an input type that accepts BoolPtr and BoolPtrOutput values.
type BoolPtrInput interface {
	Input

	ToBoolPtrOutput() BoolPtrOutput
	ToBoolPtrOutputWithContext(ctx context.Context) BoolPtrOutput
}

type boolPtr bool

// BoolPtr is an input type for *bool values.
func BoolPtr(v bool) BoolPtrInput {
	return (*boolPtr)(&v)
}

func BoolPtrFromPtr(v *bool) BoolPtrInput {
	if v == nil {
		return nil
	}
	return (*boolPtr)(v)
}

// ElementType returns the element type of this Input (*bool).
func (*boolPtr) ElementType() reflect.Type {
	return boolPtrType
}

func (in *boolPtr) ToOutput(ctx context.Context) pulumix.Output[*bool] {
	return pulumix.Output[*bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in *boolPtr) ToBoolPtrOutput() BoolPtrOutput {
	return ToOutput(in).(BoolPtrOutput)
}

func (in *boolPtr) ToBoolPtrOutputWithContext(ctx context.Context) BoolPtrOutput {
	return ToOutputWithContext(ctx, in).(BoolPtrOutput)
}

// BoolPtrOutput is an Output that returns *bool values.
type BoolPtrOutput struct{ *OutputState }

func (BoolPtrOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*bool] {
	return pulumix.Output[*bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (*bool).
func (BoolPtrOutput) ElementType() reflect.Type {
	return boolPtrType
}

func (o BoolPtrOutput) ToBoolPtrOutput() BoolPtrOutput {
	return o
}

func (o BoolPtrOutput) ToBoolPtrOutputWithContext(ctx context.Context) BoolPtrOutput {
	return o
}

// Elem dereferences the pointer value or returns the zero value of the approporiate type if the pointer is nil.
func (o BoolPtrOutput) Elem() BoolOutput {
	return o.ApplyT(func(v *bool) bool {
		var ret bool
		if v != nil {
			ret = *v
		}
		return ret
	}).(BoolOutput)
}

var boolArrayType = reflect.TypeOf((*[]bool)(nil)).Elem()

// BoolArrayInput is an input type that accepts BoolArray and BoolArrayOutput values.
type BoolArrayInput interface {
	Input

	ToBoolArrayOutput() BoolArrayOutput
	ToBoolArrayOutputWithContext(ctx context.Context) BoolArrayOutput
}

// BoolArray is an input type for []BoolInput values.
type BoolArray []BoolInput

// ElementType returns the element type of this Input ([]bool).
func (BoolArray) ElementType() reflect.Type {
	return boolArrayType
}

func (in BoolArray) ToOutput(ctx context.Context) pulumix.Output[[]bool] {
	return pulumix.Output[[]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolArray) ToBoolArrayOutput() BoolArrayOutput {
	return ToOutput(in).(BoolArrayOutput)
}

func (in BoolArray) ToBoolArrayOutputWithContext(ctx context.Context) BoolArrayOutput {
	return ToOutputWithContext(ctx, in).(BoolArrayOutput)
}

// BoolArrayOutput is an Output that returns []bool values.
type BoolArrayOutput struct{ *OutputState }

func (BoolArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]bool] {
	return pulumix.Output[[]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]bool).
func (BoolArrayOutput) ElementType() reflect.Type {
	return boolArrayType
}

func (o BoolArrayOutput) ToBoolArrayOutput() BoolArrayOutput {
	return o
}

func (o BoolArrayOutput) ToBoolArrayOutputWithContext(ctx context.Context) BoolArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o BoolArrayOutput) Index(i IntInput) BoolOutput {
	return All(o, i).ApplyT(func(vs []any) bool {
		arr := vs[0].([]bool)
		idx := vs[1].(int)
		var ret bool
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(BoolOutput)
}

func ToBoolArray(in []bool) BoolArray {
	a := make(BoolArray, len(in))
	for i, v := range in {
		a[i] = Bool(v)
	}
	return a
}

func ToBoolArrayOutput(in []BoolOutput) BoolArrayOutput {
	a := make(BoolArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToBoolArrayOutput()
}

var boolMapType = reflect.TypeOf((*map[string]bool)(nil)).Elem()

// BoolMapInput is an input type that accepts BoolMap and BoolMapOutput values.
type BoolMapInput interface {
	Input

	ToBoolMapOutput() BoolMapOutput
	ToBoolMapOutputWithContext(ctx context.Context) BoolMapOutput
}

// BoolMap is an input type for map[string]BoolInput values.
type BoolMap map[string]BoolInput

// ElementType returns the element type of this Input (map[string]bool).
func (BoolMap) ElementType() reflect.Type {
	return boolMapType
}

func (in BoolMap) ToOutput(ctx context.Context) pulumix.Output[map[string]bool] {
	return pulumix.Output[map[string]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolMap) ToBoolMapOutput() BoolMapOutput {
	return ToOutput(in).(BoolMapOutput)
}

func (in BoolMap) ToBoolMapOutputWithContext(ctx context.Context) BoolMapOutput {
	return ToOutputWithContext(ctx, in).(BoolMapOutput)
}

// BoolMapOutput is an Output that returns map[string]bool values.
type BoolMapOutput struct{ *OutputState }

func (BoolMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]bool] {
	return pulumix.Output[map[string]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]bool).
func (BoolMapOutput) ElementType() reflect.Type {
	return boolMapType
}

func (o BoolMapOutput) ToBoolMapOutput() BoolMapOutput {
	return o
}

func (o BoolMapOutput) ToBoolMapOutputWithContext(ctx context.Context) BoolMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o BoolMapOutput) MapIndex(k StringInput) BoolOutput {
	return All(o, k).ApplyT(func(vs []any) bool {
		return vs[0].(map[string]bool)[vs[1].(string)]
	}).(BoolOutput)
}

func ToBoolMap(in map[string]bool) BoolMap {
	m := make(BoolMap)
	for k, v := range in {
		m[k] = Bool(v)
	}
	return m
}

func ToBoolMapOutput(in map[string]BoolOutput) BoolMapOutput {
	m := make(BoolMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToBoolMapOutput()
}

var boolArrayMapType = reflect.TypeOf((*map[string][]bool)(nil)).Elem()

// BoolArrayMapInput is an input type that accepts BoolArrayMap and BoolArrayMapOutput values.
type BoolArrayMapInput interface {
	Input

	ToBoolArrayMapOutput() BoolArrayMapOutput
	ToBoolArrayMapOutputWithContext(ctx context.Context) BoolArrayMapOutput
}

// BoolArrayMap is an input type for map[string]BoolArrayInput values.
type BoolArrayMap map[string]BoolArrayInput

// ElementType returns the element type of this Input (map[string][]bool).
func (BoolArrayMap) ElementType() reflect.Type {
	return boolArrayMapType
}

func (in BoolArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]bool] {
	return pulumix.Output[map[string][]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolArrayMap) ToBoolArrayMapOutput() BoolArrayMapOutput {
	return ToOutput(in).(BoolArrayMapOutput)
}

func (in BoolArrayMap) ToBoolArrayMapOutputWithContext(ctx context.Context) BoolArrayMapOutput {
	return ToOutputWithContext(ctx, in).(BoolArrayMapOutput)
}

// BoolArrayMapOutput is an Output that returns map[string][]bool values.
type BoolArrayMapOutput struct{ *OutputState }

func (BoolArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]bool] {
	return pulumix.Output[map[string][]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]bool).
func (BoolArrayMapOutput) ElementType() reflect.Type {
	return boolArrayMapType
}

func (o BoolArrayMapOutput) ToBoolArrayMapOutput() BoolArrayMapOutput {
	return o
}

func (o BoolArrayMapOutput) ToBoolArrayMapOutputWithContext(ctx context.Context) BoolArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o BoolArrayMapOutput) MapIndex(k StringInput) BoolArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []bool {
		return vs[0].(map[string][]bool)[vs[1].(string)]
	}).(BoolArrayOutput)
}

func ToBoolArrayMap(in map[string][]bool) BoolArrayMap {
	m := make(BoolArrayMap)
	for k, v := range in {
		m[k] = ToBoolArray(v)
	}
	return m
}

func ToBoolArrayMapOutput(in map[string]BoolArrayOutput) BoolArrayMapOutput {
	m := make(BoolArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToBoolArrayMapOutput()
}

var boolMapArrayType = reflect.TypeOf((*[]map[string]bool)(nil)).Elem()

// BoolMapArrayInput is an input type that accepts BoolMapArray and BoolMapArrayOutput values.
type BoolMapArrayInput interface {
	Input

	ToBoolMapArrayOutput() BoolMapArrayOutput
	ToBoolMapArrayOutputWithContext(ctx context.Context) BoolMapArrayOutput
}

// BoolMapArray is an input type for []BoolMapInput values.
type BoolMapArray []BoolMapInput

// ElementType returns the element type of this Input ([]map[string]bool).
func (BoolMapArray) ElementType() reflect.Type {
	return boolMapArrayType
}

func (in BoolMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]bool] {
	return pulumix.Output[[]map[string]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolMapArray) ToBoolMapArrayOutput() BoolMapArrayOutput {
	return ToOutput(in).(BoolMapArrayOutput)
}

func (in BoolMapArray) ToBoolMapArrayOutputWithContext(ctx context.Context) BoolMapArrayOutput {
	return ToOutputWithContext(ctx, in).(BoolMapArrayOutput)
}

// BoolMapArrayOutput is an Output that returns []map[string]bool values.
type BoolMapArrayOutput struct{ *OutputState }

func (BoolMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]bool] {
	return pulumix.Output[[]map[string]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]bool).
func (BoolMapArrayOutput) ElementType() reflect.Type {
	return boolMapArrayType
}

func (o BoolMapArrayOutput) ToBoolMapArrayOutput() BoolMapArrayOutput {
	return o
}

func (o BoolMapArrayOutput) ToBoolMapArrayOutputWithContext(ctx context.Context) BoolMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o BoolMapArrayOutput) Index(i IntInput) BoolMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]bool {
		arr := vs[0].([]map[string]bool)
		idx := vs[1].(int)
		var ret map[string]bool
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(BoolMapOutput)
}

func ToBoolMapArray(in []map[string]bool) BoolMapArray {
	a := make(BoolMapArray, len(in))
	for i, v := range in {
		a[i] = ToBoolMap(v)
	}
	return a
}

func ToBoolMapArrayOutput(in []BoolMapOutput) BoolMapArrayOutput {
	a := make(BoolMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToBoolMapArrayOutput()
}

var boolMapMapType = reflect.TypeOf((*map[string]map[string]bool)(nil)).Elem()

// BoolMapMapInput is an input type that accepts BoolMapMap and BoolMapMapOutput values.
type BoolMapMapInput interface {
	Input

	ToBoolMapMapOutput() BoolMapMapOutput
	ToBoolMapMapOutputWithContext(ctx context.Context) BoolMapMapOutput
}

// BoolMapMap is an input type for map[string]BoolMapInput values.
type BoolMapMap map[string]BoolMapInput

// ElementType returns the element type of this Input (map[string]map[string]bool).
func (BoolMapMap) ElementType() reflect.Type {
	return boolMapMapType
}

func (in BoolMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]bool] {
	return pulumix.Output[map[string]map[string]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolMapMap) ToBoolMapMapOutput() BoolMapMapOutput {
	return ToOutput(in).(BoolMapMapOutput)
}

func (in BoolMapMap) ToBoolMapMapOutputWithContext(ctx context.Context) BoolMapMapOutput {
	return ToOutputWithContext(ctx, in).(BoolMapMapOutput)
}

// BoolMapMapOutput is an Output that returns map[string]map[string]bool values.
type BoolMapMapOutput struct{ *OutputState }

func (BoolMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]bool] {
	return pulumix.Output[map[string]map[string]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]bool).
func (BoolMapMapOutput) ElementType() reflect.Type {
	return boolMapMapType
}

func (o BoolMapMapOutput) ToBoolMapMapOutput() BoolMapMapOutput {
	return o
}

func (o BoolMapMapOutput) ToBoolMapMapOutputWithContext(ctx context.Context) BoolMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o BoolMapMapOutput) MapIndex(k StringInput) BoolMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]bool {
		return vs[0].(map[string]map[string]bool)[vs[1].(string)]
	}).(BoolMapOutput)
}

func ToBoolMapMap(in map[string]map[string]bool) BoolMapMap {
	m := make(BoolMapMap)
	for k, v := range in {
		m[k] = ToBoolMap(v)
	}
	return m
}

func ToBoolMapMapOutput(in map[string]BoolMapOutput) BoolMapMapOutput {
	m := make(BoolMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToBoolMapMapOutput()
}

var boolArrayArrayType = reflect.TypeOf((*[][]bool)(nil)).Elem()

// BoolArrayArrayInput is an input type that accepts BoolArrayArray and BoolArrayArrayOutput values.
type BoolArrayArrayInput interface {
	Input

	ToBoolArrayArrayOutput() BoolArrayArrayOutput
	ToBoolArrayArrayOutputWithContext(ctx context.Context) BoolArrayArrayOutput
}

// BoolArrayArray is an input type for []BoolArrayInput values.
type BoolArrayArray []BoolArrayInput

// ElementType returns the element type of this Input ([][]bool).
func (BoolArrayArray) ElementType() reflect.Type {
	return boolArrayArrayType
}

func (in BoolArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][]bool] {
	return pulumix.Output[[][]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolArrayArray) ToBoolArrayArrayOutput() BoolArrayArrayOutput {
	return ToOutput(in).(BoolArrayArrayOutput)
}

func (in BoolArrayArray) ToBoolArrayArrayOutputWithContext(ctx context.Context) BoolArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(BoolArrayArrayOutput)
}

// BoolArrayArrayOutput is an Output that returns [][]bool values.
type BoolArrayArrayOutput struct{ *OutputState }

func (BoolArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][]bool] {
	return pulumix.Output[[][]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][]bool).
func (BoolArrayArrayOutput) ElementType() reflect.Type {
	return boolArrayArrayType
}

func (o BoolArrayArrayOutput) ToBoolArrayArrayOutput() BoolArrayArrayOutput {
	return o
}

func (o BoolArrayArrayOutput) ToBoolArrayArrayOutputWithContext(ctx context.Context) BoolArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o BoolArrayArrayOutput) Index(i IntInput) BoolArrayOutput {
	return All(o, i).ApplyT(func(vs []any) []bool {
		arr := vs[0].([][]bool)
		idx := vs[1].(int)
		var ret []bool
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(BoolArrayOutput)
}

func ToBoolArrayArray(in [][]bool) BoolArrayArray {
	a := make(BoolArrayArray, len(in))
	for i, v := range in {
		a[i] = ToBoolArray(v)
	}
	return a
}

func ToBoolArrayArrayOutput(in []BoolArrayOutput) BoolArrayArrayOutput {
	a := make(BoolArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToBoolArrayArrayOutput()
}

var boolArrayMapMapType = reflect.TypeOf((*map[string]map[string][]bool)(nil)).Elem()

// BoolArrayMapMapInput is an input type that accepts BoolArrayMapMap and BoolArrayMapMapOutput values.
type BoolArrayMapMapInput interface {
	Input

	ToBoolArrayMapMapOutput() BoolArrayMapMapOutput
	ToBoolArrayMapMapOutputWithContext(ctx context.Context) BoolArrayMapMapOutput
}

// BoolArrayMapMap is an input type for map[string]BoolArrayMapInput values.
type BoolArrayMapMap map[string]BoolArrayMapInput

// ElementType returns the element type of this Input (map[string]map[string][]bool).
func (BoolArrayMapMap) ElementType() reflect.Type {
	return boolArrayMapMapType
}

func (in BoolArrayMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]bool] {
	return pulumix.Output[map[string]map[string][]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolArrayMapMap) ToBoolArrayMapMapOutput() BoolArrayMapMapOutput {
	return ToOutput(in).(BoolArrayMapMapOutput)
}

func (in BoolArrayMapMap) ToBoolArrayMapMapOutputWithContext(ctx context.Context) BoolArrayMapMapOutput {
	return ToOutputWithContext(ctx, in).(BoolArrayMapMapOutput)
}

// BoolArrayMapMapOutput is an Output that returns map[string]map[string][]bool values.
type BoolArrayMapMapOutput struct{ *OutputState }

func (BoolArrayMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolArrayMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]bool] {
	return pulumix.Output[map[string]map[string][]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string][]bool).
func (BoolArrayMapMapOutput) ElementType() reflect.Type {
	return boolArrayMapMapType
}

func (o BoolArrayMapMapOutput) ToBoolArrayMapMapOutput() BoolArrayMapMapOutput {
	return o
}

func (o BoolArrayMapMapOutput) ToBoolArrayMapMapOutputWithContext(ctx context.Context) BoolArrayMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o BoolArrayMapMapOutput) MapIndex(k StringInput) BoolArrayMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string][]bool {
		return vs[0].(map[string]map[string][]bool)[vs[1].(string)]
	}).(BoolArrayMapOutput)
}

func ToBoolArrayMapMap(in map[string]map[string][]bool) BoolArrayMapMap {
	m := make(BoolArrayMapMap)
	for k, v := range in {
		m[k] = ToBoolArrayMap(v)
	}
	return m
}

func ToBoolArrayMapMapOutput(in map[string]BoolArrayMapOutput) BoolArrayMapMapOutput {
	m := make(BoolArrayMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToBoolArrayMapMapOutput()
}

var boolMapArrayMapType = reflect.TypeOf((*map[string][]map[string]bool)(nil)).Elem()

// BoolMapArrayMapInput is an input type that accepts BoolMapArrayMap and BoolMapArrayMapOutput values.
type BoolMapArrayMapInput interface {
	Input

	ToBoolMapArrayMapOutput() BoolMapArrayMapOutput
	ToBoolMapArrayMapOutputWithContext(ctx context.Context) BoolMapArrayMapOutput
}

// BoolMapArrayMap is an input type for map[string]BoolMapArrayInput values.
type BoolMapArrayMap map[string]BoolMapArrayInput

// ElementType returns the element type of this Input (map[string][]map[string]bool).
func (BoolMapArrayMap) ElementType() reflect.Type {
	return boolMapArrayMapType
}

func (in BoolMapArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]bool] {
	return pulumix.Output[map[string][]map[string]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolMapArrayMap) ToBoolMapArrayMapOutput() BoolMapArrayMapOutput {
	return ToOutput(in).(BoolMapArrayMapOutput)
}

func (in BoolMapArrayMap) ToBoolMapArrayMapOutputWithContext(ctx context.Context) BoolMapArrayMapOutput {
	return ToOutputWithContext(ctx, in).(BoolMapArrayMapOutput)
}

// BoolMapArrayMapOutput is an Output that returns map[string][]map[string]bool values.
type BoolMapArrayMapOutput struct{ *OutputState }

func (BoolMapArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolMapArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]bool] {
	return pulumix.Output[map[string][]map[string]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]map[string]bool).
func (BoolMapArrayMapOutput) ElementType() reflect.Type {
	return boolMapArrayMapType
}

func (o BoolMapArrayMapOutput) ToBoolMapArrayMapOutput() BoolMapArrayMapOutput {
	return o
}

func (o BoolMapArrayMapOutput) ToBoolMapArrayMapOutputWithContext(ctx context.Context) BoolMapArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o BoolMapArrayMapOutput) MapIndex(k StringInput) BoolMapArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []map[string]bool {
		return vs[0].(map[string][]map[string]bool)[vs[1].(string)]
	}).(BoolMapArrayOutput)
}

func ToBoolMapArrayMap(in map[string][]map[string]bool) BoolMapArrayMap {
	m := make(BoolMapArrayMap)
	for k, v := range in {
		m[k] = ToBoolMapArray(v)
	}
	return m
}

func ToBoolMapArrayMapOutput(in map[string]BoolMapArrayOutput) BoolMapArrayMapOutput {
	m := make(BoolMapArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToBoolMapArrayMapOutput()
}

var boolMapMapArrayType = reflect.TypeOf((*[]map[string]map[string]bool)(nil)).Elem()

// BoolMapMapArrayInput is an input type that accepts BoolMapMapArray and BoolMapMapArrayOutput values.
type BoolMapMapArrayInput interface {
	Input

	ToBoolMapMapArrayOutput() BoolMapMapArrayOutput
	ToBoolMapMapArrayOutputWithContext(ctx context.Context) BoolMapMapArrayOutput
}

// BoolMapMapArray is an input type for []BoolMapMapInput values.
type BoolMapMapArray []BoolMapMapInput

// ElementType returns the element type of this Input ([]map[string]map[string]bool).
func (BoolMapMapArray) ElementType() reflect.Type {
	return boolMapMapArrayType
}

func (in BoolMapMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]bool] {
	return pulumix.Output[[]map[string]map[string]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolMapMapArray) ToBoolMapMapArrayOutput() BoolMapMapArrayOutput {
	return ToOutput(in).(BoolMapMapArrayOutput)
}

func (in BoolMapMapArray) ToBoolMapMapArrayOutputWithContext(ctx context.Context) BoolMapMapArrayOutput {
	return ToOutputWithContext(ctx, in).(BoolMapMapArrayOutput)
}

// BoolMapMapArrayOutput is an Output that returns []map[string]map[string]bool values.
type BoolMapMapArrayOutput struct{ *OutputState }

func (BoolMapMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolMapMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]bool] {
	return pulumix.Output[[]map[string]map[string]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]map[string]bool).
func (BoolMapMapArrayOutput) ElementType() reflect.Type {
	return boolMapMapArrayType
}

func (o BoolMapMapArrayOutput) ToBoolMapMapArrayOutput() BoolMapMapArrayOutput {
	return o
}

func (o BoolMapMapArrayOutput) ToBoolMapMapArrayOutputWithContext(ctx context.Context) BoolMapMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o BoolMapMapArrayOutput) Index(i IntInput) BoolMapMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]map[string]bool {
		arr := vs[0].([]map[string]map[string]bool)
		idx := vs[1].(int)
		var ret map[string]map[string]bool
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(BoolMapMapOutput)
}

func ToBoolMapMapArray(in []map[string]map[string]bool) BoolMapMapArray {
	a := make(BoolMapMapArray, len(in))
	for i, v := range in {
		a[i] = ToBoolMapMap(v)
	}
	return a
}

func ToBoolMapMapArrayOutput(in []BoolMapMapOutput) BoolMapMapArrayOutput {
	a := make(BoolMapMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToBoolMapMapArrayOutput()
}

var boolArrayMapArrayType = reflect.TypeOf((*[]map[string][]bool)(nil)).Elem()

// BoolArrayMapArrayInput is an input type that accepts BoolArrayMapArray and BoolArrayMapArrayOutput values.
type BoolArrayMapArrayInput interface {
	Input

	ToBoolArrayMapArrayOutput() BoolArrayMapArrayOutput
	ToBoolArrayMapArrayOutputWithContext(ctx context.Context) BoolArrayMapArrayOutput
}

// BoolArrayMapArray is an input type for []BoolArrayMapInput values.
type BoolArrayMapArray []BoolArrayMapInput

// ElementType returns the element type of this Input ([]map[string][]bool).
func (BoolArrayMapArray) ElementType() reflect.Type {
	return boolArrayMapArrayType
}

func (in BoolArrayMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]bool] {
	return pulumix.Output[[]map[string][]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolArrayMapArray) ToBoolArrayMapArrayOutput() BoolArrayMapArrayOutput {
	return ToOutput(in).(BoolArrayMapArrayOutput)
}

func (in BoolArrayMapArray) ToBoolArrayMapArrayOutputWithContext(ctx context.Context) BoolArrayMapArrayOutput {
	return ToOutputWithContext(ctx, in).(BoolArrayMapArrayOutput)
}

// BoolArrayMapArrayOutput is an Output that returns []map[string][]bool values.
type BoolArrayMapArrayOutput struct{ *OutputState }

func (BoolArrayMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolArrayMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]bool] {
	return pulumix.Output[[]map[string][]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string][]bool).
func (BoolArrayMapArrayOutput) ElementType() reflect.Type {
	return boolArrayMapArrayType
}

func (o BoolArrayMapArrayOutput) ToBoolArrayMapArrayOutput() BoolArrayMapArrayOutput {
	return o
}

func (o BoolArrayMapArrayOutput) ToBoolArrayMapArrayOutputWithContext(ctx context.Context) BoolArrayMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o BoolArrayMapArrayOutput) Index(i IntInput) BoolArrayMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string][]bool {
		arr := vs[0].([]map[string][]bool)
		idx := vs[1].(int)
		var ret map[string][]bool
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(BoolArrayMapOutput)
}

func ToBoolArrayMapArray(in []map[string][]bool) BoolArrayMapArray {
	a := make(BoolArrayMapArray, len(in))
	for i, v := range in {
		a[i] = ToBoolArrayMap(v)
	}
	return a
}

func ToBoolArrayMapArrayOutput(in []BoolArrayMapOutput) BoolArrayMapArrayOutput {
	a := make(BoolArrayMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToBoolArrayMapArrayOutput()
}

var boolArrayArrayMapType = reflect.TypeOf((*map[string][][]bool)(nil)).Elem()

// BoolArrayArrayMapInput is an input type that accepts BoolArrayArrayMap and BoolArrayArrayMapOutput values.
type BoolArrayArrayMapInput interface {
	Input

	ToBoolArrayArrayMapOutput() BoolArrayArrayMapOutput
	ToBoolArrayArrayMapOutputWithContext(ctx context.Context) BoolArrayArrayMapOutput
}

// BoolArrayArrayMap is an input type for map[string]BoolArrayArrayInput values.
type BoolArrayArrayMap map[string]BoolArrayArrayInput

// ElementType returns the element type of this Input (map[string][][]bool).
func (BoolArrayArrayMap) ElementType() reflect.Type {
	return boolArrayArrayMapType
}

func (in BoolArrayArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][][]bool] {
	return pulumix.Output[map[string][][]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolArrayArrayMap) ToBoolArrayArrayMapOutput() BoolArrayArrayMapOutput {
	return ToOutput(in).(BoolArrayArrayMapOutput)
}

func (in BoolArrayArrayMap) ToBoolArrayArrayMapOutputWithContext(ctx context.Context) BoolArrayArrayMapOutput {
	return ToOutputWithContext(ctx, in).(BoolArrayArrayMapOutput)
}

// BoolArrayArrayMapOutput is an Output that returns map[string][][]bool values.
type BoolArrayArrayMapOutput struct{ *OutputState }

func (BoolArrayArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolArrayArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][][]bool] {
	return pulumix.Output[map[string][][]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][][]bool).
func (BoolArrayArrayMapOutput) ElementType() reflect.Type {
	return boolArrayArrayMapType
}

func (o BoolArrayArrayMapOutput) ToBoolArrayArrayMapOutput() BoolArrayArrayMapOutput {
	return o
}

func (o BoolArrayArrayMapOutput) ToBoolArrayArrayMapOutputWithContext(ctx context.Context) BoolArrayArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o BoolArrayArrayMapOutput) MapIndex(k StringInput) BoolArrayArrayOutput {
	return All(o, k).ApplyT(func(vs []any) [][]bool {
		return vs[0].(map[string][][]bool)[vs[1].(string)]
	}).(BoolArrayArrayOutput)
}

func ToBoolArrayArrayMap(in map[string][][]bool) BoolArrayArrayMap {
	m := make(BoolArrayArrayMap)
	for k, v := range in {
		m[k] = ToBoolArrayArray(v)
	}
	return m
}

func ToBoolArrayArrayMapOutput(in map[string]BoolArrayArrayOutput) BoolArrayArrayMapOutput {
	m := make(BoolArrayArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToBoolArrayArrayMapOutput()
}

var boolArrayArrayArrayType = reflect.TypeOf((*[][][]bool)(nil)).Elem()

// BoolArrayArrayArrayInput is an input type that accepts BoolArrayArrayArray and BoolArrayArrayArrayOutput values.
type BoolArrayArrayArrayInput interface {
	Input

	ToBoolArrayArrayArrayOutput() BoolArrayArrayArrayOutput
	ToBoolArrayArrayArrayOutputWithContext(ctx context.Context) BoolArrayArrayArrayOutput
}

// BoolArrayArrayArray is an input type for []BoolArrayArrayInput values.
type BoolArrayArrayArray []BoolArrayArrayInput

// ElementType returns the element type of this Input ([][][]bool).
func (BoolArrayArrayArray) ElementType() reflect.Type {
	return boolArrayArrayArrayType
}

func (in BoolArrayArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][][]bool] {
	return pulumix.Output[[][][]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolArrayArrayArray) ToBoolArrayArrayArrayOutput() BoolArrayArrayArrayOutput {
	return ToOutput(in).(BoolArrayArrayArrayOutput)
}

func (in BoolArrayArrayArray) ToBoolArrayArrayArrayOutputWithContext(ctx context.Context) BoolArrayArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(BoolArrayArrayArrayOutput)
}

// BoolArrayArrayArrayOutput is an Output that returns [][][]bool values.
type BoolArrayArrayArrayOutput struct{ *OutputState }

func (BoolArrayArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolArrayArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][][]bool] {
	return pulumix.Output[[][][]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][][]bool).
func (BoolArrayArrayArrayOutput) ElementType() reflect.Type {
	return boolArrayArrayArrayType
}

func (o BoolArrayArrayArrayOutput) ToBoolArrayArrayArrayOutput() BoolArrayArrayArrayOutput {
	return o
}

func (o BoolArrayArrayArrayOutput) ToBoolArrayArrayArrayOutputWithContext(ctx context.Context) BoolArrayArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o BoolArrayArrayArrayOutput) Index(i IntInput) BoolArrayArrayOutput {
	return All(o, i).ApplyT(func(vs []any) [][]bool {
		arr := vs[0].([][][]bool)
		idx := vs[1].(int)
		var ret [][]bool
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(BoolArrayArrayOutput)
}

func ToBoolArrayArrayArray(in [][][]bool) BoolArrayArrayArray {
	a := make(BoolArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = ToBoolArrayArray(v)
	}
	return a
}

func ToBoolArrayArrayArrayOutput(in []BoolArrayArrayOutput) BoolArrayArrayArrayOutput {
	a := make(BoolArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToBoolArrayArrayArrayOutput()
}

var boolMapMapMapType = reflect.TypeOf((*map[string]map[string]map[string]bool)(nil)).Elem()

// BoolMapMapMapInput is an input type that accepts BoolMapMapMap and BoolMapMapMapOutput values.
type BoolMapMapMapInput interface {
	Input

	ToBoolMapMapMapOutput() BoolMapMapMapOutput
	ToBoolMapMapMapOutputWithContext(ctx context.Context) BoolMapMapMapOutput
}

// BoolMapMapMap is an input type for map[string]BoolMapMapInput values.
type BoolMapMapMap map[string]BoolMapMapInput

// ElementType returns the element type of this Input (map[string]map[string]map[string]bool).
func (BoolMapMapMap) ElementType() reflect.Type {
	return boolMapMapMapType
}

func (in BoolMapMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]bool] {
	return pulumix.Output[map[string]map[string]map[string]bool]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in BoolMapMapMap) ToBoolMapMapMapOutput() BoolMapMapMapOutput {
	return ToOutput(in).(BoolMapMapMapOutput)
}

func (in BoolMapMapMap) ToBoolMapMapMapOutputWithContext(ctx context.Context) BoolMapMapMapOutput {
	return ToOutputWithContext(ctx, in).(BoolMapMapMapOutput)
}

// BoolMapMapMapOutput is an Output that returns map[string]map[string]map[string]bool values.
type BoolMapMapMapOutput struct{ *OutputState }

func (BoolMapMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o BoolMapMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]bool] {
	return pulumix.Output[map[string]map[string]map[string]bool]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]map[string]bool).
func (BoolMapMapMapOutput) ElementType() reflect.Type {
	return boolMapMapMapType
}

func (o BoolMapMapMapOutput) ToBoolMapMapMapOutput() BoolMapMapMapOutput {
	return o
}

func (o BoolMapMapMapOutput) ToBoolMapMapMapOutputWithContext(ctx context.Context) BoolMapMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o BoolMapMapMapOutput) MapIndex(k StringInput) BoolMapMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]map[string]bool {
		return vs[0].(map[string]map[string]map[string]bool)[vs[1].(string)]
	}).(BoolMapMapOutput)
}

func ToBoolMapMapMap(in map[string]map[string]map[string]bool) BoolMapMapMap {
	m := make(BoolMapMapMap)
	for k, v := range in {
		m[k] = ToBoolMapMap(v)
	}
	return m
}

func ToBoolMapMapMapOutput(in map[string]BoolMapMapOutput) BoolMapMapMapOutput {
	m := make(BoolMapMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToBoolMapMapMapOutput()
}

var float64Type = reflect.TypeOf((*float64)(nil)).Elem()

// Float64Input is an input type that accepts Float64 and Float64Output values.
type Float64Input interface {
	Input

	ToFloat64Output() Float64Output
	ToFloat64OutputWithContext(ctx context.Context) Float64Output

	ToFloat64PtrOutput() Float64PtrOutput
	ToFloat64PtrOutputWithContext(ctx context.Context) Float64PtrOutput
}

// Float64 is an input type for float64 values.
type Float64 float64

// ElementType returns the element type of this Input (float64).
func (Float64) ElementType() reflect.Type {
	return float64Type
}

func (in Float64) ToOutput(ctx context.Context) pulumix.Output[float64] {
	return pulumix.Output[float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64) ToFloat64Output() Float64Output {
	return ToOutput(in).(Float64Output)
}

func (in Float64) ToFloat64OutputWithContext(ctx context.Context) Float64Output {
	return ToOutputWithContext(ctx, in).(Float64Output)
}

func (in Float64) ToFloat64PtrOutput() Float64PtrOutput {
	return in.ToFloat64PtrOutputWithContext(context.Background())
}

func (in Float64) ToFloat64PtrOutputWithContext(ctx context.Context) Float64PtrOutput {
	return in.ToFloat64OutputWithContext(ctx).ToFloat64PtrOutputWithContext(ctx)
}

// Float64Output is an Output that returns float64 values.
type Float64Output struct{ *OutputState }

func (Float64Output) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64Output) ToOutput(ctx context.Context) pulumix.Output[float64] {
	return pulumix.Output[float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (float64).
func (Float64Output) ElementType() reflect.Type {
	return float64Type
}

func (o Float64Output) ToFloat64Output() Float64Output {
	return o
}

func (o Float64Output) ToFloat64OutputWithContext(ctx context.Context) Float64Output {
	return o
}

func (o Float64Output) ToFloat64PtrOutput() Float64PtrOutput {
	return o.ToFloat64PtrOutputWithContext(context.Background())
}

func (o Float64Output) ToFloat64PtrOutputWithContext(ctx context.Context) Float64PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v float64) *float64 {
		return &v
	}).(Float64PtrOutput)
}

var float64PtrType = reflect.TypeOf((**float64)(nil)).Elem()

// Float64PtrInput is an input type that accepts Float64Ptr and Float64PtrOutput values.
type Float64PtrInput interface {
	Input

	ToFloat64PtrOutput() Float64PtrOutput
	ToFloat64PtrOutputWithContext(ctx context.Context) Float64PtrOutput
}

type float64Ptr float64

// Float64Ptr is an input type for *float64 values.
func Float64Ptr(v float64) Float64PtrInput {
	return (*float64Ptr)(&v)
}

func Float64PtrFromPtr(v *float64) Float64PtrInput {
	if v == nil {
		return nil
	}
	return (*float64Ptr)(v)
}

// ElementType returns the element type of this Input (*float64).
func (*float64Ptr) ElementType() reflect.Type {
	return float64PtrType
}

func (in *float64Ptr) ToOutput(ctx context.Context) pulumix.Output[*float64] {
	return pulumix.Output[*float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in *float64Ptr) ToFloat64PtrOutput() Float64PtrOutput {
	return ToOutput(in).(Float64PtrOutput)
}

func (in *float64Ptr) ToFloat64PtrOutputWithContext(ctx context.Context) Float64PtrOutput {
	return ToOutputWithContext(ctx, in).(Float64PtrOutput)
}

// Float64PtrOutput is an Output that returns *float64 values.
type Float64PtrOutput struct{ *OutputState }

func (Float64PtrOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64PtrOutput) ToOutput(ctx context.Context) pulumix.Output[*float64] {
	return pulumix.Output[*float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (*float64).
func (Float64PtrOutput) ElementType() reflect.Type {
	return float64PtrType
}

func (o Float64PtrOutput) ToFloat64PtrOutput() Float64PtrOutput {
	return o
}

func (o Float64PtrOutput) ToFloat64PtrOutputWithContext(ctx context.Context) Float64PtrOutput {
	return o
}

// Elem dereferences the pointer value or returns the zero value of the approporiate type if the pointer is nil.
func (o Float64PtrOutput) Elem() Float64Output {
	return o.ApplyT(func(v *float64) float64 {
		var ret float64
		if v != nil {
			ret = *v
		}
		return ret
	}).(Float64Output)
}

var float64ArrayType = reflect.TypeOf((*[]float64)(nil)).Elem()

// Float64ArrayInput is an input type that accepts Float64Array and Float64ArrayOutput values.
type Float64ArrayInput interface {
	Input

	ToFloat64ArrayOutput() Float64ArrayOutput
	ToFloat64ArrayOutputWithContext(ctx context.Context) Float64ArrayOutput
}

// Float64Array is an input type for []Float64Input values.
type Float64Array []Float64Input

// ElementType returns the element type of this Input ([]float64).
func (Float64Array) ElementType() reflect.Type {
	return float64ArrayType
}

func (in Float64Array) ToOutput(ctx context.Context) pulumix.Output[[]float64] {
	return pulumix.Output[[]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64Array) ToFloat64ArrayOutput() Float64ArrayOutput {
	return ToOutput(in).(Float64ArrayOutput)
}

func (in Float64Array) ToFloat64ArrayOutputWithContext(ctx context.Context) Float64ArrayOutput {
	return ToOutputWithContext(ctx, in).(Float64ArrayOutput)
}

// Float64ArrayOutput is an Output that returns []float64 values.
type Float64ArrayOutput struct{ *OutputState }

func (Float64ArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64ArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]float64] {
	return pulumix.Output[[]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]float64).
func (Float64ArrayOutput) ElementType() reflect.Type {
	return float64ArrayType
}

func (o Float64ArrayOutput) ToFloat64ArrayOutput() Float64ArrayOutput {
	return o
}

func (o Float64ArrayOutput) ToFloat64ArrayOutputWithContext(ctx context.Context) Float64ArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o Float64ArrayOutput) Index(i IntInput) Float64Output {
	return All(o, i).ApplyT(func(vs []any) float64 {
		arr := vs[0].([]float64)
		idx := vs[1].(int)
		var ret float64
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(Float64Output)
}

func ToFloat64Array(in []float64) Float64Array {
	a := make(Float64Array, len(in))
	for i, v := range in {
		a[i] = Float64(v)
	}
	return a
}

func ToFloat64ArrayOutput(in []Float64Output) Float64ArrayOutput {
	a := make(Float64Array, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToFloat64ArrayOutput()
}

var float64MapType = reflect.TypeOf((*map[string]float64)(nil)).Elem()

// Float64MapInput is an input type that accepts Float64Map and Float64MapOutput values.
type Float64MapInput interface {
	Input

	ToFloat64MapOutput() Float64MapOutput
	ToFloat64MapOutputWithContext(ctx context.Context) Float64MapOutput
}

// Float64Map is an input type for map[string]Float64Input values.
type Float64Map map[string]Float64Input

// ElementType returns the element type of this Input (map[string]float64).
func (Float64Map) ElementType() reflect.Type {
	return float64MapType
}

func (in Float64Map) ToOutput(ctx context.Context) pulumix.Output[map[string]float64] {
	return pulumix.Output[map[string]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64Map) ToFloat64MapOutput() Float64MapOutput {
	return ToOutput(in).(Float64MapOutput)
}

func (in Float64Map) ToFloat64MapOutputWithContext(ctx context.Context) Float64MapOutput {
	return ToOutputWithContext(ctx, in).(Float64MapOutput)
}

// Float64MapOutput is an Output that returns map[string]float64 values.
type Float64MapOutput struct{ *OutputState }

func (Float64MapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64MapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]float64] {
	return pulumix.Output[map[string]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]float64).
func (Float64MapOutput) ElementType() reflect.Type {
	return float64MapType
}

func (o Float64MapOutput) ToFloat64MapOutput() Float64MapOutput {
	return o
}

func (o Float64MapOutput) ToFloat64MapOutputWithContext(ctx context.Context) Float64MapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o Float64MapOutput) MapIndex(k StringInput) Float64Output {
	return All(o, k).ApplyT(func(vs []any) float64 {
		return vs[0].(map[string]float64)[vs[1].(string)]
	}).(Float64Output)
}

func ToFloat64Map(in map[string]float64) Float64Map {
	m := make(Float64Map)
	for k, v := range in {
		m[k] = Float64(v)
	}
	return m
}

func ToFloat64MapOutput(in map[string]Float64Output) Float64MapOutput {
	m := make(Float64Map)
	for k, v := range in {
		m[k] = v
	}
	return m.ToFloat64MapOutput()
}

var float64ArrayMapType = reflect.TypeOf((*map[string][]float64)(nil)).Elem()

// Float64ArrayMapInput is an input type that accepts Float64ArrayMap and Float64ArrayMapOutput values.
type Float64ArrayMapInput interface {
	Input

	ToFloat64ArrayMapOutput() Float64ArrayMapOutput
	ToFloat64ArrayMapOutputWithContext(ctx context.Context) Float64ArrayMapOutput
}

// Float64ArrayMap is an input type for map[string]Float64ArrayInput values.
type Float64ArrayMap map[string]Float64ArrayInput

// ElementType returns the element type of this Input (map[string][]float64).
func (Float64ArrayMap) ElementType() reflect.Type {
	return float64ArrayMapType
}

func (in Float64ArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]float64] {
	return pulumix.Output[map[string][]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64ArrayMap) ToFloat64ArrayMapOutput() Float64ArrayMapOutput {
	return ToOutput(in).(Float64ArrayMapOutput)
}

func (in Float64ArrayMap) ToFloat64ArrayMapOutputWithContext(ctx context.Context) Float64ArrayMapOutput {
	return ToOutputWithContext(ctx, in).(Float64ArrayMapOutput)
}

// Float64ArrayMapOutput is an Output that returns map[string][]float64 values.
type Float64ArrayMapOutput struct{ *OutputState }

func (Float64ArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64ArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]float64] {
	return pulumix.Output[map[string][]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]float64).
func (Float64ArrayMapOutput) ElementType() reflect.Type {
	return float64ArrayMapType
}

func (o Float64ArrayMapOutput) ToFloat64ArrayMapOutput() Float64ArrayMapOutput {
	return o
}

func (o Float64ArrayMapOutput) ToFloat64ArrayMapOutputWithContext(ctx context.Context) Float64ArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o Float64ArrayMapOutput) MapIndex(k StringInput) Float64ArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []float64 {
		return vs[0].(map[string][]float64)[vs[1].(string)]
	}).(Float64ArrayOutput)
}

func ToFloat64ArrayMap(in map[string][]float64) Float64ArrayMap {
	m := make(Float64ArrayMap)
	for k, v := range in {
		m[k] = ToFloat64Array(v)
	}
	return m
}

func ToFloat64ArrayMapOutput(in map[string]Float64ArrayOutput) Float64ArrayMapOutput {
	m := make(Float64ArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToFloat64ArrayMapOutput()
}

var float64MapArrayType = reflect.TypeOf((*[]map[string]float64)(nil)).Elem()

// Float64MapArrayInput is an input type that accepts Float64MapArray and Float64MapArrayOutput values.
type Float64MapArrayInput interface {
	Input

	ToFloat64MapArrayOutput() Float64MapArrayOutput
	ToFloat64MapArrayOutputWithContext(ctx context.Context) Float64MapArrayOutput
}

// Float64MapArray is an input type for []Float64MapInput values.
type Float64MapArray []Float64MapInput

// ElementType returns the element type of this Input ([]map[string]float64).
func (Float64MapArray) ElementType() reflect.Type {
	return float64MapArrayType
}

func (in Float64MapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]float64] {
	return pulumix.Output[[]map[string]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64MapArray) ToFloat64MapArrayOutput() Float64MapArrayOutput {
	return ToOutput(in).(Float64MapArrayOutput)
}

func (in Float64MapArray) ToFloat64MapArrayOutputWithContext(ctx context.Context) Float64MapArrayOutput {
	return ToOutputWithContext(ctx, in).(Float64MapArrayOutput)
}

// Float64MapArrayOutput is an Output that returns []map[string]float64 values.
type Float64MapArrayOutput struct{ *OutputState }

func (Float64MapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64MapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]float64] {
	return pulumix.Output[[]map[string]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]float64).
func (Float64MapArrayOutput) ElementType() reflect.Type {
	return float64MapArrayType
}

func (o Float64MapArrayOutput) ToFloat64MapArrayOutput() Float64MapArrayOutput {
	return o
}

func (o Float64MapArrayOutput) ToFloat64MapArrayOutputWithContext(ctx context.Context) Float64MapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o Float64MapArrayOutput) Index(i IntInput) Float64MapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]float64 {
		arr := vs[0].([]map[string]float64)
		idx := vs[1].(int)
		var ret map[string]float64
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(Float64MapOutput)
}

func ToFloat64MapArray(in []map[string]float64) Float64MapArray {
	a := make(Float64MapArray, len(in))
	for i, v := range in {
		a[i] = ToFloat64Map(v)
	}
	return a
}

func ToFloat64MapArrayOutput(in []Float64MapOutput) Float64MapArrayOutput {
	a := make(Float64MapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToFloat64MapArrayOutput()
}

var float64MapMapType = reflect.TypeOf((*map[string]map[string]float64)(nil)).Elem()

// Float64MapMapInput is an input type that accepts Float64MapMap and Float64MapMapOutput values.
type Float64MapMapInput interface {
	Input

	ToFloat64MapMapOutput() Float64MapMapOutput
	ToFloat64MapMapOutputWithContext(ctx context.Context) Float64MapMapOutput
}

// Float64MapMap is an input type for map[string]Float64MapInput values.
type Float64MapMap map[string]Float64MapInput

// ElementType returns the element type of this Input (map[string]map[string]float64).
func (Float64MapMap) ElementType() reflect.Type {
	return float64MapMapType
}

func (in Float64MapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]float64] {
	return pulumix.Output[map[string]map[string]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64MapMap) ToFloat64MapMapOutput() Float64MapMapOutput {
	return ToOutput(in).(Float64MapMapOutput)
}

func (in Float64MapMap) ToFloat64MapMapOutputWithContext(ctx context.Context) Float64MapMapOutput {
	return ToOutputWithContext(ctx, in).(Float64MapMapOutput)
}

// Float64MapMapOutput is an Output that returns map[string]map[string]float64 values.
type Float64MapMapOutput struct{ *OutputState }

func (Float64MapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64MapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]float64] {
	return pulumix.Output[map[string]map[string]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]float64).
func (Float64MapMapOutput) ElementType() reflect.Type {
	return float64MapMapType
}

func (o Float64MapMapOutput) ToFloat64MapMapOutput() Float64MapMapOutput {
	return o
}

func (o Float64MapMapOutput) ToFloat64MapMapOutputWithContext(ctx context.Context) Float64MapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o Float64MapMapOutput) MapIndex(k StringInput) Float64MapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]float64 {
		return vs[0].(map[string]map[string]float64)[vs[1].(string)]
	}).(Float64MapOutput)
}

func ToFloat64MapMap(in map[string]map[string]float64) Float64MapMap {
	m := make(Float64MapMap)
	for k, v := range in {
		m[k] = ToFloat64Map(v)
	}
	return m
}

func ToFloat64MapMapOutput(in map[string]Float64MapOutput) Float64MapMapOutput {
	m := make(Float64MapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToFloat64MapMapOutput()
}

var float64ArrayArrayType = reflect.TypeOf((*[][]float64)(nil)).Elem()

// Float64ArrayArrayInput is an input type that accepts Float64ArrayArray and Float64ArrayArrayOutput values.
type Float64ArrayArrayInput interface {
	Input

	ToFloat64ArrayArrayOutput() Float64ArrayArrayOutput
	ToFloat64ArrayArrayOutputWithContext(ctx context.Context) Float64ArrayArrayOutput
}

// Float64ArrayArray is an input type for []Float64ArrayInput values.
type Float64ArrayArray []Float64ArrayInput

// ElementType returns the element type of this Input ([][]float64).
func (Float64ArrayArray) ElementType() reflect.Type {
	return float64ArrayArrayType
}

func (in Float64ArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][]float64] {
	return pulumix.Output[[][]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64ArrayArray) ToFloat64ArrayArrayOutput() Float64ArrayArrayOutput {
	return ToOutput(in).(Float64ArrayArrayOutput)
}

func (in Float64ArrayArray) ToFloat64ArrayArrayOutputWithContext(ctx context.Context) Float64ArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(Float64ArrayArrayOutput)
}

// Float64ArrayArrayOutput is an Output that returns [][]float64 values.
type Float64ArrayArrayOutput struct{ *OutputState }

func (Float64ArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64ArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][]float64] {
	return pulumix.Output[[][]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][]float64).
func (Float64ArrayArrayOutput) ElementType() reflect.Type {
	return float64ArrayArrayType
}

func (o Float64ArrayArrayOutput) ToFloat64ArrayArrayOutput() Float64ArrayArrayOutput {
	return o
}

func (o Float64ArrayArrayOutput) ToFloat64ArrayArrayOutputWithContext(ctx context.Context) Float64ArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o Float64ArrayArrayOutput) Index(i IntInput) Float64ArrayOutput {
	return All(o, i).ApplyT(func(vs []any) []float64 {
		arr := vs[0].([][]float64)
		idx := vs[1].(int)
		var ret []float64
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(Float64ArrayOutput)
}

func ToFloat64ArrayArray(in [][]float64) Float64ArrayArray {
	a := make(Float64ArrayArray, len(in))
	for i, v := range in {
		a[i] = ToFloat64Array(v)
	}
	return a
}

func ToFloat64ArrayArrayOutput(in []Float64ArrayOutput) Float64ArrayArrayOutput {
	a := make(Float64ArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToFloat64ArrayArrayOutput()
}

var float64ArrayMapMapType = reflect.TypeOf((*map[string]map[string][]float64)(nil)).Elem()

// Float64ArrayMapMapInput is an input type that accepts Float64ArrayMapMap and Float64ArrayMapMapOutput values.
type Float64ArrayMapMapInput interface {
	Input

	ToFloat64ArrayMapMapOutput() Float64ArrayMapMapOutput
	ToFloat64ArrayMapMapOutputWithContext(ctx context.Context) Float64ArrayMapMapOutput
}

// Float64ArrayMapMap is an input type for map[string]Float64ArrayMapInput values.
type Float64ArrayMapMap map[string]Float64ArrayMapInput

// ElementType returns the element type of this Input (map[string]map[string][]float64).
func (Float64ArrayMapMap) ElementType() reflect.Type {
	return float64ArrayMapMapType
}

func (in Float64ArrayMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]float64] {
	return pulumix.Output[map[string]map[string][]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64ArrayMapMap) ToFloat64ArrayMapMapOutput() Float64ArrayMapMapOutput {
	return ToOutput(in).(Float64ArrayMapMapOutput)
}

func (in Float64ArrayMapMap) ToFloat64ArrayMapMapOutputWithContext(ctx context.Context) Float64ArrayMapMapOutput {
	return ToOutputWithContext(ctx, in).(Float64ArrayMapMapOutput)
}

// Float64ArrayMapMapOutput is an Output that returns map[string]map[string][]float64 values.
type Float64ArrayMapMapOutput struct{ *OutputState }

func (Float64ArrayMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64ArrayMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]float64] {
	return pulumix.Output[map[string]map[string][]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string][]float64).
func (Float64ArrayMapMapOutput) ElementType() reflect.Type {
	return float64ArrayMapMapType
}

func (o Float64ArrayMapMapOutput) ToFloat64ArrayMapMapOutput() Float64ArrayMapMapOutput {
	return o
}

func (o Float64ArrayMapMapOutput) ToFloat64ArrayMapMapOutputWithContext(ctx context.Context) Float64ArrayMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o Float64ArrayMapMapOutput) MapIndex(k StringInput) Float64ArrayMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string][]float64 {
		return vs[0].(map[string]map[string][]float64)[vs[1].(string)]
	}).(Float64ArrayMapOutput)
}

func ToFloat64ArrayMapMap(in map[string]map[string][]float64) Float64ArrayMapMap {
	m := make(Float64ArrayMapMap)
	for k, v := range in {
		m[k] = ToFloat64ArrayMap(v)
	}
	return m
}

func ToFloat64ArrayMapMapOutput(in map[string]Float64ArrayMapOutput) Float64ArrayMapMapOutput {
	m := make(Float64ArrayMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToFloat64ArrayMapMapOutput()
}

var float64MapArrayMapType = reflect.TypeOf((*map[string][]map[string]float64)(nil)).Elem()

// Float64MapArrayMapInput is an input type that accepts Float64MapArrayMap and Float64MapArrayMapOutput values.
type Float64MapArrayMapInput interface {
	Input

	ToFloat64MapArrayMapOutput() Float64MapArrayMapOutput
	ToFloat64MapArrayMapOutputWithContext(ctx context.Context) Float64MapArrayMapOutput
}

// Float64MapArrayMap is an input type for map[string]Float64MapArrayInput values.
type Float64MapArrayMap map[string]Float64MapArrayInput

// ElementType returns the element type of this Input (map[string][]map[string]float64).
func (Float64MapArrayMap) ElementType() reflect.Type {
	return float64MapArrayMapType
}

func (in Float64MapArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]float64] {
	return pulumix.Output[map[string][]map[string]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64MapArrayMap) ToFloat64MapArrayMapOutput() Float64MapArrayMapOutput {
	return ToOutput(in).(Float64MapArrayMapOutput)
}

func (in Float64MapArrayMap) ToFloat64MapArrayMapOutputWithContext(ctx context.Context) Float64MapArrayMapOutput {
	return ToOutputWithContext(ctx, in).(Float64MapArrayMapOutput)
}

// Float64MapArrayMapOutput is an Output that returns map[string][]map[string]float64 values.
type Float64MapArrayMapOutput struct{ *OutputState }

func (Float64MapArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64MapArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]float64] {
	return pulumix.Output[map[string][]map[string]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]map[string]float64).
func (Float64MapArrayMapOutput) ElementType() reflect.Type {
	return float64MapArrayMapType
}

func (o Float64MapArrayMapOutput) ToFloat64MapArrayMapOutput() Float64MapArrayMapOutput {
	return o
}

func (o Float64MapArrayMapOutput) ToFloat64MapArrayMapOutputWithContext(ctx context.Context) Float64MapArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o Float64MapArrayMapOutput) MapIndex(k StringInput) Float64MapArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []map[string]float64 {
		return vs[0].(map[string][]map[string]float64)[vs[1].(string)]
	}).(Float64MapArrayOutput)
}

func ToFloat64MapArrayMap(in map[string][]map[string]float64) Float64MapArrayMap {
	m := make(Float64MapArrayMap)
	for k, v := range in {
		m[k] = ToFloat64MapArray(v)
	}
	return m
}

func ToFloat64MapArrayMapOutput(in map[string]Float64MapArrayOutput) Float64MapArrayMapOutput {
	m := make(Float64MapArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToFloat64MapArrayMapOutput()
}

var float64MapMapArrayType = reflect.TypeOf((*[]map[string]map[string]float64)(nil)).Elem()

// Float64MapMapArrayInput is an input type that accepts Float64MapMapArray and Float64MapMapArrayOutput values.
type Float64MapMapArrayInput interface {
	Input

	ToFloat64MapMapArrayOutput() Float64MapMapArrayOutput
	ToFloat64MapMapArrayOutputWithContext(ctx context.Context) Float64MapMapArrayOutput
}

// Float64MapMapArray is an input type for []Float64MapMapInput values.
type Float64MapMapArray []Float64MapMapInput

// ElementType returns the element type of this Input ([]map[string]map[string]float64).
func (Float64MapMapArray) ElementType() reflect.Type {
	return float64MapMapArrayType
}

func (in Float64MapMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]float64] {
	return pulumix.Output[[]map[string]map[string]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64MapMapArray) ToFloat64MapMapArrayOutput() Float64MapMapArrayOutput {
	return ToOutput(in).(Float64MapMapArrayOutput)
}

func (in Float64MapMapArray) ToFloat64MapMapArrayOutputWithContext(ctx context.Context) Float64MapMapArrayOutput {
	return ToOutputWithContext(ctx, in).(Float64MapMapArrayOutput)
}

// Float64MapMapArrayOutput is an Output that returns []map[string]map[string]float64 values.
type Float64MapMapArrayOutput struct{ *OutputState }

func (Float64MapMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64MapMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]float64] {
	return pulumix.Output[[]map[string]map[string]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]map[string]float64).
func (Float64MapMapArrayOutput) ElementType() reflect.Type {
	return float64MapMapArrayType
}

func (o Float64MapMapArrayOutput) ToFloat64MapMapArrayOutput() Float64MapMapArrayOutput {
	return o
}

func (o Float64MapMapArrayOutput) ToFloat64MapMapArrayOutputWithContext(ctx context.Context) Float64MapMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o Float64MapMapArrayOutput) Index(i IntInput) Float64MapMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]map[string]float64 {
		arr := vs[0].([]map[string]map[string]float64)
		idx := vs[1].(int)
		var ret map[string]map[string]float64
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(Float64MapMapOutput)
}

func ToFloat64MapMapArray(in []map[string]map[string]float64) Float64MapMapArray {
	a := make(Float64MapMapArray, len(in))
	for i, v := range in {
		a[i] = ToFloat64MapMap(v)
	}
	return a
}

func ToFloat64MapMapArrayOutput(in []Float64MapMapOutput) Float64MapMapArrayOutput {
	a := make(Float64MapMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToFloat64MapMapArrayOutput()
}

var float64ArrayMapArrayType = reflect.TypeOf((*[]map[string][]float64)(nil)).Elem()

// Float64ArrayMapArrayInput is an input type that accepts Float64ArrayMapArray and Float64ArrayMapArrayOutput values.
type Float64ArrayMapArrayInput interface {
	Input

	ToFloat64ArrayMapArrayOutput() Float64ArrayMapArrayOutput
	ToFloat64ArrayMapArrayOutputWithContext(ctx context.Context) Float64ArrayMapArrayOutput
}

// Float64ArrayMapArray is an input type for []Float64ArrayMapInput values.
type Float64ArrayMapArray []Float64ArrayMapInput

// ElementType returns the element type of this Input ([]map[string][]float64).
func (Float64ArrayMapArray) ElementType() reflect.Type {
	return float64ArrayMapArrayType
}

func (in Float64ArrayMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]float64] {
	return pulumix.Output[[]map[string][]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64ArrayMapArray) ToFloat64ArrayMapArrayOutput() Float64ArrayMapArrayOutput {
	return ToOutput(in).(Float64ArrayMapArrayOutput)
}

func (in Float64ArrayMapArray) ToFloat64ArrayMapArrayOutputWithContext(ctx context.Context) Float64ArrayMapArrayOutput {
	return ToOutputWithContext(ctx, in).(Float64ArrayMapArrayOutput)
}

// Float64ArrayMapArrayOutput is an Output that returns []map[string][]float64 values.
type Float64ArrayMapArrayOutput struct{ *OutputState }

func (Float64ArrayMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64ArrayMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]float64] {
	return pulumix.Output[[]map[string][]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string][]float64).
func (Float64ArrayMapArrayOutput) ElementType() reflect.Type {
	return float64ArrayMapArrayType
}

func (o Float64ArrayMapArrayOutput) ToFloat64ArrayMapArrayOutput() Float64ArrayMapArrayOutput {
	return o
}

func (o Float64ArrayMapArrayOutput) ToFloat64ArrayMapArrayOutputWithContext(ctx context.Context) Float64ArrayMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o Float64ArrayMapArrayOutput) Index(i IntInput) Float64ArrayMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string][]float64 {
		arr := vs[0].([]map[string][]float64)
		idx := vs[1].(int)
		var ret map[string][]float64
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(Float64ArrayMapOutput)
}

func ToFloat64ArrayMapArray(in []map[string][]float64) Float64ArrayMapArray {
	a := make(Float64ArrayMapArray, len(in))
	for i, v := range in {
		a[i] = ToFloat64ArrayMap(v)
	}
	return a
}

func ToFloat64ArrayMapArrayOutput(in []Float64ArrayMapOutput) Float64ArrayMapArrayOutput {
	a := make(Float64ArrayMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToFloat64ArrayMapArrayOutput()
}

var float64ArrayArrayMapType = reflect.TypeOf((*map[string][][]float64)(nil)).Elem()

// Float64ArrayArrayMapInput is an input type that accepts Float64ArrayArrayMap and Float64ArrayArrayMapOutput values.
type Float64ArrayArrayMapInput interface {
	Input

	ToFloat64ArrayArrayMapOutput() Float64ArrayArrayMapOutput
	ToFloat64ArrayArrayMapOutputWithContext(ctx context.Context) Float64ArrayArrayMapOutput
}

// Float64ArrayArrayMap is an input type for map[string]Float64ArrayArrayInput values.
type Float64ArrayArrayMap map[string]Float64ArrayArrayInput

// ElementType returns the element type of this Input (map[string][][]float64).
func (Float64ArrayArrayMap) ElementType() reflect.Type {
	return float64ArrayArrayMapType
}

func (in Float64ArrayArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][][]float64] {
	return pulumix.Output[map[string][][]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64ArrayArrayMap) ToFloat64ArrayArrayMapOutput() Float64ArrayArrayMapOutput {
	return ToOutput(in).(Float64ArrayArrayMapOutput)
}

func (in Float64ArrayArrayMap) ToFloat64ArrayArrayMapOutputWithContext(ctx context.Context) Float64ArrayArrayMapOutput {
	return ToOutputWithContext(ctx, in).(Float64ArrayArrayMapOutput)
}

// Float64ArrayArrayMapOutput is an Output that returns map[string][][]float64 values.
type Float64ArrayArrayMapOutput struct{ *OutputState }

func (Float64ArrayArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64ArrayArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][][]float64] {
	return pulumix.Output[map[string][][]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][][]float64).
func (Float64ArrayArrayMapOutput) ElementType() reflect.Type {
	return float64ArrayArrayMapType
}

func (o Float64ArrayArrayMapOutput) ToFloat64ArrayArrayMapOutput() Float64ArrayArrayMapOutput {
	return o
}

func (o Float64ArrayArrayMapOutput) ToFloat64ArrayArrayMapOutputWithContext(ctx context.Context) Float64ArrayArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o Float64ArrayArrayMapOutput) MapIndex(k StringInput) Float64ArrayArrayOutput {
	return All(o, k).ApplyT(func(vs []any) [][]float64 {
		return vs[0].(map[string][][]float64)[vs[1].(string)]
	}).(Float64ArrayArrayOutput)
}

func ToFloat64ArrayArrayMap(in map[string][][]float64) Float64ArrayArrayMap {
	m := make(Float64ArrayArrayMap)
	for k, v := range in {
		m[k] = ToFloat64ArrayArray(v)
	}
	return m
}

func ToFloat64ArrayArrayMapOutput(in map[string]Float64ArrayArrayOutput) Float64ArrayArrayMapOutput {
	m := make(Float64ArrayArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToFloat64ArrayArrayMapOutput()
}

var float64ArrayArrayArrayType = reflect.TypeOf((*[][][]float64)(nil)).Elem()

// Float64ArrayArrayArrayInput is an input type that accepts Float64ArrayArrayArray and Float64ArrayArrayArrayOutput values.
type Float64ArrayArrayArrayInput interface {
	Input

	ToFloat64ArrayArrayArrayOutput() Float64ArrayArrayArrayOutput
	ToFloat64ArrayArrayArrayOutputWithContext(ctx context.Context) Float64ArrayArrayArrayOutput
}

// Float64ArrayArrayArray is an input type for []Float64ArrayArrayInput values.
type Float64ArrayArrayArray []Float64ArrayArrayInput

// ElementType returns the element type of this Input ([][][]float64).
func (Float64ArrayArrayArray) ElementType() reflect.Type {
	return float64ArrayArrayArrayType
}

func (in Float64ArrayArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][][]float64] {
	return pulumix.Output[[][][]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64ArrayArrayArray) ToFloat64ArrayArrayArrayOutput() Float64ArrayArrayArrayOutput {
	return ToOutput(in).(Float64ArrayArrayArrayOutput)
}

func (in Float64ArrayArrayArray) ToFloat64ArrayArrayArrayOutputWithContext(ctx context.Context) Float64ArrayArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(Float64ArrayArrayArrayOutput)
}

// Float64ArrayArrayArrayOutput is an Output that returns [][][]float64 values.
type Float64ArrayArrayArrayOutput struct{ *OutputState }

func (Float64ArrayArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64ArrayArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][][]float64] {
	return pulumix.Output[[][][]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][][]float64).
func (Float64ArrayArrayArrayOutput) ElementType() reflect.Type {
	return float64ArrayArrayArrayType
}

func (o Float64ArrayArrayArrayOutput) ToFloat64ArrayArrayArrayOutput() Float64ArrayArrayArrayOutput {
	return o
}

func (o Float64ArrayArrayArrayOutput) ToFloat64ArrayArrayArrayOutputWithContext(ctx context.Context) Float64ArrayArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o Float64ArrayArrayArrayOutput) Index(i IntInput) Float64ArrayArrayOutput {
	return All(o, i).ApplyT(func(vs []any) [][]float64 {
		arr := vs[0].([][][]float64)
		idx := vs[1].(int)
		var ret [][]float64
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(Float64ArrayArrayOutput)
}

func ToFloat64ArrayArrayArray(in [][][]float64) Float64ArrayArrayArray {
	a := make(Float64ArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = ToFloat64ArrayArray(v)
	}
	return a
}

func ToFloat64ArrayArrayArrayOutput(in []Float64ArrayArrayOutput) Float64ArrayArrayArrayOutput {
	a := make(Float64ArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToFloat64ArrayArrayArrayOutput()
}

var float64MapMapMapType = reflect.TypeOf((*map[string]map[string]map[string]float64)(nil)).Elem()

// Float64MapMapMapInput is an input type that accepts Float64MapMapMap and Float64MapMapMapOutput values.
type Float64MapMapMapInput interface {
	Input

	ToFloat64MapMapMapOutput() Float64MapMapMapOutput
	ToFloat64MapMapMapOutputWithContext(ctx context.Context) Float64MapMapMapOutput
}

// Float64MapMapMap is an input type for map[string]Float64MapMapInput values.
type Float64MapMapMap map[string]Float64MapMapInput

// ElementType returns the element type of this Input (map[string]map[string]map[string]float64).
func (Float64MapMapMap) ElementType() reflect.Type {
	return float64MapMapMapType
}

func (in Float64MapMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]float64] {
	return pulumix.Output[map[string]map[string]map[string]float64]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Float64MapMapMap) ToFloat64MapMapMapOutput() Float64MapMapMapOutput {
	return ToOutput(in).(Float64MapMapMapOutput)
}

func (in Float64MapMapMap) ToFloat64MapMapMapOutputWithContext(ctx context.Context) Float64MapMapMapOutput {
	return ToOutputWithContext(ctx, in).(Float64MapMapMapOutput)
}

// Float64MapMapMapOutput is an Output that returns map[string]map[string]map[string]float64 values.
type Float64MapMapMapOutput struct{ *OutputState }

func (Float64MapMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o Float64MapMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]float64] {
	return pulumix.Output[map[string]map[string]map[string]float64]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]map[string]float64).
func (Float64MapMapMapOutput) ElementType() reflect.Type {
	return float64MapMapMapType
}

func (o Float64MapMapMapOutput) ToFloat64MapMapMapOutput() Float64MapMapMapOutput {
	return o
}

func (o Float64MapMapMapOutput) ToFloat64MapMapMapOutputWithContext(ctx context.Context) Float64MapMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o Float64MapMapMapOutput) MapIndex(k StringInput) Float64MapMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]map[string]float64 {
		return vs[0].(map[string]map[string]map[string]float64)[vs[1].(string)]
	}).(Float64MapMapOutput)
}

func ToFloat64MapMapMap(in map[string]map[string]map[string]float64) Float64MapMapMap {
	m := make(Float64MapMapMap)
	for k, v := range in {
		m[k] = ToFloat64MapMap(v)
	}
	return m
}

func ToFloat64MapMapMapOutput(in map[string]Float64MapMapOutput) Float64MapMapMapOutput {
	m := make(Float64MapMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToFloat64MapMapMapOutput()
}

var idType = reflect.TypeOf((*ID)(nil)).Elem()

// IDInput is an input type that accepts ID and IDOutput values.
type IDInput interface {
	Input

	ToIDOutput() IDOutput
	ToIDOutputWithContext(ctx context.Context) IDOutput

	ToIDPtrOutput() IDPtrOutput
	ToIDPtrOutputWithContext(ctx context.Context) IDPtrOutput
}

// ElementType returns the element type of this Input (ID).
func (ID) ElementType() reflect.Type {
	return idType
}

func (in ID) ToOutput(ctx context.Context) pulumix.Output[ID] {
	return pulumix.Output[ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ID) ToIDOutput() IDOutput {
	return ToOutput(in).(IDOutput)
}

func (in ID) ToIDOutputWithContext(ctx context.Context) IDOutput {
	return ToOutputWithContext(ctx, in).(IDOutput)
}

func (in ID) ToStringOutput() StringOutput {
	return in.ToStringOutputWithContext(context.Background())
}

func (in ID) ToStringOutputWithContext(ctx context.Context) StringOutput {
	return in.ToIDOutputWithContext(ctx).ToStringOutputWithContext(ctx)
}

func (in ID) ToIDPtrOutput() IDPtrOutput {
	return in.ToIDPtrOutputWithContext(context.Background())
}

func (in ID) ToIDPtrOutputWithContext(ctx context.Context) IDPtrOutput {
	return in.ToIDOutputWithContext(ctx).ToIDPtrOutputWithContext(ctx)
}

// IDOutput is an Output that returns ID values.
type IDOutput struct{ *OutputState }

func (IDOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDOutput) ToOutput(ctx context.Context) pulumix.Output[ID] {
	return pulumix.Output[ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (ID).
func (IDOutput) ElementType() reflect.Type {
	return idType
}

func (o IDOutput) ToIDOutput() IDOutput {
	return o
}

func (o IDOutput) ToIDOutputWithContext(ctx context.Context) IDOutput {
	return o
}

func (o IDOutput) ToStringOutput() StringOutput {
	return o.ToStringOutputWithContext(context.Background())
}

func (o IDOutput) ToStringOutputWithContext(ctx context.Context) StringOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ID) string {
		return (string)(v)
	}).(StringOutput)
}

func (o IDOutput) ToIDPtrOutput() IDPtrOutput {
	return o.ToIDPtrOutputWithContext(context.Background())
}

func (o IDOutput) ToIDPtrOutputWithContext(ctx context.Context) IDPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ID) *ID {
		return &v
	}).(IDPtrOutput)
}

var iDPtrType = reflect.TypeOf((**ID)(nil)).Elem()

// IDPtrInput is an input type that accepts IDPtr and IDPtrOutput values.
type IDPtrInput interface {
	Input

	ToIDPtrOutput() IDPtrOutput
	ToIDPtrOutputWithContext(ctx context.Context) IDPtrOutput
}

type idPtr ID

// IDPtr is an input type for *ID values.
func IDPtr(v ID) IDPtrInput {
	return (*idPtr)(&v)
}

func IDPtrFromPtr(v *ID) IDPtrInput {
	if v == nil {
		return nil
	}
	return (*idPtr)(v)
}

// ElementType returns the element type of this Input (*ID).
func (*idPtr) ElementType() reflect.Type {
	return iDPtrType
}

func (in *idPtr) ToOutput(ctx context.Context) pulumix.Output[*ID] {
	return pulumix.Output[*ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in *idPtr) ToIDPtrOutput() IDPtrOutput {
	return ToOutput(in).(IDPtrOutput)
}

func (in *idPtr) ToIDPtrOutputWithContext(ctx context.Context) IDPtrOutput {
	return ToOutputWithContext(ctx, in).(IDPtrOutput)
}

// IDPtrOutput is an Output that returns *ID values.
type IDPtrOutput struct{ *OutputState }

func (IDPtrOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*ID] {
	return pulumix.Output[*ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (*ID).
func (IDPtrOutput) ElementType() reflect.Type {
	return iDPtrType
}

func (o IDPtrOutput) ToIDPtrOutput() IDPtrOutput {
	return o
}

func (o IDPtrOutput) ToIDPtrOutputWithContext(ctx context.Context) IDPtrOutput {
	return o
}

// Elem dereferences the pointer value or returns the zero value of the approporiate type if the pointer is nil.
func (o IDPtrOutput) Elem() IDOutput {
	return o.ApplyT(func(v *ID) ID {
		var ret ID
		if v != nil {
			ret = *v
		}
		return ret
	}).(IDOutput)
}

var iDArrayType = reflect.TypeOf((*[]ID)(nil)).Elem()

// IDArrayInput is an input type that accepts IDArray and IDArrayOutput values.
type IDArrayInput interface {
	Input

	ToIDArrayOutput() IDArrayOutput
	ToIDArrayOutputWithContext(ctx context.Context) IDArrayOutput
}

// IDArray is an input type for []IDInput values.
type IDArray []IDInput

// ElementType returns the element type of this Input ([]ID).
func (IDArray) ElementType() reflect.Type {
	return iDArrayType
}

func (in IDArray) ToOutput(ctx context.Context) pulumix.Output[[]ID] {
	return pulumix.Output[[]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDArray) ToIDArrayOutput() IDArrayOutput {
	return ToOutput(in).(IDArrayOutput)
}

func (in IDArray) ToIDArrayOutputWithContext(ctx context.Context) IDArrayOutput {
	return ToOutputWithContext(ctx, in).(IDArrayOutput)
}

// IDArrayOutput is an Output that returns []ID values.
type IDArrayOutput struct{ *OutputState }

func (IDArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]ID] {
	return pulumix.Output[[]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]ID).
func (IDArrayOutput) ElementType() reflect.Type {
	return iDArrayType
}

func (o IDArrayOutput) ToIDArrayOutput() IDArrayOutput {
	return o
}

func (o IDArrayOutput) ToIDArrayOutputWithContext(ctx context.Context) IDArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IDArrayOutput) Index(i IntInput) IDOutput {
	return All(o, i).ApplyT(func(vs []any) ID {
		arr := vs[0].([]ID)
		idx := vs[1].(int)
		var ret ID
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IDOutput)
}

func ToIDArray(in []ID) IDArray {
	a := make(IDArray, len(in))
	for i, v := range in {
		a[i] = (v)
	}
	return a
}

func ToIDArrayOutput(in []IDOutput) IDArrayOutput {
	a := make(IDArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIDArrayOutput()
}

var iDMapType = reflect.TypeOf((*map[string]ID)(nil)).Elem()

// IDMapInput is an input type that accepts IDMap and IDMapOutput values.
type IDMapInput interface {
	Input

	ToIDMapOutput() IDMapOutput
	ToIDMapOutputWithContext(ctx context.Context) IDMapOutput
}

// IDMap is an input type for map[string]IDInput values.
type IDMap map[string]IDInput

// ElementType returns the element type of this Input (map[string]ID).
func (IDMap) ElementType() reflect.Type {
	return iDMapType
}

func (in IDMap) ToOutput(ctx context.Context) pulumix.Output[map[string]ID] {
	return pulumix.Output[map[string]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDMap) ToIDMapOutput() IDMapOutput {
	return ToOutput(in).(IDMapOutput)
}

func (in IDMap) ToIDMapOutputWithContext(ctx context.Context) IDMapOutput {
	return ToOutputWithContext(ctx, in).(IDMapOutput)
}

// IDMapOutput is an Output that returns map[string]ID values.
type IDMapOutput struct{ *OutputState }

func (IDMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]ID] {
	return pulumix.Output[map[string]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]ID).
func (IDMapOutput) ElementType() reflect.Type {
	return iDMapType
}

func (o IDMapOutput) ToIDMapOutput() IDMapOutput {
	return o
}

func (o IDMapOutput) ToIDMapOutputWithContext(ctx context.Context) IDMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IDMapOutput) MapIndex(k StringInput) IDOutput {
	return All(o, k).ApplyT(func(vs []any) ID {
		return vs[0].(map[string]ID)[vs[1].(string)]
	}).(IDOutput)
}

func ToIDMap(in map[string]ID) IDMap {
	m := make(IDMap)
	for k, v := range in {
		m[k] = (v)
	}
	return m
}

func ToIDMapOutput(in map[string]IDOutput) IDMapOutput {
	m := make(IDMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIDMapOutput()
}

var iDArrayMapType = reflect.TypeOf((*map[string][]ID)(nil)).Elem()

// IDArrayMapInput is an input type that accepts IDArrayMap and IDArrayMapOutput values.
type IDArrayMapInput interface {
	Input

	ToIDArrayMapOutput() IDArrayMapOutput
	ToIDArrayMapOutputWithContext(ctx context.Context) IDArrayMapOutput
}

// IDArrayMap is an input type for map[string]IDArrayInput values.
type IDArrayMap map[string]IDArrayInput

// ElementType returns the element type of this Input (map[string][]ID).
func (IDArrayMap) ElementType() reflect.Type {
	return iDArrayMapType
}

func (in IDArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]ID] {
	return pulumix.Output[map[string][]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDArrayMap) ToIDArrayMapOutput() IDArrayMapOutput {
	return ToOutput(in).(IDArrayMapOutput)
}

func (in IDArrayMap) ToIDArrayMapOutputWithContext(ctx context.Context) IDArrayMapOutput {
	return ToOutputWithContext(ctx, in).(IDArrayMapOutput)
}

// IDArrayMapOutput is an Output that returns map[string][]ID values.
type IDArrayMapOutput struct{ *OutputState }

func (IDArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]ID] {
	return pulumix.Output[map[string][]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]ID).
func (IDArrayMapOutput) ElementType() reflect.Type {
	return iDArrayMapType
}

func (o IDArrayMapOutput) ToIDArrayMapOutput() IDArrayMapOutput {
	return o
}

func (o IDArrayMapOutput) ToIDArrayMapOutputWithContext(ctx context.Context) IDArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IDArrayMapOutput) MapIndex(k StringInput) IDArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []ID {
		return vs[0].(map[string][]ID)[vs[1].(string)]
	}).(IDArrayOutput)
}

func ToIDArrayMap(in map[string][]ID) IDArrayMap {
	m := make(IDArrayMap)
	for k, v := range in {
		m[k] = ToIDArray(v)
	}
	return m
}

func ToIDArrayMapOutput(in map[string]IDArrayOutput) IDArrayMapOutput {
	m := make(IDArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIDArrayMapOutput()
}

var iDMapArrayType = reflect.TypeOf((*[]map[string]ID)(nil)).Elem()

// IDMapArrayInput is an input type that accepts IDMapArray and IDMapArrayOutput values.
type IDMapArrayInput interface {
	Input

	ToIDMapArrayOutput() IDMapArrayOutput
	ToIDMapArrayOutputWithContext(ctx context.Context) IDMapArrayOutput
}

// IDMapArray is an input type for []IDMapInput values.
type IDMapArray []IDMapInput

// ElementType returns the element type of this Input ([]map[string]ID).
func (IDMapArray) ElementType() reflect.Type {
	return iDMapArrayType
}

func (in IDMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]ID] {
	return pulumix.Output[[]map[string]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDMapArray) ToIDMapArrayOutput() IDMapArrayOutput {
	return ToOutput(in).(IDMapArrayOutput)
}

func (in IDMapArray) ToIDMapArrayOutputWithContext(ctx context.Context) IDMapArrayOutput {
	return ToOutputWithContext(ctx, in).(IDMapArrayOutput)
}

// IDMapArrayOutput is an Output that returns []map[string]ID values.
type IDMapArrayOutput struct{ *OutputState }

func (IDMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]ID] {
	return pulumix.Output[[]map[string]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]ID).
func (IDMapArrayOutput) ElementType() reflect.Type {
	return iDMapArrayType
}

func (o IDMapArrayOutput) ToIDMapArrayOutput() IDMapArrayOutput {
	return o
}

func (o IDMapArrayOutput) ToIDMapArrayOutputWithContext(ctx context.Context) IDMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IDMapArrayOutput) Index(i IntInput) IDMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]ID {
		arr := vs[0].([]map[string]ID)
		idx := vs[1].(int)
		var ret map[string]ID
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IDMapOutput)
}

func ToIDMapArray(in []map[string]ID) IDMapArray {
	a := make(IDMapArray, len(in))
	for i, v := range in {
		a[i] = ToIDMap(v)
	}
	return a
}

func ToIDMapArrayOutput(in []IDMapOutput) IDMapArrayOutput {
	a := make(IDMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIDMapArrayOutput()
}

var iDMapMapType = reflect.TypeOf((*map[string]map[string]ID)(nil)).Elem()

// IDMapMapInput is an input type that accepts IDMapMap and IDMapMapOutput values.
type IDMapMapInput interface {
	Input

	ToIDMapMapOutput() IDMapMapOutput
	ToIDMapMapOutputWithContext(ctx context.Context) IDMapMapOutput
}

// IDMapMap is an input type for map[string]IDMapInput values.
type IDMapMap map[string]IDMapInput

// ElementType returns the element type of this Input (map[string]map[string]ID).
func (IDMapMap) ElementType() reflect.Type {
	return iDMapMapType
}

func (in IDMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]ID] {
	return pulumix.Output[map[string]map[string]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDMapMap) ToIDMapMapOutput() IDMapMapOutput {
	return ToOutput(in).(IDMapMapOutput)
}

func (in IDMapMap) ToIDMapMapOutputWithContext(ctx context.Context) IDMapMapOutput {
	return ToOutputWithContext(ctx, in).(IDMapMapOutput)
}

// IDMapMapOutput is an Output that returns map[string]map[string]ID values.
type IDMapMapOutput struct{ *OutputState }

func (IDMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]ID] {
	return pulumix.Output[map[string]map[string]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]ID).
func (IDMapMapOutput) ElementType() reflect.Type {
	return iDMapMapType
}

func (o IDMapMapOutput) ToIDMapMapOutput() IDMapMapOutput {
	return o
}

func (o IDMapMapOutput) ToIDMapMapOutputWithContext(ctx context.Context) IDMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IDMapMapOutput) MapIndex(k StringInput) IDMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]ID {
		return vs[0].(map[string]map[string]ID)[vs[1].(string)]
	}).(IDMapOutput)
}

func ToIDMapMap(in map[string]map[string]ID) IDMapMap {
	m := make(IDMapMap)
	for k, v := range in {
		m[k] = ToIDMap(v)
	}
	return m
}

func ToIDMapMapOutput(in map[string]IDMapOutput) IDMapMapOutput {
	m := make(IDMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIDMapMapOutput()
}

var iDArrayArrayType = reflect.TypeOf((*[][]ID)(nil)).Elem()

// IDArrayArrayInput is an input type that accepts IDArrayArray and IDArrayArrayOutput values.
type IDArrayArrayInput interface {
	Input

	ToIDArrayArrayOutput() IDArrayArrayOutput
	ToIDArrayArrayOutputWithContext(ctx context.Context) IDArrayArrayOutput
}

// IDArrayArray is an input type for []IDArrayInput values.
type IDArrayArray []IDArrayInput

// ElementType returns the element type of this Input ([][]ID).
func (IDArrayArray) ElementType() reflect.Type {
	return iDArrayArrayType
}

func (in IDArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][]ID] {
	return pulumix.Output[[][]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDArrayArray) ToIDArrayArrayOutput() IDArrayArrayOutput {
	return ToOutput(in).(IDArrayArrayOutput)
}

func (in IDArrayArray) ToIDArrayArrayOutputWithContext(ctx context.Context) IDArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(IDArrayArrayOutput)
}

// IDArrayArrayOutput is an Output that returns [][]ID values.
type IDArrayArrayOutput struct{ *OutputState }

func (IDArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][]ID] {
	return pulumix.Output[[][]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][]ID).
func (IDArrayArrayOutput) ElementType() reflect.Type {
	return iDArrayArrayType
}

func (o IDArrayArrayOutput) ToIDArrayArrayOutput() IDArrayArrayOutput {
	return o
}

func (o IDArrayArrayOutput) ToIDArrayArrayOutputWithContext(ctx context.Context) IDArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IDArrayArrayOutput) Index(i IntInput) IDArrayOutput {
	return All(o, i).ApplyT(func(vs []any) []ID {
		arr := vs[0].([][]ID)
		idx := vs[1].(int)
		var ret []ID
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IDArrayOutput)
}

func ToIDArrayArray(in [][]ID) IDArrayArray {
	a := make(IDArrayArray, len(in))
	for i, v := range in {
		a[i] = ToIDArray(v)
	}
	return a
}

func ToIDArrayArrayOutput(in []IDArrayOutput) IDArrayArrayOutput {
	a := make(IDArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIDArrayArrayOutput()
}

var iDArrayMapMapType = reflect.TypeOf((*map[string]map[string][]ID)(nil)).Elem()

// IDArrayMapMapInput is an input type that accepts IDArrayMapMap and IDArrayMapMapOutput values.
type IDArrayMapMapInput interface {
	Input

	ToIDArrayMapMapOutput() IDArrayMapMapOutput
	ToIDArrayMapMapOutputWithContext(ctx context.Context) IDArrayMapMapOutput
}

// IDArrayMapMap is an input type for map[string]IDArrayMapInput values.
type IDArrayMapMap map[string]IDArrayMapInput

// ElementType returns the element type of this Input (map[string]map[string][]ID).
func (IDArrayMapMap) ElementType() reflect.Type {
	return iDArrayMapMapType
}

func (in IDArrayMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]ID] {
	return pulumix.Output[map[string]map[string][]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDArrayMapMap) ToIDArrayMapMapOutput() IDArrayMapMapOutput {
	return ToOutput(in).(IDArrayMapMapOutput)
}

func (in IDArrayMapMap) ToIDArrayMapMapOutputWithContext(ctx context.Context) IDArrayMapMapOutput {
	return ToOutputWithContext(ctx, in).(IDArrayMapMapOutput)
}

// IDArrayMapMapOutput is an Output that returns map[string]map[string][]ID values.
type IDArrayMapMapOutput struct{ *OutputState }

func (IDArrayMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDArrayMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]ID] {
	return pulumix.Output[map[string]map[string][]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string][]ID).
func (IDArrayMapMapOutput) ElementType() reflect.Type {
	return iDArrayMapMapType
}

func (o IDArrayMapMapOutput) ToIDArrayMapMapOutput() IDArrayMapMapOutput {
	return o
}

func (o IDArrayMapMapOutput) ToIDArrayMapMapOutputWithContext(ctx context.Context) IDArrayMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IDArrayMapMapOutput) MapIndex(k StringInput) IDArrayMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string][]ID {
		return vs[0].(map[string]map[string][]ID)[vs[1].(string)]
	}).(IDArrayMapOutput)
}

func ToIDArrayMapMap(in map[string]map[string][]ID) IDArrayMapMap {
	m := make(IDArrayMapMap)
	for k, v := range in {
		m[k] = ToIDArrayMap(v)
	}
	return m
}

func ToIDArrayMapMapOutput(in map[string]IDArrayMapOutput) IDArrayMapMapOutput {
	m := make(IDArrayMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIDArrayMapMapOutput()
}

var iDMapArrayMapType = reflect.TypeOf((*map[string][]map[string]ID)(nil)).Elem()

// IDMapArrayMapInput is an input type that accepts IDMapArrayMap and IDMapArrayMapOutput values.
type IDMapArrayMapInput interface {
	Input

	ToIDMapArrayMapOutput() IDMapArrayMapOutput
	ToIDMapArrayMapOutputWithContext(ctx context.Context) IDMapArrayMapOutput
}

// IDMapArrayMap is an input type for map[string]IDMapArrayInput values.
type IDMapArrayMap map[string]IDMapArrayInput

// ElementType returns the element type of this Input (map[string][]map[string]ID).
func (IDMapArrayMap) ElementType() reflect.Type {
	return iDMapArrayMapType
}

func (in IDMapArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]ID] {
	return pulumix.Output[map[string][]map[string]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDMapArrayMap) ToIDMapArrayMapOutput() IDMapArrayMapOutput {
	return ToOutput(in).(IDMapArrayMapOutput)
}

func (in IDMapArrayMap) ToIDMapArrayMapOutputWithContext(ctx context.Context) IDMapArrayMapOutput {
	return ToOutputWithContext(ctx, in).(IDMapArrayMapOutput)
}

// IDMapArrayMapOutput is an Output that returns map[string][]map[string]ID values.
type IDMapArrayMapOutput struct{ *OutputState }

func (IDMapArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDMapArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]ID] {
	return pulumix.Output[map[string][]map[string]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]map[string]ID).
func (IDMapArrayMapOutput) ElementType() reflect.Type {
	return iDMapArrayMapType
}

func (o IDMapArrayMapOutput) ToIDMapArrayMapOutput() IDMapArrayMapOutput {
	return o
}

func (o IDMapArrayMapOutput) ToIDMapArrayMapOutputWithContext(ctx context.Context) IDMapArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IDMapArrayMapOutput) MapIndex(k StringInput) IDMapArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []map[string]ID {
		return vs[0].(map[string][]map[string]ID)[vs[1].(string)]
	}).(IDMapArrayOutput)
}

func ToIDMapArrayMap(in map[string][]map[string]ID) IDMapArrayMap {
	m := make(IDMapArrayMap)
	for k, v := range in {
		m[k] = ToIDMapArray(v)
	}
	return m
}

func ToIDMapArrayMapOutput(in map[string]IDMapArrayOutput) IDMapArrayMapOutput {
	m := make(IDMapArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIDMapArrayMapOutput()
}

var iDMapMapArrayType = reflect.TypeOf((*[]map[string]map[string]ID)(nil)).Elem()

// IDMapMapArrayInput is an input type that accepts IDMapMapArray and IDMapMapArrayOutput values.
type IDMapMapArrayInput interface {
	Input

	ToIDMapMapArrayOutput() IDMapMapArrayOutput
	ToIDMapMapArrayOutputWithContext(ctx context.Context) IDMapMapArrayOutput
}

// IDMapMapArray is an input type for []IDMapMapInput values.
type IDMapMapArray []IDMapMapInput

// ElementType returns the element type of this Input ([]map[string]map[string]ID).
func (IDMapMapArray) ElementType() reflect.Type {
	return iDMapMapArrayType
}

func (in IDMapMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]ID] {
	return pulumix.Output[[]map[string]map[string]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDMapMapArray) ToIDMapMapArrayOutput() IDMapMapArrayOutput {
	return ToOutput(in).(IDMapMapArrayOutput)
}

func (in IDMapMapArray) ToIDMapMapArrayOutputWithContext(ctx context.Context) IDMapMapArrayOutput {
	return ToOutputWithContext(ctx, in).(IDMapMapArrayOutput)
}

// IDMapMapArrayOutput is an Output that returns []map[string]map[string]ID values.
type IDMapMapArrayOutput struct{ *OutputState }

func (IDMapMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDMapMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]ID] {
	return pulumix.Output[[]map[string]map[string]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]map[string]ID).
func (IDMapMapArrayOutput) ElementType() reflect.Type {
	return iDMapMapArrayType
}

func (o IDMapMapArrayOutput) ToIDMapMapArrayOutput() IDMapMapArrayOutput {
	return o
}

func (o IDMapMapArrayOutput) ToIDMapMapArrayOutputWithContext(ctx context.Context) IDMapMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IDMapMapArrayOutput) Index(i IntInput) IDMapMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]map[string]ID {
		arr := vs[0].([]map[string]map[string]ID)
		idx := vs[1].(int)
		var ret map[string]map[string]ID
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IDMapMapOutput)
}

func ToIDMapMapArray(in []map[string]map[string]ID) IDMapMapArray {
	a := make(IDMapMapArray, len(in))
	for i, v := range in {
		a[i] = ToIDMapMap(v)
	}
	return a
}

func ToIDMapMapArrayOutput(in []IDMapMapOutput) IDMapMapArrayOutput {
	a := make(IDMapMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIDMapMapArrayOutput()
}

var iDArrayMapArrayType = reflect.TypeOf((*[]map[string][]ID)(nil)).Elem()

// IDArrayMapArrayInput is an input type that accepts IDArrayMapArray and IDArrayMapArrayOutput values.
type IDArrayMapArrayInput interface {
	Input

	ToIDArrayMapArrayOutput() IDArrayMapArrayOutput
	ToIDArrayMapArrayOutputWithContext(ctx context.Context) IDArrayMapArrayOutput
}

// IDArrayMapArray is an input type for []IDArrayMapInput values.
type IDArrayMapArray []IDArrayMapInput

// ElementType returns the element type of this Input ([]map[string][]ID).
func (IDArrayMapArray) ElementType() reflect.Type {
	return iDArrayMapArrayType
}

func (in IDArrayMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]ID] {
	return pulumix.Output[[]map[string][]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDArrayMapArray) ToIDArrayMapArrayOutput() IDArrayMapArrayOutput {
	return ToOutput(in).(IDArrayMapArrayOutput)
}

func (in IDArrayMapArray) ToIDArrayMapArrayOutputWithContext(ctx context.Context) IDArrayMapArrayOutput {
	return ToOutputWithContext(ctx, in).(IDArrayMapArrayOutput)
}

// IDArrayMapArrayOutput is an Output that returns []map[string][]ID values.
type IDArrayMapArrayOutput struct{ *OutputState }

func (IDArrayMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDArrayMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]ID] {
	return pulumix.Output[[]map[string][]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string][]ID).
func (IDArrayMapArrayOutput) ElementType() reflect.Type {
	return iDArrayMapArrayType
}

func (o IDArrayMapArrayOutput) ToIDArrayMapArrayOutput() IDArrayMapArrayOutput {
	return o
}

func (o IDArrayMapArrayOutput) ToIDArrayMapArrayOutputWithContext(ctx context.Context) IDArrayMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IDArrayMapArrayOutput) Index(i IntInput) IDArrayMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string][]ID {
		arr := vs[0].([]map[string][]ID)
		idx := vs[1].(int)
		var ret map[string][]ID
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IDArrayMapOutput)
}

func ToIDArrayMapArray(in []map[string][]ID) IDArrayMapArray {
	a := make(IDArrayMapArray, len(in))
	for i, v := range in {
		a[i] = ToIDArrayMap(v)
	}
	return a
}

func ToIDArrayMapArrayOutput(in []IDArrayMapOutput) IDArrayMapArrayOutput {
	a := make(IDArrayMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIDArrayMapArrayOutput()
}

var iDArrayArrayMapType = reflect.TypeOf((*map[string][][]ID)(nil)).Elem()

// IDArrayArrayMapInput is an input type that accepts IDArrayArrayMap and IDArrayArrayMapOutput values.
type IDArrayArrayMapInput interface {
	Input

	ToIDArrayArrayMapOutput() IDArrayArrayMapOutput
	ToIDArrayArrayMapOutputWithContext(ctx context.Context) IDArrayArrayMapOutput
}

// IDArrayArrayMap is an input type for map[string]IDArrayArrayInput values.
type IDArrayArrayMap map[string]IDArrayArrayInput

// ElementType returns the element type of this Input (map[string][][]ID).
func (IDArrayArrayMap) ElementType() reflect.Type {
	return iDArrayArrayMapType
}

func (in IDArrayArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][][]ID] {
	return pulumix.Output[map[string][][]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDArrayArrayMap) ToIDArrayArrayMapOutput() IDArrayArrayMapOutput {
	return ToOutput(in).(IDArrayArrayMapOutput)
}

func (in IDArrayArrayMap) ToIDArrayArrayMapOutputWithContext(ctx context.Context) IDArrayArrayMapOutput {
	return ToOutputWithContext(ctx, in).(IDArrayArrayMapOutput)
}

// IDArrayArrayMapOutput is an Output that returns map[string][][]ID values.
type IDArrayArrayMapOutput struct{ *OutputState }

func (IDArrayArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDArrayArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][][]ID] {
	return pulumix.Output[map[string][][]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][][]ID).
func (IDArrayArrayMapOutput) ElementType() reflect.Type {
	return iDArrayArrayMapType
}

func (o IDArrayArrayMapOutput) ToIDArrayArrayMapOutput() IDArrayArrayMapOutput {
	return o
}

func (o IDArrayArrayMapOutput) ToIDArrayArrayMapOutputWithContext(ctx context.Context) IDArrayArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IDArrayArrayMapOutput) MapIndex(k StringInput) IDArrayArrayOutput {
	return All(o, k).ApplyT(func(vs []any) [][]ID {
		return vs[0].(map[string][][]ID)[vs[1].(string)]
	}).(IDArrayArrayOutput)
}

func ToIDArrayArrayMap(in map[string][][]ID) IDArrayArrayMap {
	m := make(IDArrayArrayMap)
	for k, v := range in {
		m[k] = ToIDArrayArray(v)
	}
	return m
}

func ToIDArrayArrayMapOutput(in map[string]IDArrayArrayOutput) IDArrayArrayMapOutput {
	m := make(IDArrayArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIDArrayArrayMapOutput()
}

var iDArrayArrayArrayType = reflect.TypeOf((*[][][]ID)(nil)).Elem()

// IDArrayArrayArrayInput is an input type that accepts IDArrayArrayArray and IDArrayArrayArrayOutput values.
type IDArrayArrayArrayInput interface {
	Input

	ToIDArrayArrayArrayOutput() IDArrayArrayArrayOutput
	ToIDArrayArrayArrayOutputWithContext(ctx context.Context) IDArrayArrayArrayOutput
}

// IDArrayArrayArray is an input type for []IDArrayArrayInput values.
type IDArrayArrayArray []IDArrayArrayInput

// ElementType returns the element type of this Input ([][][]ID).
func (IDArrayArrayArray) ElementType() reflect.Type {
	return iDArrayArrayArrayType
}

func (in IDArrayArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][][]ID] {
	return pulumix.Output[[][][]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDArrayArrayArray) ToIDArrayArrayArrayOutput() IDArrayArrayArrayOutput {
	return ToOutput(in).(IDArrayArrayArrayOutput)
}

func (in IDArrayArrayArray) ToIDArrayArrayArrayOutputWithContext(ctx context.Context) IDArrayArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(IDArrayArrayArrayOutput)
}

// IDArrayArrayArrayOutput is an Output that returns [][][]ID values.
type IDArrayArrayArrayOutput struct{ *OutputState }

func (IDArrayArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDArrayArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][][]ID] {
	return pulumix.Output[[][][]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][][]ID).
func (IDArrayArrayArrayOutput) ElementType() reflect.Type {
	return iDArrayArrayArrayType
}

func (o IDArrayArrayArrayOutput) ToIDArrayArrayArrayOutput() IDArrayArrayArrayOutput {
	return o
}

func (o IDArrayArrayArrayOutput) ToIDArrayArrayArrayOutputWithContext(ctx context.Context) IDArrayArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IDArrayArrayArrayOutput) Index(i IntInput) IDArrayArrayOutput {
	return All(o, i).ApplyT(func(vs []any) [][]ID {
		arr := vs[0].([][][]ID)
		idx := vs[1].(int)
		var ret [][]ID
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IDArrayArrayOutput)
}

func ToIDArrayArrayArray(in [][][]ID) IDArrayArrayArray {
	a := make(IDArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = ToIDArrayArray(v)
	}
	return a
}

func ToIDArrayArrayArrayOutput(in []IDArrayArrayOutput) IDArrayArrayArrayOutput {
	a := make(IDArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIDArrayArrayArrayOutput()
}

var iDMapMapMapType = reflect.TypeOf((*map[string]map[string]map[string]ID)(nil)).Elem()

// IDMapMapMapInput is an input type that accepts IDMapMapMap and IDMapMapMapOutput values.
type IDMapMapMapInput interface {
	Input

	ToIDMapMapMapOutput() IDMapMapMapOutput
	ToIDMapMapMapOutputWithContext(ctx context.Context) IDMapMapMapOutput
}

// IDMapMapMap is an input type for map[string]IDMapMapInput values.
type IDMapMapMap map[string]IDMapMapInput

// ElementType returns the element type of this Input (map[string]map[string]map[string]ID).
func (IDMapMapMap) ElementType() reflect.Type {
	return iDMapMapMapType
}

func (in IDMapMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]ID] {
	return pulumix.Output[map[string]map[string]map[string]ID]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IDMapMapMap) ToIDMapMapMapOutput() IDMapMapMapOutput {
	return ToOutput(in).(IDMapMapMapOutput)
}

func (in IDMapMapMap) ToIDMapMapMapOutputWithContext(ctx context.Context) IDMapMapMapOutput {
	return ToOutputWithContext(ctx, in).(IDMapMapMapOutput)
}

// IDMapMapMapOutput is an Output that returns map[string]map[string]map[string]ID values.
type IDMapMapMapOutput struct{ *OutputState }

func (IDMapMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IDMapMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]ID] {
	return pulumix.Output[map[string]map[string]map[string]ID]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]map[string]ID).
func (IDMapMapMapOutput) ElementType() reflect.Type {
	return iDMapMapMapType
}

func (o IDMapMapMapOutput) ToIDMapMapMapOutput() IDMapMapMapOutput {
	return o
}

func (o IDMapMapMapOutput) ToIDMapMapMapOutputWithContext(ctx context.Context) IDMapMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IDMapMapMapOutput) MapIndex(k StringInput) IDMapMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]map[string]ID {
		return vs[0].(map[string]map[string]map[string]ID)[vs[1].(string)]
	}).(IDMapMapOutput)
}

func ToIDMapMapMap(in map[string]map[string]map[string]ID) IDMapMapMap {
	m := make(IDMapMapMap)
	for k, v := range in {
		m[k] = ToIDMapMap(v)
	}
	return m
}

func ToIDMapMapMapOutput(in map[string]IDMapMapOutput) IDMapMapMapOutput {
	m := make(IDMapMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIDMapMapMapOutput()
}

var arrayType = reflect.TypeOf((*[]any)(nil)).Elem()

// ArrayInput is an input type that accepts Array and ArrayOutput values.
type ArrayInput interface {
	Input

	ToArrayOutput() ArrayOutput
	ToArrayOutputWithContext(ctx context.Context) ArrayOutput
}

// Array is an input type for []Input values.
type Array []Input

// ElementType returns the element type of this Input ([]any).
func (Array) ElementType() reflect.Type {
	return arrayType
}

func (in Array) ToOutput(ctx context.Context) pulumix.Output[[]any] {
	return pulumix.Output[[]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Array) ToArrayOutput() ArrayOutput {
	return ToOutput(in).(ArrayOutput)
}

func (in Array) ToArrayOutputWithContext(ctx context.Context) ArrayOutput {
	return ToOutputWithContext(ctx, in).(ArrayOutput)
}

// ArrayOutput is an Output that returns []any values.
type ArrayOutput struct{ *OutputState }

func (ArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]any] {
	return pulumix.Output[[]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]any).
func (ArrayOutput) ElementType() reflect.Type {
	return arrayType
}

func (o ArrayOutput) ToArrayOutput() ArrayOutput {
	return o
}

func (o ArrayOutput) ToArrayOutputWithContext(ctx context.Context) ArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o ArrayOutput) Index(i IntInput) Output {
	return All(o, i).ApplyT(func(vs []any) any {
		arr := vs[0].([]any)
		idx := vs[1].(int)
		var ret any
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(Output)
}

func ToArray(in []any) Array {
	a := make(Array, len(in))
	for i, v := range in {
		a[i] = ToOutput(v)
	}
	return a
}

func ToArrayOutput(in []Output) ArrayOutput {
	a := make(Array, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToArrayOutput()
}

var mapType = reflect.TypeOf((*map[string]any)(nil)).Elem()

// MapInput is an input type that accepts Map and MapOutput values.
type MapInput interface {
	Input

	ToMapOutput() MapOutput
	ToMapOutputWithContext(ctx context.Context) MapOutput
}

// Map is an input type for map[string]Input values.
type Map map[string]Input

// ElementType returns the element type of this Input (map[string]any).
func (Map) ElementType() reflect.Type {
	return mapType
}

func (in Map) ToOutput(ctx context.Context) pulumix.Output[map[string]any] {
	return pulumix.Output[map[string]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Map) ToMapOutput() MapOutput {
	return ToOutput(in).(MapOutput)
}

func (in Map) ToMapOutputWithContext(ctx context.Context) MapOutput {
	return ToOutputWithContext(ctx, in).(MapOutput)
}

// MapOutput is an Output that returns map[string]any values.
type MapOutput struct{ *OutputState }

func (MapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o MapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]any] {
	return pulumix.Output[map[string]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]any).
func (MapOutput) ElementType() reflect.Type {
	return mapType
}

func (o MapOutput) ToMapOutput() MapOutput {
	return o
}

func (o MapOutput) ToMapOutputWithContext(ctx context.Context) MapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o MapOutput) MapIndex(k StringInput) Output {
	return All(o, k).ApplyT(func(vs []any) any {
		return vs[0].(map[string]any)[vs[1].(string)]
	}).(Output)
}

func ToMap(in map[string]any) Map {
	m := make(Map)
	for k, v := range in {
		m[k] = ToOutput(v)
	}
	return m
}

func ToMapOutput(in map[string]Output) MapOutput {
	m := make(Map)
	for k, v := range in {
		m[k] = v
	}
	return m.ToMapOutput()
}

var arrayMapType = reflect.TypeOf((*map[string][]any)(nil)).Elem()

// ArrayMapInput is an input type that accepts ArrayMap and ArrayMapOutput values.
type ArrayMapInput interface {
	Input

	ToArrayMapOutput() ArrayMapOutput
	ToArrayMapOutputWithContext(ctx context.Context) ArrayMapOutput
}

// ArrayMap is an input type for map[string]ArrayInput values.
type ArrayMap map[string]ArrayInput

// ElementType returns the element type of this Input (map[string][]any).
func (ArrayMap) ElementType() reflect.Type {
	return arrayMapType
}

func (in ArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]any] {
	return pulumix.Output[map[string][]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArrayMap) ToArrayMapOutput() ArrayMapOutput {
	return ToOutput(in).(ArrayMapOutput)
}

func (in ArrayMap) ToArrayMapOutputWithContext(ctx context.Context) ArrayMapOutput {
	return ToOutputWithContext(ctx, in).(ArrayMapOutput)
}

// ArrayMapOutput is an Output that returns map[string][]any values.
type ArrayMapOutput struct{ *OutputState }

func (ArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]any] {
	return pulumix.Output[map[string][]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]any).
func (ArrayMapOutput) ElementType() reflect.Type {
	return arrayMapType
}

func (o ArrayMapOutput) ToArrayMapOutput() ArrayMapOutput {
	return o
}

func (o ArrayMapOutput) ToArrayMapOutputWithContext(ctx context.Context) ArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o ArrayMapOutput) MapIndex(k StringInput) ArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []any {
		return vs[0].(map[string][]any)[vs[1].(string)]
	}).(ArrayOutput)
}

func ToArrayMap(in map[string][]any) ArrayMap {
	m := make(ArrayMap)
	for k, v := range in {
		m[k] = ToArray(v)
	}
	return m
}

func ToArrayMapOutput(in map[string]ArrayOutput) ArrayMapOutput {
	m := make(ArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToArrayMapOutput()
}

var mapArrayType = reflect.TypeOf((*[]map[string]any)(nil)).Elem()

// MapArrayInput is an input type that accepts MapArray and MapArrayOutput values.
type MapArrayInput interface {
	Input

	ToMapArrayOutput() MapArrayOutput
	ToMapArrayOutputWithContext(ctx context.Context) MapArrayOutput
}

// MapArray is an input type for []MapInput values.
type MapArray []MapInput

// ElementType returns the element type of this Input ([]map[string]any).
func (MapArray) ElementType() reflect.Type {
	return mapArrayType
}

func (in MapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]any] {
	return pulumix.Output[[]map[string]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in MapArray) ToMapArrayOutput() MapArrayOutput {
	return ToOutput(in).(MapArrayOutput)
}

func (in MapArray) ToMapArrayOutputWithContext(ctx context.Context) MapArrayOutput {
	return ToOutputWithContext(ctx, in).(MapArrayOutput)
}

// MapArrayOutput is an Output that returns []map[string]any values.
type MapArrayOutput struct{ *OutputState }

func (MapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o MapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]any] {
	return pulumix.Output[[]map[string]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]any).
func (MapArrayOutput) ElementType() reflect.Type {
	return mapArrayType
}

func (o MapArrayOutput) ToMapArrayOutput() MapArrayOutput {
	return o
}

func (o MapArrayOutput) ToMapArrayOutputWithContext(ctx context.Context) MapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o MapArrayOutput) Index(i IntInput) MapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]any {
		arr := vs[0].([]map[string]any)
		idx := vs[1].(int)
		var ret map[string]any
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(MapOutput)
}

func ToMapArray(in []map[string]any) MapArray {
	a := make(MapArray, len(in))
	for i, v := range in {
		a[i] = ToMap(v)
	}
	return a
}

func ToMapArrayOutput(in []MapOutput) MapArrayOutput {
	a := make(MapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToMapArrayOutput()
}

var mapMapType = reflect.TypeOf((*map[string]map[string]any)(nil)).Elem()

// MapMapInput is an input type that accepts MapMap and MapMapOutput values.
type MapMapInput interface {
	Input

	ToMapMapOutput() MapMapOutput
	ToMapMapOutputWithContext(ctx context.Context) MapMapOutput
}

// MapMap is an input type for map[string]MapInput values.
type MapMap map[string]MapInput

// ElementType returns the element type of this Input (map[string]map[string]any).
func (MapMap) ElementType() reflect.Type {
	return mapMapType
}

func (in MapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]any] {
	return pulumix.Output[map[string]map[string]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in MapMap) ToMapMapOutput() MapMapOutput {
	return ToOutput(in).(MapMapOutput)
}

func (in MapMap) ToMapMapOutputWithContext(ctx context.Context) MapMapOutput {
	return ToOutputWithContext(ctx, in).(MapMapOutput)
}

// MapMapOutput is an Output that returns map[string]map[string]any values.
type MapMapOutput struct{ *OutputState }

func (MapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o MapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]any] {
	return pulumix.Output[map[string]map[string]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]any).
func (MapMapOutput) ElementType() reflect.Type {
	return mapMapType
}

func (o MapMapOutput) ToMapMapOutput() MapMapOutput {
	return o
}

func (o MapMapOutput) ToMapMapOutputWithContext(ctx context.Context) MapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o MapMapOutput) MapIndex(k StringInput) MapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]any {
		return vs[0].(map[string]map[string]any)[vs[1].(string)]
	}).(MapOutput)
}

func ToMapMap(in map[string]map[string]any) MapMap {
	m := make(MapMap)
	for k, v := range in {
		m[k] = ToMap(v)
	}
	return m
}

func ToMapMapOutput(in map[string]MapOutput) MapMapOutput {
	m := make(MapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToMapMapOutput()
}

var arrayArrayType = reflect.TypeOf((*[][]any)(nil)).Elem()

// ArrayArrayInput is an input type that accepts ArrayArray and ArrayArrayOutput values.
type ArrayArrayInput interface {
	Input

	ToArrayArrayOutput() ArrayArrayOutput
	ToArrayArrayOutputWithContext(ctx context.Context) ArrayArrayOutput
}

// ArrayArray is an input type for []ArrayInput values.
type ArrayArray []ArrayInput

// ElementType returns the element type of this Input ([][]any).
func (ArrayArray) ElementType() reflect.Type {
	return arrayArrayType
}

func (in ArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][]any] {
	return pulumix.Output[[][]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArrayArray) ToArrayArrayOutput() ArrayArrayOutput {
	return ToOutput(in).(ArrayArrayOutput)
}

func (in ArrayArray) ToArrayArrayOutputWithContext(ctx context.Context) ArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(ArrayArrayOutput)
}

// ArrayArrayOutput is an Output that returns [][]any values.
type ArrayArrayOutput struct{ *OutputState }

func (ArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][]any] {
	return pulumix.Output[[][]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][]any).
func (ArrayArrayOutput) ElementType() reflect.Type {
	return arrayArrayType
}

func (o ArrayArrayOutput) ToArrayArrayOutput() ArrayArrayOutput {
	return o
}

func (o ArrayArrayOutput) ToArrayArrayOutputWithContext(ctx context.Context) ArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o ArrayArrayOutput) Index(i IntInput) ArrayOutput {
	return All(o, i).ApplyT(func(vs []any) []any {
		arr := vs[0].([][]any)
		idx := vs[1].(int)
		var ret []any
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(ArrayOutput)
}

func ToArrayArray(in [][]any) ArrayArray {
	a := make(ArrayArray, len(in))
	for i, v := range in {
		a[i] = ToArray(v)
	}
	return a
}

func ToArrayArrayOutput(in []ArrayOutput) ArrayArrayOutput {
	a := make(ArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToArrayArrayOutput()
}

var arrayMapMapType = reflect.TypeOf((*map[string]map[string][]any)(nil)).Elem()

// ArrayMapMapInput is an input type that accepts ArrayMapMap and ArrayMapMapOutput values.
type ArrayMapMapInput interface {
	Input

	ToArrayMapMapOutput() ArrayMapMapOutput
	ToArrayMapMapOutputWithContext(ctx context.Context) ArrayMapMapOutput
}

// ArrayMapMap is an input type for map[string]ArrayMapInput values.
type ArrayMapMap map[string]ArrayMapInput

// ElementType returns the element type of this Input (map[string]map[string][]any).
func (ArrayMapMap) ElementType() reflect.Type {
	return arrayMapMapType
}

func (in ArrayMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]any] {
	return pulumix.Output[map[string]map[string][]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArrayMapMap) ToArrayMapMapOutput() ArrayMapMapOutput {
	return ToOutput(in).(ArrayMapMapOutput)
}

func (in ArrayMapMap) ToArrayMapMapOutputWithContext(ctx context.Context) ArrayMapMapOutput {
	return ToOutputWithContext(ctx, in).(ArrayMapMapOutput)
}

// ArrayMapMapOutput is an Output that returns map[string]map[string][]any values.
type ArrayMapMapOutput struct{ *OutputState }

func (ArrayMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArrayMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]any] {
	return pulumix.Output[map[string]map[string][]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string][]any).
func (ArrayMapMapOutput) ElementType() reflect.Type {
	return arrayMapMapType
}

func (o ArrayMapMapOutput) ToArrayMapMapOutput() ArrayMapMapOutput {
	return o
}

func (o ArrayMapMapOutput) ToArrayMapMapOutputWithContext(ctx context.Context) ArrayMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o ArrayMapMapOutput) MapIndex(k StringInput) ArrayMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string][]any {
		return vs[0].(map[string]map[string][]any)[vs[1].(string)]
	}).(ArrayMapOutput)
}

func ToArrayMapMap(in map[string]map[string][]any) ArrayMapMap {
	m := make(ArrayMapMap)
	for k, v := range in {
		m[k] = ToArrayMap(v)
	}
	return m
}

func ToArrayMapMapOutput(in map[string]ArrayMapOutput) ArrayMapMapOutput {
	m := make(ArrayMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToArrayMapMapOutput()
}

var mapArrayMapType = reflect.TypeOf((*map[string][]map[string]any)(nil)).Elem()

// MapArrayMapInput is an input type that accepts MapArrayMap and MapArrayMapOutput values.
type MapArrayMapInput interface {
	Input

	ToMapArrayMapOutput() MapArrayMapOutput
	ToMapArrayMapOutputWithContext(ctx context.Context) MapArrayMapOutput
}

// MapArrayMap is an input type for map[string]MapArrayInput values.
type MapArrayMap map[string]MapArrayInput

// ElementType returns the element type of this Input (map[string][]map[string]any).
func (MapArrayMap) ElementType() reflect.Type {
	return mapArrayMapType
}

func (in MapArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]any] {
	return pulumix.Output[map[string][]map[string]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in MapArrayMap) ToMapArrayMapOutput() MapArrayMapOutput {
	return ToOutput(in).(MapArrayMapOutput)
}

func (in MapArrayMap) ToMapArrayMapOutputWithContext(ctx context.Context) MapArrayMapOutput {
	return ToOutputWithContext(ctx, in).(MapArrayMapOutput)
}

// MapArrayMapOutput is an Output that returns map[string][]map[string]any values.
type MapArrayMapOutput struct{ *OutputState }

func (MapArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o MapArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]any] {
	return pulumix.Output[map[string][]map[string]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]map[string]any).
func (MapArrayMapOutput) ElementType() reflect.Type {
	return mapArrayMapType
}

func (o MapArrayMapOutput) ToMapArrayMapOutput() MapArrayMapOutput {
	return o
}

func (o MapArrayMapOutput) ToMapArrayMapOutputWithContext(ctx context.Context) MapArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o MapArrayMapOutput) MapIndex(k StringInput) MapArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []map[string]any {
		return vs[0].(map[string][]map[string]any)[vs[1].(string)]
	}).(MapArrayOutput)
}

func ToMapArrayMap(in map[string][]map[string]any) MapArrayMap {
	m := make(MapArrayMap)
	for k, v := range in {
		m[k] = ToMapArray(v)
	}
	return m
}

func ToMapArrayMapOutput(in map[string]MapArrayOutput) MapArrayMapOutput {
	m := make(MapArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToMapArrayMapOutput()
}

var mapMapArrayType = reflect.TypeOf((*[]map[string]map[string]any)(nil)).Elem()

// MapMapArrayInput is an input type that accepts MapMapArray and MapMapArrayOutput values.
type MapMapArrayInput interface {
	Input

	ToMapMapArrayOutput() MapMapArrayOutput
	ToMapMapArrayOutputWithContext(ctx context.Context) MapMapArrayOutput
}

// MapMapArray is an input type for []MapMapInput values.
type MapMapArray []MapMapInput

// ElementType returns the element type of this Input ([]map[string]map[string]any).
func (MapMapArray) ElementType() reflect.Type {
	return mapMapArrayType
}

func (in MapMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]any] {
	return pulumix.Output[[]map[string]map[string]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in MapMapArray) ToMapMapArrayOutput() MapMapArrayOutput {
	return ToOutput(in).(MapMapArrayOutput)
}

func (in MapMapArray) ToMapMapArrayOutputWithContext(ctx context.Context) MapMapArrayOutput {
	return ToOutputWithContext(ctx, in).(MapMapArrayOutput)
}

// MapMapArrayOutput is an Output that returns []map[string]map[string]any values.
type MapMapArrayOutput struct{ *OutputState }

func (MapMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o MapMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]any] {
	return pulumix.Output[[]map[string]map[string]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]map[string]any).
func (MapMapArrayOutput) ElementType() reflect.Type {
	return mapMapArrayType
}

func (o MapMapArrayOutput) ToMapMapArrayOutput() MapMapArrayOutput {
	return o
}

func (o MapMapArrayOutput) ToMapMapArrayOutputWithContext(ctx context.Context) MapMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o MapMapArrayOutput) Index(i IntInput) MapMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]map[string]any {
		arr := vs[0].([]map[string]map[string]any)
		idx := vs[1].(int)
		var ret map[string]map[string]any
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(MapMapOutput)
}

func ToMapMapArray(in []map[string]map[string]any) MapMapArray {
	a := make(MapMapArray, len(in))
	for i, v := range in {
		a[i] = ToMapMap(v)
	}
	return a
}

func ToMapMapArrayOutput(in []MapMapOutput) MapMapArrayOutput {
	a := make(MapMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToMapMapArrayOutput()
}

var arrayMapArrayType = reflect.TypeOf((*[]map[string][]any)(nil)).Elem()

// ArrayMapArrayInput is an input type that accepts ArrayMapArray and ArrayMapArrayOutput values.
type ArrayMapArrayInput interface {
	Input

	ToArrayMapArrayOutput() ArrayMapArrayOutput
	ToArrayMapArrayOutputWithContext(ctx context.Context) ArrayMapArrayOutput
}

// ArrayMapArray is an input type for []ArrayMapInput values.
type ArrayMapArray []ArrayMapInput

// ElementType returns the element type of this Input ([]map[string][]any).
func (ArrayMapArray) ElementType() reflect.Type {
	return arrayMapArrayType
}

func (in ArrayMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]any] {
	return pulumix.Output[[]map[string][]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArrayMapArray) ToArrayMapArrayOutput() ArrayMapArrayOutput {
	return ToOutput(in).(ArrayMapArrayOutput)
}

func (in ArrayMapArray) ToArrayMapArrayOutputWithContext(ctx context.Context) ArrayMapArrayOutput {
	return ToOutputWithContext(ctx, in).(ArrayMapArrayOutput)
}

// ArrayMapArrayOutput is an Output that returns []map[string][]any values.
type ArrayMapArrayOutput struct{ *OutputState }

func (ArrayMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArrayMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]any] {
	return pulumix.Output[[]map[string][]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string][]any).
func (ArrayMapArrayOutput) ElementType() reflect.Type {
	return arrayMapArrayType
}

func (o ArrayMapArrayOutput) ToArrayMapArrayOutput() ArrayMapArrayOutput {
	return o
}

func (o ArrayMapArrayOutput) ToArrayMapArrayOutputWithContext(ctx context.Context) ArrayMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o ArrayMapArrayOutput) Index(i IntInput) ArrayMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string][]any {
		arr := vs[0].([]map[string][]any)
		idx := vs[1].(int)
		var ret map[string][]any
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(ArrayMapOutput)
}

func ToArrayMapArray(in []map[string][]any) ArrayMapArray {
	a := make(ArrayMapArray, len(in))
	for i, v := range in {
		a[i] = ToArrayMap(v)
	}
	return a
}

func ToArrayMapArrayOutput(in []ArrayMapOutput) ArrayMapArrayOutput {
	a := make(ArrayMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToArrayMapArrayOutput()
}

var arrayArrayMapType = reflect.TypeOf((*map[string][][]any)(nil)).Elem()

// ArrayArrayMapInput is an input type that accepts ArrayArrayMap and ArrayArrayMapOutput values.
type ArrayArrayMapInput interface {
	Input

	ToArrayArrayMapOutput() ArrayArrayMapOutput
	ToArrayArrayMapOutputWithContext(ctx context.Context) ArrayArrayMapOutput
}

// ArrayArrayMap is an input type for map[string]ArrayArrayInput values.
type ArrayArrayMap map[string]ArrayArrayInput

// ElementType returns the element type of this Input (map[string][][]any).
func (ArrayArrayMap) ElementType() reflect.Type {
	return arrayArrayMapType
}

func (in ArrayArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][][]any] {
	return pulumix.Output[map[string][][]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArrayArrayMap) ToArrayArrayMapOutput() ArrayArrayMapOutput {
	return ToOutput(in).(ArrayArrayMapOutput)
}

func (in ArrayArrayMap) ToArrayArrayMapOutputWithContext(ctx context.Context) ArrayArrayMapOutput {
	return ToOutputWithContext(ctx, in).(ArrayArrayMapOutput)
}

// ArrayArrayMapOutput is an Output that returns map[string][][]any values.
type ArrayArrayMapOutput struct{ *OutputState }

func (ArrayArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArrayArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][][]any] {
	return pulumix.Output[map[string][][]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][][]any).
func (ArrayArrayMapOutput) ElementType() reflect.Type {
	return arrayArrayMapType
}

func (o ArrayArrayMapOutput) ToArrayArrayMapOutput() ArrayArrayMapOutput {
	return o
}

func (o ArrayArrayMapOutput) ToArrayArrayMapOutputWithContext(ctx context.Context) ArrayArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o ArrayArrayMapOutput) MapIndex(k StringInput) ArrayArrayOutput {
	return All(o, k).ApplyT(func(vs []any) [][]any {
		return vs[0].(map[string][][]any)[vs[1].(string)]
	}).(ArrayArrayOutput)
}

func ToArrayArrayMap(in map[string][][]any) ArrayArrayMap {
	m := make(ArrayArrayMap)
	for k, v := range in {
		m[k] = ToArrayArray(v)
	}
	return m
}

func ToArrayArrayMapOutput(in map[string]ArrayArrayOutput) ArrayArrayMapOutput {
	m := make(ArrayArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToArrayArrayMapOutput()
}

var arrayArrayArrayType = reflect.TypeOf((*[][][]any)(nil)).Elem()

// ArrayArrayArrayInput is an input type that accepts ArrayArrayArray and ArrayArrayArrayOutput values.
type ArrayArrayArrayInput interface {
	Input

	ToArrayArrayArrayOutput() ArrayArrayArrayOutput
	ToArrayArrayArrayOutputWithContext(ctx context.Context) ArrayArrayArrayOutput
}

// ArrayArrayArray is an input type for []ArrayArrayInput values.
type ArrayArrayArray []ArrayArrayInput

// ElementType returns the element type of this Input ([][][]any).
func (ArrayArrayArray) ElementType() reflect.Type {
	return arrayArrayArrayType
}

func (in ArrayArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][][]any] {
	return pulumix.Output[[][][]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in ArrayArrayArray) ToArrayArrayArrayOutput() ArrayArrayArrayOutput {
	return ToOutput(in).(ArrayArrayArrayOutput)
}

func (in ArrayArrayArray) ToArrayArrayArrayOutputWithContext(ctx context.Context) ArrayArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(ArrayArrayArrayOutput)
}

// ArrayArrayArrayOutput is an Output that returns [][][]any values.
type ArrayArrayArrayOutput struct{ *OutputState }

func (ArrayArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o ArrayArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][][]any] {
	return pulumix.Output[[][][]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][][]any).
func (ArrayArrayArrayOutput) ElementType() reflect.Type {
	return arrayArrayArrayType
}

func (o ArrayArrayArrayOutput) ToArrayArrayArrayOutput() ArrayArrayArrayOutput {
	return o
}

func (o ArrayArrayArrayOutput) ToArrayArrayArrayOutputWithContext(ctx context.Context) ArrayArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o ArrayArrayArrayOutput) Index(i IntInput) ArrayArrayOutput {
	return All(o, i).ApplyT(func(vs []any) [][]any {
		arr := vs[0].([][][]any)
		idx := vs[1].(int)
		var ret [][]any
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(ArrayArrayOutput)
}

func ToArrayArrayArray(in [][][]any) ArrayArrayArray {
	a := make(ArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = ToArrayArray(v)
	}
	return a
}

func ToArrayArrayArrayOutput(in []ArrayArrayOutput) ArrayArrayArrayOutput {
	a := make(ArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToArrayArrayArrayOutput()
}

var mapMapMapType = reflect.TypeOf((*map[string]map[string]map[string]any)(nil)).Elem()

// MapMapMapInput is an input type that accepts MapMapMap and MapMapMapOutput values.
type MapMapMapInput interface {
	Input

	ToMapMapMapOutput() MapMapMapOutput
	ToMapMapMapOutputWithContext(ctx context.Context) MapMapMapOutput
}

// MapMapMap is an input type for map[string]MapMapInput values.
type MapMapMap map[string]MapMapInput

// ElementType returns the element type of this Input (map[string]map[string]map[string]any).
func (MapMapMap) ElementType() reflect.Type {
	return mapMapMapType
}

func (in MapMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]any] {
	return pulumix.Output[map[string]map[string]map[string]any]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in MapMapMap) ToMapMapMapOutput() MapMapMapOutput {
	return ToOutput(in).(MapMapMapOutput)
}

func (in MapMapMap) ToMapMapMapOutputWithContext(ctx context.Context) MapMapMapOutput {
	return ToOutputWithContext(ctx, in).(MapMapMapOutput)
}

// MapMapMapOutput is an Output that returns map[string]map[string]map[string]any values.
type MapMapMapOutput struct{ *OutputState }

func (MapMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o MapMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]any] {
	return pulumix.Output[map[string]map[string]map[string]any]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]map[string]any).
func (MapMapMapOutput) ElementType() reflect.Type {
	return mapMapMapType
}

func (o MapMapMapOutput) ToMapMapMapOutput() MapMapMapOutput {
	return o
}

func (o MapMapMapOutput) ToMapMapMapOutputWithContext(ctx context.Context) MapMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o MapMapMapOutput) MapIndex(k StringInput) MapMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]map[string]any {
		return vs[0].(map[string]map[string]map[string]any)[vs[1].(string)]
	}).(MapMapOutput)
}

func ToMapMapMap(in map[string]map[string]map[string]any) MapMapMap {
	m := make(MapMapMap)
	for k, v := range in {
		m[k] = ToMapMap(v)
	}
	return m
}

func ToMapMapMapOutput(in map[string]MapMapOutput) MapMapMapOutput {
	m := make(MapMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToMapMapMapOutput()
}

var intType = reflect.TypeOf((*int)(nil)).Elem()

// IntInput is an input type that accepts Int and IntOutput values.
type IntInput interface {
	Input

	ToIntOutput() IntOutput
	ToIntOutputWithContext(ctx context.Context) IntOutput

	ToIntPtrOutput() IntPtrOutput
	ToIntPtrOutputWithContext(ctx context.Context) IntPtrOutput
}

// Int is an input type for int values.
type Int int

// ElementType returns the element type of this Input (int).
func (Int) ElementType() reflect.Type {
	return intType
}

func (in Int) ToOutput(ctx context.Context) pulumix.Output[int] {
	return pulumix.Output[int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in Int) ToIntOutput() IntOutput {
	return ToOutput(in).(IntOutput)
}

func (in Int) ToIntOutputWithContext(ctx context.Context) IntOutput {
	return ToOutputWithContext(ctx, in).(IntOutput)
}

func (in Int) ToIntPtrOutput() IntPtrOutput {
	return in.ToIntPtrOutputWithContext(context.Background())
}

func (in Int) ToIntPtrOutputWithContext(ctx context.Context) IntPtrOutput {
	return in.ToIntOutputWithContext(ctx).ToIntPtrOutputWithContext(ctx)
}

// IntOutput is an Output that returns int values.
type IntOutput struct{ *OutputState }

func (IntOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntOutput) ToOutput(ctx context.Context) pulumix.Output[int] {
	return pulumix.Output[int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (int).
func (IntOutput) ElementType() reflect.Type {
	return intType
}

func (o IntOutput) ToIntOutput() IntOutput {
	return o
}

func (o IntOutput) ToIntOutputWithContext(ctx context.Context) IntOutput {
	return o
}

func (o IntOutput) ToIntPtrOutput() IntPtrOutput {
	return o.ToIntPtrOutputWithContext(context.Background())
}

func (o IntOutput) ToIntPtrOutputWithContext(ctx context.Context) IntPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v int) *int {
		return &v
	}).(IntPtrOutput)
}

var intPtrType = reflect.TypeOf((**int)(nil)).Elem()

// IntPtrInput is an input type that accepts IntPtr and IntPtrOutput values.
type IntPtrInput interface {
	Input

	ToIntPtrOutput() IntPtrOutput
	ToIntPtrOutputWithContext(ctx context.Context) IntPtrOutput
}

type intPtr int

// IntPtr is an input type for *int values.
func IntPtr(v int) IntPtrInput {
	return (*intPtr)(&v)
}

func IntPtrFromPtr(v *int) IntPtrInput {
	if v == nil {
		return nil
	}
	return (*intPtr)(v)
}

// ElementType returns the element type of this Input (*int).
func (*intPtr) ElementType() reflect.Type {
	return intPtrType
}

func (in *intPtr) ToOutput(ctx context.Context) pulumix.Output[*int] {
	return pulumix.Output[*int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in *intPtr) ToIntPtrOutput() IntPtrOutput {
	return ToOutput(in).(IntPtrOutput)
}

func (in *intPtr) ToIntPtrOutputWithContext(ctx context.Context) IntPtrOutput {
	return ToOutputWithContext(ctx, in).(IntPtrOutput)
}

// IntPtrOutput is an Output that returns *int values.
type IntPtrOutput struct{ *OutputState }

func (IntPtrOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*int] {
	return pulumix.Output[*int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (*int).
func (IntPtrOutput) ElementType() reflect.Type {
	return intPtrType
}

func (o IntPtrOutput) ToIntPtrOutput() IntPtrOutput {
	return o
}

func (o IntPtrOutput) ToIntPtrOutputWithContext(ctx context.Context) IntPtrOutput {
	return o
}

// Elem dereferences the pointer value or returns the zero value of the approporiate type if the pointer is nil.
func (o IntPtrOutput) Elem() IntOutput {
	return o.ApplyT(func(v *int) int {
		var ret int
		if v != nil {
			ret = *v
		}
		return ret
	}).(IntOutput)
}

var intArrayType = reflect.TypeOf((*[]int)(nil)).Elem()

// IntArrayInput is an input type that accepts IntArray and IntArrayOutput values.
type IntArrayInput interface {
	Input

	ToIntArrayOutput() IntArrayOutput
	ToIntArrayOutputWithContext(ctx context.Context) IntArrayOutput
}

// IntArray is an input type for []IntInput values.
type IntArray []IntInput

// ElementType returns the element type of this Input ([]int).
func (IntArray) ElementType() reflect.Type {
	return intArrayType
}

func (in IntArray) ToOutput(ctx context.Context) pulumix.Output[[]int] {
	return pulumix.Output[[]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntArray) ToIntArrayOutput() IntArrayOutput {
	return ToOutput(in).(IntArrayOutput)
}

func (in IntArray) ToIntArrayOutputWithContext(ctx context.Context) IntArrayOutput {
	return ToOutputWithContext(ctx, in).(IntArrayOutput)
}

// IntArrayOutput is an Output that returns []int values.
type IntArrayOutput struct{ *OutputState }

func (IntArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]int] {
	return pulumix.Output[[]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]int).
func (IntArrayOutput) ElementType() reflect.Type {
	return intArrayType
}

func (o IntArrayOutput) ToIntArrayOutput() IntArrayOutput {
	return o
}

func (o IntArrayOutput) ToIntArrayOutputWithContext(ctx context.Context) IntArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IntArrayOutput) Index(i IntInput) IntOutput {
	return All(o, i).ApplyT(func(vs []any) int {
		arr := vs[0].([]int)
		idx := vs[1].(int)
		var ret int
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IntOutput)
}

func ToIntArray(in []int) IntArray {
	a := make(IntArray, len(in))
	for i, v := range in {
		a[i] = Int(v)
	}
	return a
}

func ToIntArrayOutput(in []IntOutput) IntArrayOutput {
	a := make(IntArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIntArrayOutput()
}

var intMapType = reflect.TypeOf((*map[string]int)(nil)).Elem()

// IntMapInput is an input type that accepts IntMap and IntMapOutput values.
type IntMapInput interface {
	Input

	ToIntMapOutput() IntMapOutput
	ToIntMapOutputWithContext(ctx context.Context) IntMapOutput
}

// IntMap is an input type for map[string]IntInput values.
type IntMap map[string]IntInput

// ElementType returns the element type of this Input (map[string]int).
func (IntMap) ElementType() reflect.Type {
	return intMapType
}

func (in IntMap) ToOutput(ctx context.Context) pulumix.Output[map[string]int] {
	return pulumix.Output[map[string]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntMap) ToIntMapOutput() IntMapOutput {
	return ToOutput(in).(IntMapOutput)
}

func (in IntMap) ToIntMapOutputWithContext(ctx context.Context) IntMapOutput {
	return ToOutputWithContext(ctx, in).(IntMapOutput)
}

// IntMapOutput is an Output that returns map[string]int values.
type IntMapOutput struct{ *OutputState }

func (IntMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]int] {
	return pulumix.Output[map[string]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]int).
func (IntMapOutput) ElementType() reflect.Type {
	return intMapType
}

func (o IntMapOutput) ToIntMapOutput() IntMapOutput {
	return o
}

func (o IntMapOutput) ToIntMapOutputWithContext(ctx context.Context) IntMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IntMapOutput) MapIndex(k StringInput) IntOutput {
	return All(o, k).ApplyT(func(vs []any) int {
		return vs[0].(map[string]int)[vs[1].(string)]
	}).(IntOutput)
}

func ToIntMap(in map[string]int) IntMap {
	m := make(IntMap)
	for k, v := range in {
		m[k] = Int(v)
	}
	return m
}

func ToIntMapOutput(in map[string]IntOutput) IntMapOutput {
	m := make(IntMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIntMapOutput()
}

var intArrayMapType = reflect.TypeOf((*map[string][]int)(nil)).Elem()

// IntArrayMapInput is an input type that accepts IntArrayMap and IntArrayMapOutput values.
type IntArrayMapInput interface {
	Input

	ToIntArrayMapOutput() IntArrayMapOutput
	ToIntArrayMapOutputWithContext(ctx context.Context) IntArrayMapOutput
}

// IntArrayMap is an input type for map[string]IntArrayInput values.
type IntArrayMap map[string]IntArrayInput

// ElementType returns the element type of this Input (map[string][]int).
func (IntArrayMap) ElementType() reflect.Type {
	return intArrayMapType
}

func (in IntArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]int] {
	return pulumix.Output[map[string][]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntArrayMap) ToIntArrayMapOutput() IntArrayMapOutput {
	return ToOutput(in).(IntArrayMapOutput)
}

func (in IntArrayMap) ToIntArrayMapOutputWithContext(ctx context.Context) IntArrayMapOutput {
	return ToOutputWithContext(ctx, in).(IntArrayMapOutput)
}

// IntArrayMapOutput is an Output that returns map[string][]int values.
type IntArrayMapOutput struct{ *OutputState }

func (IntArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]int] {
	return pulumix.Output[map[string][]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]int).
func (IntArrayMapOutput) ElementType() reflect.Type {
	return intArrayMapType
}

func (o IntArrayMapOutput) ToIntArrayMapOutput() IntArrayMapOutput {
	return o
}

func (o IntArrayMapOutput) ToIntArrayMapOutputWithContext(ctx context.Context) IntArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IntArrayMapOutput) MapIndex(k StringInput) IntArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []int {
		return vs[0].(map[string][]int)[vs[1].(string)]
	}).(IntArrayOutput)
}

func ToIntArrayMap(in map[string][]int) IntArrayMap {
	m := make(IntArrayMap)
	for k, v := range in {
		m[k] = ToIntArray(v)
	}
	return m
}

func ToIntArrayMapOutput(in map[string]IntArrayOutput) IntArrayMapOutput {
	m := make(IntArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIntArrayMapOutput()
}

var intMapArrayType = reflect.TypeOf((*[]map[string]int)(nil)).Elem()

// IntMapArrayInput is an input type that accepts IntMapArray and IntMapArrayOutput values.
type IntMapArrayInput interface {
	Input

	ToIntMapArrayOutput() IntMapArrayOutput
	ToIntMapArrayOutputWithContext(ctx context.Context) IntMapArrayOutput
}

// IntMapArray is an input type for []IntMapInput values.
type IntMapArray []IntMapInput

// ElementType returns the element type of this Input ([]map[string]int).
func (IntMapArray) ElementType() reflect.Type {
	return intMapArrayType
}

func (in IntMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]int] {
	return pulumix.Output[[]map[string]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntMapArray) ToIntMapArrayOutput() IntMapArrayOutput {
	return ToOutput(in).(IntMapArrayOutput)
}

func (in IntMapArray) ToIntMapArrayOutputWithContext(ctx context.Context) IntMapArrayOutput {
	return ToOutputWithContext(ctx, in).(IntMapArrayOutput)
}

// IntMapArrayOutput is an Output that returns []map[string]int values.
type IntMapArrayOutput struct{ *OutputState }

func (IntMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]int] {
	return pulumix.Output[[]map[string]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]int).
func (IntMapArrayOutput) ElementType() reflect.Type {
	return intMapArrayType
}

func (o IntMapArrayOutput) ToIntMapArrayOutput() IntMapArrayOutput {
	return o
}

func (o IntMapArrayOutput) ToIntMapArrayOutputWithContext(ctx context.Context) IntMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IntMapArrayOutput) Index(i IntInput) IntMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]int {
		arr := vs[0].([]map[string]int)
		idx := vs[1].(int)
		var ret map[string]int
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IntMapOutput)
}

func ToIntMapArray(in []map[string]int) IntMapArray {
	a := make(IntMapArray, len(in))
	for i, v := range in {
		a[i] = ToIntMap(v)
	}
	return a
}

func ToIntMapArrayOutput(in []IntMapOutput) IntMapArrayOutput {
	a := make(IntMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIntMapArrayOutput()
}

var intMapMapType = reflect.TypeOf((*map[string]map[string]int)(nil)).Elem()

// IntMapMapInput is an input type that accepts IntMapMap and IntMapMapOutput values.
type IntMapMapInput interface {
	Input

	ToIntMapMapOutput() IntMapMapOutput
	ToIntMapMapOutputWithContext(ctx context.Context) IntMapMapOutput
}

// IntMapMap is an input type for map[string]IntMapInput values.
type IntMapMap map[string]IntMapInput

// ElementType returns the element type of this Input (map[string]map[string]int).
func (IntMapMap) ElementType() reflect.Type {
	return intMapMapType
}

func (in IntMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]int] {
	return pulumix.Output[map[string]map[string]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntMapMap) ToIntMapMapOutput() IntMapMapOutput {
	return ToOutput(in).(IntMapMapOutput)
}

func (in IntMapMap) ToIntMapMapOutputWithContext(ctx context.Context) IntMapMapOutput {
	return ToOutputWithContext(ctx, in).(IntMapMapOutput)
}

// IntMapMapOutput is an Output that returns map[string]map[string]int values.
type IntMapMapOutput struct{ *OutputState }

func (IntMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]int] {
	return pulumix.Output[map[string]map[string]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]int).
func (IntMapMapOutput) ElementType() reflect.Type {
	return intMapMapType
}

func (o IntMapMapOutput) ToIntMapMapOutput() IntMapMapOutput {
	return o
}

func (o IntMapMapOutput) ToIntMapMapOutputWithContext(ctx context.Context) IntMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IntMapMapOutput) MapIndex(k StringInput) IntMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]int {
		return vs[0].(map[string]map[string]int)[vs[1].(string)]
	}).(IntMapOutput)
}

func ToIntMapMap(in map[string]map[string]int) IntMapMap {
	m := make(IntMapMap)
	for k, v := range in {
		m[k] = ToIntMap(v)
	}
	return m
}

func ToIntMapMapOutput(in map[string]IntMapOutput) IntMapMapOutput {
	m := make(IntMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIntMapMapOutput()
}

var intArrayArrayType = reflect.TypeOf((*[][]int)(nil)).Elem()

// IntArrayArrayInput is an input type that accepts IntArrayArray and IntArrayArrayOutput values.
type IntArrayArrayInput interface {
	Input

	ToIntArrayArrayOutput() IntArrayArrayOutput
	ToIntArrayArrayOutputWithContext(ctx context.Context) IntArrayArrayOutput
}

// IntArrayArray is an input type for []IntArrayInput values.
type IntArrayArray []IntArrayInput

// ElementType returns the element type of this Input ([][]int).
func (IntArrayArray) ElementType() reflect.Type {
	return intArrayArrayType
}

func (in IntArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][]int] {
	return pulumix.Output[[][]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntArrayArray) ToIntArrayArrayOutput() IntArrayArrayOutput {
	return ToOutput(in).(IntArrayArrayOutput)
}

func (in IntArrayArray) ToIntArrayArrayOutputWithContext(ctx context.Context) IntArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(IntArrayArrayOutput)
}

// IntArrayArrayOutput is an Output that returns [][]int values.
type IntArrayArrayOutput struct{ *OutputState }

func (IntArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][]int] {
	return pulumix.Output[[][]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][]int).
func (IntArrayArrayOutput) ElementType() reflect.Type {
	return intArrayArrayType
}

func (o IntArrayArrayOutput) ToIntArrayArrayOutput() IntArrayArrayOutput {
	return o
}

func (o IntArrayArrayOutput) ToIntArrayArrayOutputWithContext(ctx context.Context) IntArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IntArrayArrayOutput) Index(i IntInput) IntArrayOutput {
	return All(o, i).ApplyT(func(vs []any) []int {
		arr := vs[0].([][]int)
		idx := vs[1].(int)
		var ret []int
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IntArrayOutput)
}

func ToIntArrayArray(in [][]int) IntArrayArray {
	a := make(IntArrayArray, len(in))
	for i, v := range in {
		a[i] = ToIntArray(v)
	}
	return a
}

func ToIntArrayArrayOutput(in []IntArrayOutput) IntArrayArrayOutput {
	a := make(IntArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIntArrayArrayOutput()
}

var intArrayMapMapType = reflect.TypeOf((*map[string]map[string][]int)(nil)).Elem()

// IntArrayMapMapInput is an input type that accepts IntArrayMapMap and IntArrayMapMapOutput values.
type IntArrayMapMapInput interface {
	Input

	ToIntArrayMapMapOutput() IntArrayMapMapOutput
	ToIntArrayMapMapOutputWithContext(ctx context.Context) IntArrayMapMapOutput
}

// IntArrayMapMap is an input type for map[string]IntArrayMapInput values.
type IntArrayMapMap map[string]IntArrayMapInput

// ElementType returns the element type of this Input (map[string]map[string][]int).
func (IntArrayMapMap) ElementType() reflect.Type {
	return intArrayMapMapType
}

func (in IntArrayMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]int] {
	return pulumix.Output[map[string]map[string][]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntArrayMapMap) ToIntArrayMapMapOutput() IntArrayMapMapOutput {
	return ToOutput(in).(IntArrayMapMapOutput)
}

func (in IntArrayMapMap) ToIntArrayMapMapOutputWithContext(ctx context.Context) IntArrayMapMapOutput {
	return ToOutputWithContext(ctx, in).(IntArrayMapMapOutput)
}

// IntArrayMapMapOutput is an Output that returns map[string]map[string][]int values.
type IntArrayMapMapOutput struct{ *OutputState }

func (IntArrayMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntArrayMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]int] {
	return pulumix.Output[map[string]map[string][]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string][]int).
func (IntArrayMapMapOutput) ElementType() reflect.Type {
	return intArrayMapMapType
}

func (o IntArrayMapMapOutput) ToIntArrayMapMapOutput() IntArrayMapMapOutput {
	return o
}

func (o IntArrayMapMapOutput) ToIntArrayMapMapOutputWithContext(ctx context.Context) IntArrayMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IntArrayMapMapOutput) MapIndex(k StringInput) IntArrayMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string][]int {
		return vs[0].(map[string]map[string][]int)[vs[1].(string)]
	}).(IntArrayMapOutput)
}

func ToIntArrayMapMap(in map[string]map[string][]int) IntArrayMapMap {
	m := make(IntArrayMapMap)
	for k, v := range in {
		m[k] = ToIntArrayMap(v)
	}
	return m
}

func ToIntArrayMapMapOutput(in map[string]IntArrayMapOutput) IntArrayMapMapOutput {
	m := make(IntArrayMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIntArrayMapMapOutput()
}

var intMapArrayMapType = reflect.TypeOf((*map[string][]map[string]int)(nil)).Elem()

// IntMapArrayMapInput is an input type that accepts IntMapArrayMap and IntMapArrayMapOutput values.
type IntMapArrayMapInput interface {
	Input

	ToIntMapArrayMapOutput() IntMapArrayMapOutput
	ToIntMapArrayMapOutputWithContext(ctx context.Context) IntMapArrayMapOutput
}

// IntMapArrayMap is an input type for map[string]IntMapArrayInput values.
type IntMapArrayMap map[string]IntMapArrayInput

// ElementType returns the element type of this Input (map[string][]map[string]int).
func (IntMapArrayMap) ElementType() reflect.Type {
	return intMapArrayMapType
}

func (in IntMapArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]int] {
	return pulumix.Output[map[string][]map[string]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntMapArrayMap) ToIntMapArrayMapOutput() IntMapArrayMapOutput {
	return ToOutput(in).(IntMapArrayMapOutput)
}

func (in IntMapArrayMap) ToIntMapArrayMapOutputWithContext(ctx context.Context) IntMapArrayMapOutput {
	return ToOutputWithContext(ctx, in).(IntMapArrayMapOutput)
}

// IntMapArrayMapOutput is an Output that returns map[string][]map[string]int values.
type IntMapArrayMapOutput struct{ *OutputState }

func (IntMapArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntMapArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]int] {
	return pulumix.Output[map[string][]map[string]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]map[string]int).
func (IntMapArrayMapOutput) ElementType() reflect.Type {
	return intMapArrayMapType
}

func (o IntMapArrayMapOutput) ToIntMapArrayMapOutput() IntMapArrayMapOutput {
	return o
}

func (o IntMapArrayMapOutput) ToIntMapArrayMapOutputWithContext(ctx context.Context) IntMapArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IntMapArrayMapOutput) MapIndex(k StringInput) IntMapArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []map[string]int {
		return vs[0].(map[string][]map[string]int)[vs[1].(string)]
	}).(IntMapArrayOutput)
}

func ToIntMapArrayMap(in map[string][]map[string]int) IntMapArrayMap {
	m := make(IntMapArrayMap)
	for k, v := range in {
		m[k] = ToIntMapArray(v)
	}
	return m
}

func ToIntMapArrayMapOutput(in map[string]IntMapArrayOutput) IntMapArrayMapOutput {
	m := make(IntMapArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIntMapArrayMapOutput()
}

var intMapMapArrayType = reflect.TypeOf((*[]map[string]map[string]int)(nil)).Elem()

// IntMapMapArrayInput is an input type that accepts IntMapMapArray and IntMapMapArrayOutput values.
type IntMapMapArrayInput interface {
	Input

	ToIntMapMapArrayOutput() IntMapMapArrayOutput
	ToIntMapMapArrayOutputWithContext(ctx context.Context) IntMapMapArrayOutput
}

// IntMapMapArray is an input type for []IntMapMapInput values.
type IntMapMapArray []IntMapMapInput

// ElementType returns the element type of this Input ([]map[string]map[string]int).
func (IntMapMapArray) ElementType() reflect.Type {
	return intMapMapArrayType
}

func (in IntMapMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]int] {
	return pulumix.Output[[]map[string]map[string]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntMapMapArray) ToIntMapMapArrayOutput() IntMapMapArrayOutput {
	return ToOutput(in).(IntMapMapArrayOutput)
}

func (in IntMapMapArray) ToIntMapMapArrayOutputWithContext(ctx context.Context) IntMapMapArrayOutput {
	return ToOutputWithContext(ctx, in).(IntMapMapArrayOutput)
}

// IntMapMapArrayOutput is an Output that returns []map[string]map[string]int values.
type IntMapMapArrayOutput struct{ *OutputState }

func (IntMapMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntMapMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]int] {
	return pulumix.Output[[]map[string]map[string]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]map[string]int).
func (IntMapMapArrayOutput) ElementType() reflect.Type {
	return intMapMapArrayType
}

func (o IntMapMapArrayOutput) ToIntMapMapArrayOutput() IntMapMapArrayOutput {
	return o
}

func (o IntMapMapArrayOutput) ToIntMapMapArrayOutputWithContext(ctx context.Context) IntMapMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IntMapMapArrayOutput) Index(i IntInput) IntMapMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]map[string]int {
		arr := vs[0].([]map[string]map[string]int)
		idx := vs[1].(int)
		var ret map[string]map[string]int
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IntMapMapOutput)
}

func ToIntMapMapArray(in []map[string]map[string]int) IntMapMapArray {
	a := make(IntMapMapArray, len(in))
	for i, v := range in {
		a[i] = ToIntMapMap(v)
	}
	return a
}

func ToIntMapMapArrayOutput(in []IntMapMapOutput) IntMapMapArrayOutput {
	a := make(IntMapMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIntMapMapArrayOutput()
}

var intArrayMapArrayType = reflect.TypeOf((*[]map[string][]int)(nil)).Elem()

// IntArrayMapArrayInput is an input type that accepts IntArrayMapArray and IntArrayMapArrayOutput values.
type IntArrayMapArrayInput interface {
	Input

	ToIntArrayMapArrayOutput() IntArrayMapArrayOutput
	ToIntArrayMapArrayOutputWithContext(ctx context.Context) IntArrayMapArrayOutput
}

// IntArrayMapArray is an input type for []IntArrayMapInput values.
type IntArrayMapArray []IntArrayMapInput

// ElementType returns the element type of this Input ([]map[string][]int).
func (IntArrayMapArray) ElementType() reflect.Type {
	return intArrayMapArrayType
}

func (in IntArrayMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]int] {
	return pulumix.Output[[]map[string][]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntArrayMapArray) ToIntArrayMapArrayOutput() IntArrayMapArrayOutput {
	return ToOutput(in).(IntArrayMapArrayOutput)
}

func (in IntArrayMapArray) ToIntArrayMapArrayOutputWithContext(ctx context.Context) IntArrayMapArrayOutput {
	return ToOutputWithContext(ctx, in).(IntArrayMapArrayOutput)
}

// IntArrayMapArrayOutput is an Output that returns []map[string][]int values.
type IntArrayMapArrayOutput struct{ *OutputState }

func (IntArrayMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntArrayMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]int] {
	return pulumix.Output[[]map[string][]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string][]int).
func (IntArrayMapArrayOutput) ElementType() reflect.Type {
	return intArrayMapArrayType
}

func (o IntArrayMapArrayOutput) ToIntArrayMapArrayOutput() IntArrayMapArrayOutput {
	return o
}

func (o IntArrayMapArrayOutput) ToIntArrayMapArrayOutputWithContext(ctx context.Context) IntArrayMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IntArrayMapArrayOutput) Index(i IntInput) IntArrayMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string][]int {
		arr := vs[0].([]map[string][]int)
		idx := vs[1].(int)
		var ret map[string][]int
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IntArrayMapOutput)
}

func ToIntArrayMapArray(in []map[string][]int) IntArrayMapArray {
	a := make(IntArrayMapArray, len(in))
	for i, v := range in {
		a[i] = ToIntArrayMap(v)
	}
	return a
}

func ToIntArrayMapArrayOutput(in []IntArrayMapOutput) IntArrayMapArrayOutput {
	a := make(IntArrayMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIntArrayMapArrayOutput()
}

var intArrayArrayMapType = reflect.TypeOf((*map[string][][]int)(nil)).Elem()

// IntArrayArrayMapInput is an input type that accepts IntArrayArrayMap and IntArrayArrayMapOutput values.
type IntArrayArrayMapInput interface {
	Input

	ToIntArrayArrayMapOutput() IntArrayArrayMapOutput
	ToIntArrayArrayMapOutputWithContext(ctx context.Context) IntArrayArrayMapOutput
}

// IntArrayArrayMap is an input type for map[string]IntArrayArrayInput values.
type IntArrayArrayMap map[string]IntArrayArrayInput

// ElementType returns the element type of this Input (map[string][][]int).
func (IntArrayArrayMap) ElementType() reflect.Type {
	return intArrayArrayMapType
}

func (in IntArrayArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][][]int] {
	return pulumix.Output[map[string][][]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntArrayArrayMap) ToIntArrayArrayMapOutput() IntArrayArrayMapOutput {
	return ToOutput(in).(IntArrayArrayMapOutput)
}

func (in IntArrayArrayMap) ToIntArrayArrayMapOutputWithContext(ctx context.Context) IntArrayArrayMapOutput {
	return ToOutputWithContext(ctx, in).(IntArrayArrayMapOutput)
}

// IntArrayArrayMapOutput is an Output that returns map[string][][]int values.
type IntArrayArrayMapOutput struct{ *OutputState }

func (IntArrayArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntArrayArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][][]int] {
	return pulumix.Output[map[string][][]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][][]int).
func (IntArrayArrayMapOutput) ElementType() reflect.Type {
	return intArrayArrayMapType
}

func (o IntArrayArrayMapOutput) ToIntArrayArrayMapOutput() IntArrayArrayMapOutput {
	return o
}

func (o IntArrayArrayMapOutput) ToIntArrayArrayMapOutputWithContext(ctx context.Context) IntArrayArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IntArrayArrayMapOutput) MapIndex(k StringInput) IntArrayArrayOutput {
	return All(o, k).ApplyT(func(vs []any) [][]int {
		return vs[0].(map[string][][]int)[vs[1].(string)]
	}).(IntArrayArrayOutput)
}

func ToIntArrayArrayMap(in map[string][][]int) IntArrayArrayMap {
	m := make(IntArrayArrayMap)
	for k, v := range in {
		m[k] = ToIntArrayArray(v)
	}
	return m
}

func ToIntArrayArrayMapOutput(in map[string]IntArrayArrayOutput) IntArrayArrayMapOutput {
	m := make(IntArrayArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIntArrayArrayMapOutput()
}

var intArrayArrayArrayType = reflect.TypeOf((*[][][]int)(nil)).Elem()

// IntArrayArrayArrayInput is an input type that accepts IntArrayArrayArray and IntArrayArrayArrayOutput values.
type IntArrayArrayArrayInput interface {
	Input

	ToIntArrayArrayArrayOutput() IntArrayArrayArrayOutput
	ToIntArrayArrayArrayOutputWithContext(ctx context.Context) IntArrayArrayArrayOutput
}

// IntArrayArrayArray is an input type for []IntArrayArrayInput values.
type IntArrayArrayArray []IntArrayArrayInput

// ElementType returns the element type of this Input ([][][]int).
func (IntArrayArrayArray) ElementType() reflect.Type {
	return intArrayArrayArrayType
}

func (in IntArrayArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][][]int] {
	return pulumix.Output[[][][]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntArrayArrayArray) ToIntArrayArrayArrayOutput() IntArrayArrayArrayOutput {
	return ToOutput(in).(IntArrayArrayArrayOutput)
}

func (in IntArrayArrayArray) ToIntArrayArrayArrayOutputWithContext(ctx context.Context) IntArrayArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(IntArrayArrayArrayOutput)
}

// IntArrayArrayArrayOutput is an Output that returns [][][]int values.
type IntArrayArrayArrayOutput struct{ *OutputState }

func (IntArrayArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntArrayArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][][]int] {
	return pulumix.Output[[][][]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][][]int).
func (IntArrayArrayArrayOutput) ElementType() reflect.Type {
	return intArrayArrayArrayType
}

func (o IntArrayArrayArrayOutput) ToIntArrayArrayArrayOutput() IntArrayArrayArrayOutput {
	return o
}

func (o IntArrayArrayArrayOutput) ToIntArrayArrayArrayOutputWithContext(ctx context.Context) IntArrayArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o IntArrayArrayArrayOutput) Index(i IntInput) IntArrayArrayOutput {
	return All(o, i).ApplyT(func(vs []any) [][]int {
		arr := vs[0].([][][]int)
		idx := vs[1].(int)
		var ret [][]int
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(IntArrayArrayOutput)
}

func ToIntArrayArrayArray(in [][][]int) IntArrayArrayArray {
	a := make(IntArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = ToIntArrayArray(v)
	}
	return a
}

func ToIntArrayArrayArrayOutput(in []IntArrayArrayOutput) IntArrayArrayArrayOutput {
	a := make(IntArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToIntArrayArrayArrayOutput()
}

var intMapMapMapType = reflect.TypeOf((*map[string]map[string]map[string]int)(nil)).Elem()

// IntMapMapMapInput is an input type that accepts IntMapMapMap and IntMapMapMapOutput values.
type IntMapMapMapInput interface {
	Input

	ToIntMapMapMapOutput() IntMapMapMapOutput
	ToIntMapMapMapOutputWithContext(ctx context.Context) IntMapMapMapOutput
}

// IntMapMapMap is an input type for map[string]IntMapMapInput values.
type IntMapMapMap map[string]IntMapMapInput

// ElementType returns the element type of this Input (map[string]map[string]map[string]int).
func (IntMapMapMap) ElementType() reflect.Type {
	return intMapMapMapType
}

func (in IntMapMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]int] {
	return pulumix.Output[map[string]map[string]map[string]int]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in IntMapMapMap) ToIntMapMapMapOutput() IntMapMapMapOutput {
	return ToOutput(in).(IntMapMapMapOutput)
}

func (in IntMapMapMap) ToIntMapMapMapOutputWithContext(ctx context.Context) IntMapMapMapOutput {
	return ToOutputWithContext(ctx, in).(IntMapMapMapOutput)
}

// IntMapMapMapOutput is an Output that returns map[string]map[string]map[string]int values.
type IntMapMapMapOutput struct{ *OutputState }

func (IntMapMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o IntMapMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]int] {
	return pulumix.Output[map[string]map[string]map[string]int]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]map[string]int).
func (IntMapMapMapOutput) ElementType() reflect.Type {
	return intMapMapMapType
}

func (o IntMapMapMapOutput) ToIntMapMapMapOutput() IntMapMapMapOutput {
	return o
}

func (o IntMapMapMapOutput) ToIntMapMapMapOutputWithContext(ctx context.Context) IntMapMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o IntMapMapMapOutput) MapIndex(k StringInput) IntMapMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]map[string]int {
		return vs[0].(map[string]map[string]map[string]int)[vs[1].(string)]
	}).(IntMapMapOutput)
}

func ToIntMapMapMap(in map[string]map[string]map[string]int) IntMapMapMap {
	m := make(IntMapMapMap)
	for k, v := range in {
		m[k] = ToIntMapMap(v)
	}
	return m
}

func ToIntMapMapMapOutput(in map[string]IntMapMapOutput) IntMapMapMapOutput {
	m := make(IntMapMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToIntMapMapMapOutput()
}

var stringType = reflect.TypeOf((*string)(nil)).Elem()

// StringInput is an input type that accepts String and StringOutput values.
type StringInput interface {
	Input

	ToStringOutput() StringOutput
	ToStringOutputWithContext(ctx context.Context) StringOutput

	ToStringPtrOutput() StringPtrOutput
	ToStringPtrOutputWithContext(ctx context.Context) StringPtrOutput
}

// String is an input type for string values.
type String string

// ElementType returns the element type of this Input (string).
func (String) ElementType() reflect.Type {
	return stringType
}

func (in String) ToOutput(ctx context.Context) pulumix.Output[string] {
	return pulumix.Output[string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in String) ToStringOutput() StringOutput {
	return ToOutput(in).(StringOutput)
}

func (in String) ToStringOutputWithContext(ctx context.Context) StringOutput {
	return ToOutputWithContext(ctx, in).(StringOutput)
}

func (in String) ToStringPtrOutput() StringPtrOutput {
	return in.ToStringPtrOutputWithContext(context.Background())
}

func (in String) ToStringPtrOutputWithContext(ctx context.Context) StringPtrOutput {
	return in.ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// StringOutput is an Output that returns string values.
type StringOutput struct{ *OutputState }

func (StringOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringOutput) ToOutput(ctx context.Context) pulumix.Output[string] {
	return pulumix.Output[string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (string).
func (StringOutput) ElementType() reflect.Type {
	return stringType
}

func (o StringOutput) ToStringOutput() StringOutput {
	return o
}

func (o StringOutput) ToStringOutputWithContext(ctx context.Context) StringOutput {
	return o
}

func (o StringOutput) ToStringPtrOutput() StringPtrOutput {
	return o.ToStringPtrOutputWithContext(context.Background())
}

func (o StringOutput) ToStringPtrOutputWithContext(ctx context.Context) StringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v string) *string {
		return &v
	}).(StringPtrOutput)
}

var stringPtrType = reflect.TypeOf((**string)(nil)).Elem()

// StringPtrInput is an input type that accepts StringPtr and StringPtrOutput values.
type StringPtrInput interface {
	Input

	ToStringPtrOutput() StringPtrOutput
	ToStringPtrOutputWithContext(ctx context.Context) StringPtrOutput
}

type stringPtr string

// StringPtr is an input type for *string values.
func StringPtr(v string) StringPtrInput {
	return (*stringPtr)(&v)
}

func StringPtrFromPtr(v *string) StringPtrInput {
	if v == nil {
		return nil
	}
	return (*stringPtr)(v)
}

// ElementType returns the element type of this Input (*string).
func (*stringPtr) ElementType() reflect.Type {
	return stringPtrType
}

func (in *stringPtr) ToOutput(ctx context.Context) pulumix.Output[*string] {
	return pulumix.Output[*string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in *stringPtr) ToStringPtrOutput() StringPtrOutput {
	return ToOutput(in).(StringPtrOutput)
}

func (in *stringPtr) ToStringPtrOutputWithContext(ctx context.Context) StringPtrOutput {
	return ToOutputWithContext(ctx, in).(StringPtrOutput)
}

// StringPtrOutput is an Output that returns *string values.
type StringPtrOutput struct{ *OutputState }

func (StringPtrOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*string] {
	return pulumix.Output[*string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (*string).
func (StringPtrOutput) ElementType() reflect.Type {
	return stringPtrType
}

func (o StringPtrOutput) ToStringPtrOutput() StringPtrOutput {
	return o
}

func (o StringPtrOutput) ToStringPtrOutputWithContext(ctx context.Context) StringPtrOutput {
	return o
}

// Elem dereferences the pointer value or returns the zero value of the approporiate type if the pointer is nil.
func (o StringPtrOutput) Elem() StringOutput {
	return o.ApplyT(func(v *string) string {
		var ret string
		if v != nil {
			ret = *v
		}
		return ret
	}).(StringOutput)
}

var stringArrayType = reflect.TypeOf((*[]string)(nil)).Elem()

// StringArrayInput is an input type that accepts StringArray and StringArrayOutput values.
type StringArrayInput interface {
	Input

	ToStringArrayOutput() StringArrayOutput
	ToStringArrayOutputWithContext(ctx context.Context) StringArrayOutput
}

// StringArray is an input type for []StringInput values.
type StringArray []StringInput

// ElementType returns the element type of this Input ([]string).
func (StringArray) ElementType() reflect.Type {
	return stringArrayType
}

func (in StringArray) ToOutput(ctx context.Context) pulumix.Output[[]string] {
	return pulumix.Output[[]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringArray) ToStringArrayOutput() StringArrayOutput {
	return ToOutput(in).(StringArrayOutput)
}

func (in StringArray) ToStringArrayOutputWithContext(ctx context.Context) StringArrayOutput {
	return ToOutputWithContext(ctx, in).(StringArrayOutput)
}

// StringArrayOutput is an Output that returns []string values.
type StringArrayOutput struct{ *OutputState }

func (StringArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]string] {
	return pulumix.Output[[]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]string).
func (StringArrayOutput) ElementType() reflect.Type {
	return stringArrayType
}

func (o StringArrayOutput) ToStringArrayOutput() StringArrayOutput {
	return o
}

func (o StringArrayOutput) ToStringArrayOutputWithContext(ctx context.Context) StringArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o StringArrayOutput) Index(i IntInput) StringOutput {
	return All(o, i).ApplyT(func(vs []any) string {
		arr := vs[0].([]string)
		idx := vs[1].(int)
		var ret string
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(StringOutput)
}

func ToStringArray(in []string) StringArray {
	a := make(StringArray, len(in))
	for i, v := range in {
		a[i] = String(v)
	}
	return a
}

func ToStringArrayOutput(in []StringOutput) StringArrayOutput {
	a := make(StringArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToStringArrayOutput()
}

var stringMapType = reflect.TypeOf((*map[string]string)(nil)).Elem()

// StringMapInput is an input type that accepts StringMap and StringMapOutput values.
type StringMapInput interface {
	Input

	ToStringMapOutput() StringMapOutput
	ToStringMapOutputWithContext(ctx context.Context) StringMapOutput
}

// StringMap is an input type for map[string]StringInput values.
type StringMap map[string]StringInput

// ElementType returns the element type of this Input (map[string]string).
func (StringMap) ElementType() reflect.Type {
	return stringMapType
}

func (in StringMap) ToOutput(ctx context.Context) pulumix.Output[map[string]string] {
	return pulumix.Output[map[string]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringMap) ToStringMapOutput() StringMapOutput {
	return ToOutput(in).(StringMapOutput)
}

func (in StringMap) ToStringMapOutputWithContext(ctx context.Context) StringMapOutput {
	return ToOutputWithContext(ctx, in).(StringMapOutput)
}

// StringMapOutput is an Output that returns map[string]string values.
type StringMapOutput struct{ *OutputState }

func (StringMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]string] {
	return pulumix.Output[map[string]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]string).
func (StringMapOutput) ElementType() reflect.Type {
	return stringMapType
}

func (o StringMapOutput) ToStringMapOutput() StringMapOutput {
	return o
}

func (o StringMapOutput) ToStringMapOutputWithContext(ctx context.Context) StringMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o StringMapOutput) MapIndex(k StringInput) StringOutput {
	return All(o, k).ApplyT(func(vs []any) string {
		return vs[0].(map[string]string)[vs[1].(string)]
	}).(StringOutput)
}

func ToStringMap(in map[string]string) StringMap {
	m := make(StringMap)
	for k, v := range in {
		m[k] = String(v)
	}
	return m
}

func ToStringMapOutput(in map[string]StringOutput) StringMapOutput {
	m := make(StringMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToStringMapOutput()
}

var stringArrayMapType = reflect.TypeOf((*map[string][]string)(nil)).Elem()

// StringArrayMapInput is an input type that accepts StringArrayMap and StringArrayMapOutput values.
type StringArrayMapInput interface {
	Input

	ToStringArrayMapOutput() StringArrayMapOutput
	ToStringArrayMapOutputWithContext(ctx context.Context) StringArrayMapOutput
}

// StringArrayMap is an input type for map[string]StringArrayInput values.
type StringArrayMap map[string]StringArrayInput

// ElementType returns the element type of this Input (map[string][]string).
func (StringArrayMap) ElementType() reflect.Type {
	return stringArrayMapType
}

func (in StringArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]string] {
	return pulumix.Output[map[string][]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringArrayMap) ToStringArrayMapOutput() StringArrayMapOutput {
	return ToOutput(in).(StringArrayMapOutput)
}

func (in StringArrayMap) ToStringArrayMapOutputWithContext(ctx context.Context) StringArrayMapOutput {
	return ToOutputWithContext(ctx, in).(StringArrayMapOutput)
}

// StringArrayMapOutput is an Output that returns map[string][]string values.
type StringArrayMapOutput struct{ *OutputState }

func (StringArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]string] {
	return pulumix.Output[map[string][]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]string).
func (StringArrayMapOutput) ElementType() reflect.Type {
	return stringArrayMapType
}

func (o StringArrayMapOutput) ToStringArrayMapOutput() StringArrayMapOutput {
	return o
}

func (o StringArrayMapOutput) ToStringArrayMapOutputWithContext(ctx context.Context) StringArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o StringArrayMapOutput) MapIndex(k StringInput) StringArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []string {
		return vs[0].(map[string][]string)[vs[1].(string)]
	}).(StringArrayOutput)
}

func ToStringArrayMap(in map[string][]string) StringArrayMap {
	m := make(StringArrayMap)
	for k, v := range in {
		m[k] = ToStringArray(v)
	}
	return m
}

func ToStringArrayMapOutput(in map[string]StringArrayOutput) StringArrayMapOutput {
	m := make(StringArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToStringArrayMapOutput()
}

var stringMapArrayType = reflect.TypeOf((*[]map[string]string)(nil)).Elem()

// StringMapArrayInput is an input type that accepts StringMapArray and StringMapArrayOutput values.
type StringMapArrayInput interface {
	Input

	ToStringMapArrayOutput() StringMapArrayOutput
	ToStringMapArrayOutputWithContext(ctx context.Context) StringMapArrayOutput
}

// StringMapArray is an input type for []StringMapInput values.
type StringMapArray []StringMapInput

// ElementType returns the element type of this Input ([]map[string]string).
func (StringMapArray) ElementType() reflect.Type {
	return stringMapArrayType
}

func (in StringMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]string] {
	return pulumix.Output[[]map[string]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringMapArray) ToStringMapArrayOutput() StringMapArrayOutput {
	return ToOutput(in).(StringMapArrayOutput)
}

func (in StringMapArray) ToStringMapArrayOutputWithContext(ctx context.Context) StringMapArrayOutput {
	return ToOutputWithContext(ctx, in).(StringMapArrayOutput)
}

// StringMapArrayOutput is an Output that returns []map[string]string values.
type StringMapArrayOutput struct{ *OutputState }

func (StringMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]string] {
	return pulumix.Output[[]map[string]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]string).
func (StringMapArrayOutput) ElementType() reflect.Type {
	return stringMapArrayType
}

func (o StringMapArrayOutput) ToStringMapArrayOutput() StringMapArrayOutput {
	return o
}

func (o StringMapArrayOutput) ToStringMapArrayOutputWithContext(ctx context.Context) StringMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o StringMapArrayOutput) Index(i IntInput) StringMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]string {
		arr := vs[0].([]map[string]string)
		idx := vs[1].(int)
		var ret map[string]string
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(StringMapOutput)
}

func ToStringMapArray(in []map[string]string) StringMapArray {
	a := make(StringMapArray, len(in))
	for i, v := range in {
		a[i] = ToStringMap(v)
	}
	return a
}

func ToStringMapArrayOutput(in []StringMapOutput) StringMapArrayOutput {
	a := make(StringMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToStringMapArrayOutput()
}

var stringMapMapType = reflect.TypeOf((*map[string]map[string]string)(nil)).Elem()

// StringMapMapInput is an input type that accepts StringMapMap and StringMapMapOutput values.
type StringMapMapInput interface {
	Input

	ToStringMapMapOutput() StringMapMapOutput
	ToStringMapMapOutputWithContext(ctx context.Context) StringMapMapOutput
}

// StringMapMap is an input type for map[string]StringMapInput values.
type StringMapMap map[string]StringMapInput

// ElementType returns the element type of this Input (map[string]map[string]string).
func (StringMapMap) ElementType() reflect.Type {
	return stringMapMapType
}

func (in StringMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]string] {
	return pulumix.Output[map[string]map[string]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringMapMap) ToStringMapMapOutput() StringMapMapOutput {
	return ToOutput(in).(StringMapMapOutput)
}

func (in StringMapMap) ToStringMapMapOutputWithContext(ctx context.Context) StringMapMapOutput {
	return ToOutputWithContext(ctx, in).(StringMapMapOutput)
}

// StringMapMapOutput is an Output that returns map[string]map[string]string values.
type StringMapMapOutput struct{ *OutputState }

func (StringMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]string] {
	return pulumix.Output[map[string]map[string]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]string).
func (StringMapMapOutput) ElementType() reflect.Type {
	return stringMapMapType
}

func (o StringMapMapOutput) ToStringMapMapOutput() StringMapMapOutput {
	return o
}

func (o StringMapMapOutput) ToStringMapMapOutputWithContext(ctx context.Context) StringMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o StringMapMapOutput) MapIndex(k StringInput) StringMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]string {
		return vs[0].(map[string]map[string]string)[vs[1].(string)]
	}).(StringMapOutput)
}

func ToStringMapMap(in map[string]map[string]string) StringMapMap {
	m := make(StringMapMap)
	for k, v := range in {
		m[k] = ToStringMap(v)
	}
	return m
}

func ToStringMapMapOutput(in map[string]StringMapOutput) StringMapMapOutput {
	m := make(StringMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToStringMapMapOutput()
}

var stringArrayArrayType = reflect.TypeOf((*[][]string)(nil)).Elem()

// StringArrayArrayInput is an input type that accepts StringArrayArray and StringArrayArrayOutput values.
type StringArrayArrayInput interface {
	Input

	ToStringArrayArrayOutput() StringArrayArrayOutput
	ToStringArrayArrayOutputWithContext(ctx context.Context) StringArrayArrayOutput
}

// StringArrayArray is an input type for []StringArrayInput values.
type StringArrayArray []StringArrayInput

// ElementType returns the element type of this Input ([][]string).
func (StringArrayArray) ElementType() reflect.Type {
	return stringArrayArrayType
}

func (in StringArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][]string] {
	return pulumix.Output[[][]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringArrayArray) ToStringArrayArrayOutput() StringArrayArrayOutput {
	return ToOutput(in).(StringArrayArrayOutput)
}

func (in StringArrayArray) ToStringArrayArrayOutputWithContext(ctx context.Context) StringArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(StringArrayArrayOutput)
}

// StringArrayArrayOutput is an Output that returns [][]string values.
type StringArrayArrayOutput struct{ *OutputState }

func (StringArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][]string] {
	return pulumix.Output[[][]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][]string).
func (StringArrayArrayOutput) ElementType() reflect.Type {
	return stringArrayArrayType
}

func (o StringArrayArrayOutput) ToStringArrayArrayOutput() StringArrayArrayOutput {
	return o
}

func (o StringArrayArrayOutput) ToStringArrayArrayOutputWithContext(ctx context.Context) StringArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o StringArrayArrayOutput) Index(i IntInput) StringArrayOutput {
	return All(o, i).ApplyT(func(vs []any) []string {
		arr := vs[0].([][]string)
		idx := vs[1].(int)
		var ret []string
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(StringArrayOutput)
}

func ToStringArrayArray(in [][]string) StringArrayArray {
	a := make(StringArrayArray, len(in))
	for i, v := range in {
		a[i] = ToStringArray(v)
	}
	return a
}

func ToStringArrayArrayOutput(in []StringArrayOutput) StringArrayArrayOutput {
	a := make(StringArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToStringArrayArrayOutput()
}

var stringArrayMapMapType = reflect.TypeOf((*map[string]map[string][]string)(nil)).Elem()

// StringArrayMapMapInput is an input type that accepts StringArrayMapMap and StringArrayMapMapOutput values.
type StringArrayMapMapInput interface {
	Input

	ToStringArrayMapMapOutput() StringArrayMapMapOutput
	ToStringArrayMapMapOutputWithContext(ctx context.Context) StringArrayMapMapOutput
}

// StringArrayMapMap is an input type for map[string]StringArrayMapInput values.
type StringArrayMapMap map[string]StringArrayMapInput

// ElementType returns the element type of this Input (map[string]map[string][]string).
func (StringArrayMapMap) ElementType() reflect.Type {
	return stringArrayMapMapType
}

func (in StringArrayMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]string] {
	return pulumix.Output[map[string]map[string][]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringArrayMapMap) ToStringArrayMapMapOutput() StringArrayMapMapOutput {
	return ToOutput(in).(StringArrayMapMapOutput)
}

func (in StringArrayMapMap) ToStringArrayMapMapOutputWithContext(ctx context.Context) StringArrayMapMapOutput {
	return ToOutputWithContext(ctx, in).(StringArrayMapMapOutput)
}

// StringArrayMapMapOutput is an Output that returns map[string]map[string][]string values.
type StringArrayMapMapOutput struct{ *OutputState }

func (StringArrayMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringArrayMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]string] {
	return pulumix.Output[map[string]map[string][]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string][]string).
func (StringArrayMapMapOutput) ElementType() reflect.Type {
	return stringArrayMapMapType
}

func (o StringArrayMapMapOutput) ToStringArrayMapMapOutput() StringArrayMapMapOutput {
	return o
}

func (o StringArrayMapMapOutput) ToStringArrayMapMapOutputWithContext(ctx context.Context) StringArrayMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o StringArrayMapMapOutput) MapIndex(k StringInput) StringArrayMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string][]string {
		return vs[0].(map[string]map[string][]string)[vs[1].(string)]
	}).(StringArrayMapOutput)
}

func ToStringArrayMapMap(in map[string]map[string][]string) StringArrayMapMap {
	m := make(StringArrayMapMap)
	for k, v := range in {
		m[k] = ToStringArrayMap(v)
	}
	return m
}

func ToStringArrayMapMapOutput(in map[string]StringArrayMapOutput) StringArrayMapMapOutput {
	m := make(StringArrayMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToStringArrayMapMapOutput()
}

var stringMapArrayMapType = reflect.TypeOf((*map[string][]map[string]string)(nil)).Elem()

// StringMapArrayMapInput is an input type that accepts StringMapArrayMap and StringMapArrayMapOutput values.
type StringMapArrayMapInput interface {
	Input

	ToStringMapArrayMapOutput() StringMapArrayMapOutput
	ToStringMapArrayMapOutputWithContext(ctx context.Context) StringMapArrayMapOutput
}

// StringMapArrayMap is an input type for map[string]StringMapArrayInput values.
type StringMapArrayMap map[string]StringMapArrayInput

// ElementType returns the element type of this Input (map[string][]map[string]string).
func (StringMapArrayMap) ElementType() reflect.Type {
	return stringMapArrayMapType
}

func (in StringMapArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]string] {
	return pulumix.Output[map[string][]map[string]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringMapArrayMap) ToStringMapArrayMapOutput() StringMapArrayMapOutput {
	return ToOutput(in).(StringMapArrayMapOutput)
}

func (in StringMapArrayMap) ToStringMapArrayMapOutputWithContext(ctx context.Context) StringMapArrayMapOutput {
	return ToOutputWithContext(ctx, in).(StringMapArrayMapOutput)
}

// StringMapArrayMapOutput is an Output that returns map[string][]map[string]string values.
type StringMapArrayMapOutput struct{ *OutputState }

func (StringMapArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringMapArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]string] {
	return pulumix.Output[map[string][]map[string]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]map[string]string).
func (StringMapArrayMapOutput) ElementType() reflect.Type {
	return stringMapArrayMapType
}

func (o StringMapArrayMapOutput) ToStringMapArrayMapOutput() StringMapArrayMapOutput {
	return o
}

func (o StringMapArrayMapOutput) ToStringMapArrayMapOutputWithContext(ctx context.Context) StringMapArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o StringMapArrayMapOutput) MapIndex(k StringInput) StringMapArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []map[string]string {
		return vs[0].(map[string][]map[string]string)[vs[1].(string)]
	}).(StringMapArrayOutput)
}

func ToStringMapArrayMap(in map[string][]map[string]string) StringMapArrayMap {
	m := make(StringMapArrayMap)
	for k, v := range in {
		m[k] = ToStringMapArray(v)
	}
	return m
}

func ToStringMapArrayMapOutput(in map[string]StringMapArrayOutput) StringMapArrayMapOutput {
	m := make(StringMapArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToStringMapArrayMapOutput()
}

var stringMapMapArrayType = reflect.TypeOf((*[]map[string]map[string]string)(nil)).Elem()

// StringMapMapArrayInput is an input type that accepts StringMapMapArray and StringMapMapArrayOutput values.
type StringMapMapArrayInput interface {
	Input

	ToStringMapMapArrayOutput() StringMapMapArrayOutput
	ToStringMapMapArrayOutputWithContext(ctx context.Context) StringMapMapArrayOutput
}

// StringMapMapArray is an input type for []StringMapMapInput values.
type StringMapMapArray []StringMapMapInput

// ElementType returns the element type of this Input ([]map[string]map[string]string).
func (StringMapMapArray) ElementType() reflect.Type {
	return stringMapMapArrayType
}

func (in StringMapMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]string] {
	return pulumix.Output[[]map[string]map[string]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringMapMapArray) ToStringMapMapArrayOutput() StringMapMapArrayOutput {
	return ToOutput(in).(StringMapMapArrayOutput)
}

func (in StringMapMapArray) ToStringMapMapArrayOutputWithContext(ctx context.Context) StringMapMapArrayOutput {
	return ToOutputWithContext(ctx, in).(StringMapMapArrayOutput)
}

// StringMapMapArrayOutput is an Output that returns []map[string]map[string]string values.
type StringMapMapArrayOutput struct{ *OutputState }

func (StringMapMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringMapMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]string] {
	return pulumix.Output[[]map[string]map[string]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]map[string]string).
func (StringMapMapArrayOutput) ElementType() reflect.Type {
	return stringMapMapArrayType
}

func (o StringMapMapArrayOutput) ToStringMapMapArrayOutput() StringMapMapArrayOutput {
	return o
}

func (o StringMapMapArrayOutput) ToStringMapMapArrayOutputWithContext(ctx context.Context) StringMapMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o StringMapMapArrayOutput) Index(i IntInput) StringMapMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]map[string]string {
		arr := vs[0].([]map[string]map[string]string)
		idx := vs[1].(int)
		var ret map[string]map[string]string
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(StringMapMapOutput)
}

func ToStringMapMapArray(in []map[string]map[string]string) StringMapMapArray {
	a := make(StringMapMapArray, len(in))
	for i, v := range in {
		a[i] = ToStringMapMap(v)
	}
	return a
}

func ToStringMapMapArrayOutput(in []StringMapMapOutput) StringMapMapArrayOutput {
	a := make(StringMapMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToStringMapMapArrayOutput()
}

var stringArrayMapArrayType = reflect.TypeOf((*[]map[string][]string)(nil)).Elem()

// StringArrayMapArrayInput is an input type that accepts StringArrayMapArray and StringArrayMapArrayOutput values.
type StringArrayMapArrayInput interface {
	Input

	ToStringArrayMapArrayOutput() StringArrayMapArrayOutput
	ToStringArrayMapArrayOutputWithContext(ctx context.Context) StringArrayMapArrayOutput
}

// StringArrayMapArray is an input type for []StringArrayMapInput values.
type StringArrayMapArray []StringArrayMapInput

// ElementType returns the element type of this Input ([]map[string][]string).
func (StringArrayMapArray) ElementType() reflect.Type {
	return stringArrayMapArrayType
}

func (in StringArrayMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]string] {
	return pulumix.Output[[]map[string][]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringArrayMapArray) ToStringArrayMapArrayOutput() StringArrayMapArrayOutput {
	return ToOutput(in).(StringArrayMapArrayOutput)
}

func (in StringArrayMapArray) ToStringArrayMapArrayOutputWithContext(ctx context.Context) StringArrayMapArrayOutput {
	return ToOutputWithContext(ctx, in).(StringArrayMapArrayOutput)
}

// StringArrayMapArrayOutput is an Output that returns []map[string][]string values.
type StringArrayMapArrayOutput struct{ *OutputState }

func (StringArrayMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringArrayMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]string] {
	return pulumix.Output[[]map[string][]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string][]string).
func (StringArrayMapArrayOutput) ElementType() reflect.Type {
	return stringArrayMapArrayType
}

func (o StringArrayMapArrayOutput) ToStringArrayMapArrayOutput() StringArrayMapArrayOutput {
	return o
}

func (o StringArrayMapArrayOutput) ToStringArrayMapArrayOutputWithContext(ctx context.Context) StringArrayMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o StringArrayMapArrayOutput) Index(i IntInput) StringArrayMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string][]string {
		arr := vs[0].([]map[string][]string)
		idx := vs[1].(int)
		var ret map[string][]string
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(StringArrayMapOutput)
}

func ToStringArrayMapArray(in []map[string][]string) StringArrayMapArray {
	a := make(StringArrayMapArray, len(in))
	for i, v := range in {
		a[i] = ToStringArrayMap(v)
	}
	return a
}

func ToStringArrayMapArrayOutput(in []StringArrayMapOutput) StringArrayMapArrayOutput {
	a := make(StringArrayMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToStringArrayMapArrayOutput()
}

var stringArrayArrayMapType = reflect.TypeOf((*map[string][][]string)(nil)).Elem()

// StringArrayArrayMapInput is an input type that accepts StringArrayArrayMap and StringArrayArrayMapOutput values.
type StringArrayArrayMapInput interface {
	Input

	ToStringArrayArrayMapOutput() StringArrayArrayMapOutput
	ToStringArrayArrayMapOutputWithContext(ctx context.Context) StringArrayArrayMapOutput
}

// StringArrayArrayMap is an input type for map[string]StringArrayArrayInput values.
type StringArrayArrayMap map[string]StringArrayArrayInput

// ElementType returns the element type of this Input (map[string][][]string).
func (StringArrayArrayMap) ElementType() reflect.Type {
	return stringArrayArrayMapType
}

func (in StringArrayArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][][]string] {
	return pulumix.Output[map[string][][]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringArrayArrayMap) ToStringArrayArrayMapOutput() StringArrayArrayMapOutput {
	return ToOutput(in).(StringArrayArrayMapOutput)
}

func (in StringArrayArrayMap) ToStringArrayArrayMapOutputWithContext(ctx context.Context) StringArrayArrayMapOutput {
	return ToOutputWithContext(ctx, in).(StringArrayArrayMapOutput)
}

// StringArrayArrayMapOutput is an Output that returns map[string][][]string values.
type StringArrayArrayMapOutput struct{ *OutputState }

func (StringArrayArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringArrayArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][][]string] {
	return pulumix.Output[map[string][][]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][][]string).
func (StringArrayArrayMapOutput) ElementType() reflect.Type {
	return stringArrayArrayMapType
}

func (o StringArrayArrayMapOutput) ToStringArrayArrayMapOutput() StringArrayArrayMapOutput {
	return o
}

func (o StringArrayArrayMapOutput) ToStringArrayArrayMapOutputWithContext(ctx context.Context) StringArrayArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o StringArrayArrayMapOutput) MapIndex(k StringInput) StringArrayArrayOutput {
	return All(o, k).ApplyT(func(vs []any) [][]string {
		return vs[0].(map[string][][]string)[vs[1].(string)]
	}).(StringArrayArrayOutput)
}

func ToStringArrayArrayMap(in map[string][][]string) StringArrayArrayMap {
	m := make(StringArrayArrayMap)
	for k, v := range in {
		m[k] = ToStringArrayArray(v)
	}
	return m
}

func ToStringArrayArrayMapOutput(in map[string]StringArrayArrayOutput) StringArrayArrayMapOutput {
	m := make(StringArrayArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToStringArrayArrayMapOutput()
}

var stringArrayArrayArrayType = reflect.TypeOf((*[][][]string)(nil)).Elem()

// StringArrayArrayArrayInput is an input type that accepts StringArrayArrayArray and StringArrayArrayArrayOutput values.
type StringArrayArrayArrayInput interface {
	Input

	ToStringArrayArrayArrayOutput() StringArrayArrayArrayOutput
	ToStringArrayArrayArrayOutputWithContext(ctx context.Context) StringArrayArrayArrayOutput
}

// StringArrayArrayArray is an input type for []StringArrayArrayInput values.
type StringArrayArrayArray []StringArrayArrayInput

// ElementType returns the element type of this Input ([][][]string).
func (StringArrayArrayArray) ElementType() reflect.Type {
	return stringArrayArrayArrayType
}

func (in StringArrayArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][][]string] {
	return pulumix.Output[[][][]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringArrayArrayArray) ToStringArrayArrayArrayOutput() StringArrayArrayArrayOutput {
	return ToOutput(in).(StringArrayArrayArrayOutput)
}

func (in StringArrayArrayArray) ToStringArrayArrayArrayOutputWithContext(ctx context.Context) StringArrayArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(StringArrayArrayArrayOutput)
}

// StringArrayArrayArrayOutput is an Output that returns [][][]string values.
type StringArrayArrayArrayOutput struct{ *OutputState }

func (StringArrayArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringArrayArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][][]string] {
	return pulumix.Output[[][][]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][][]string).
func (StringArrayArrayArrayOutput) ElementType() reflect.Type {
	return stringArrayArrayArrayType
}

func (o StringArrayArrayArrayOutput) ToStringArrayArrayArrayOutput() StringArrayArrayArrayOutput {
	return o
}

func (o StringArrayArrayArrayOutput) ToStringArrayArrayArrayOutputWithContext(ctx context.Context) StringArrayArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o StringArrayArrayArrayOutput) Index(i IntInput) StringArrayArrayOutput {
	return All(o, i).ApplyT(func(vs []any) [][]string {
		arr := vs[0].([][][]string)
		idx := vs[1].(int)
		var ret [][]string
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(StringArrayArrayOutput)
}

func ToStringArrayArrayArray(in [][][]string) StringArrayArrayArray {
	a := make(StringArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = ToStringArrayArray(v)
	}
	return a
}

func ToStringArrayArrayArrayOutput(in []StringArrayArrayOutput) StringArrayArrayArrayOutput {
	a := make(StringArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToStringArrayArrayArrayOutput()
}

var stringMapMapMapType = reflect.TypeOf((*map[string]map[string]map[string]string)(nil)).Elem()

// StringMapMapMapInput is an input type that accepts StringMapMapMap and StringMapMapMapOutput values.
type StringMapMapMapInput interface {
	Input

	ToStringMapMapMapOutput() StringMapMapMapOutput
	ToStringMapMapMapOutputWithContext(ctx context.Context) StringMapMapMapOutput
}

// StringMapMapMap is an input type for map[string]StringMapMapInput values.
type StringMapMapMap map[string]StringMapMapInput

// ElementType returns the element type of this Input (map[string]map[string]map[string]string).
func (StringMapMapMap) ElementType() reflect.Type {
	return stringMapMapMapType
}

func (in StringMapMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]string] {
	return pulumix.Output[map[string]map[string]map[string]string]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in StringMapMapMap) ToStringMapMapMapOutput() StringMapMapMapOutput {
	return ToOutput(in).(StringMapMapMapOutput)
}

func (in StringMapMapMap) ToStringMapMapMapOutputWithContext(ctx context.Context) StringMapMapMapOutput {
	return ToOutputWithContext(ctx, in).(StringMapMapMapOutput)
}

// StringMapMapMapOutput is an Output that returns map[string]map[string]map[string]string values.
type StringMapMapMapOutput struct{ *OutputState }

func (StringMapMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o StringMapMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]string] {
	return pulumix.Output[map[string]map[string]map[string]string]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]map[string]string).
func (StringMapMapMapOutput) ElementType() reflect.Type {
	return stringMapMapMapType
}

func (o StringMapMapMapOutput) ToStringMapMapMapOutput() StringMapMapMapOutput {
	return o
}

func (o StringMapMapMapOutput) ToStringMapMapMapOutputWithContext(ctx context.Context) StringMapMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o StringMapMapMapOutput) MapIndex(k StringInput) StringMapMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]map[string]string {
		return vs[0].(map[string]map[string]map[string]string)[vs[1].(string)]
	}).(StringMapMapOutput)
}

func ToStringMapMapMap(in map[string]map[string]map[string]string) StringMapMapMap {
	m := make(StringMapMapMap)
	for k, v := range in {
		m[k] = ToStringMapMap(v)
	}
	return m
}

func ToStringMapMapMapOutput(in map[string]StringMapMapOutput) StringMapMapMapOutput {
	m := make(StringMapMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToStringMapMapMapOutput()
}

var urnType = reflect.TypeOf((*URN)(nil)).Elem()

// URNInput is an input type that accepts URN and URNOutput values.
type URNInput interface {
	Input

	ToURNOutput() URNOutput
	ToURNOutputWithContext(ctx context.Context) URNOutput

	ToURNPtrOutput() URNPtrOutput
	ToURNPtrOutputWithContext(ctx context.Context) URNPtrOutput
}

// ElementType returns the element type of this Input (URN).
func (URN) ElementType() reflect.Type {
	return urnType
}

func (in URN) ToOutput(ctx context.Context) pulumix.Output[URN] {
	return pulumix.Output[URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URN) ToURNOutput() URNOutput {
	return ToOutput(in).(URNOutput)
}

func (in URN) ToURNOutputWithContext(ctx context.Context) URNOutput {
	return ToOutputWithContext(ctx, in).(URNOutput)
}

func (in URN) ToStringOutput() StringOutput {
	return in.ToStringOutputWithContext(context.Background())
}

func (in URN) ToStringOutputWithContext(ctx context.Context) StringOutput {
	return in.ToURNOutputWithContext(ctx).ToStringOutputWithContext(ctx)
}

func (in URN) ToURNPtrOutput() URNPtrOutput {
	return in.ToURNPtrOutputWithContext(context.Background())
}

func (in URN) ToURNPtrOutputWithContext(ctx context.Context) URNPtrOutput {
	return in.ToURNOutputWithContext(ctx).ToURNPtrOutputWithContext(ctx)
}

// URNOutput is an Output that returns URN values.
type URNOutput struct{ *OutputState }

func (URNOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNOutput) ToOutput(ctx context.Context) pulumix.Output[URN] {
	return pulumix.Output[URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (URN).
func (URNOutput) ElementType() reflect.Type {
	return urnType
}

func (o URNOutput) ToURNOutput() URNOutput {
	return o
}

func (o URNOutput) ToURNOutputWithContext(ctx context.Context) URNOutput {
	return o
}

func (o URNOutput) ToStringOutput() StringOutput {
	return o.ToStringOutputWithContext(context.Background())
}

func (o URNOutput) ToStringOutputWithContext(ctx context.Context) StringOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v URN) string {
		return (string)(v)
	}).(StringOutput)
}

func (o URNOutput) ToURNPtrOutput() URNPtrOutput {
	return o.ToURNPtrOutputWithContext(context.Background())
}

func (o URNOutput) ToURNPtrOutputWithContext(ctx context.Context) URNPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v URN) *URN {
		return &v
	}).(URNPtrOutput)
}

var uRNPtrType = reflect.TypeOf((**URN)(nil)).Elem()

// URNPtrInput is an input type that accepts URNPtr and URNPtrOutput values.
type URNPtrInput interface {
	Input

	ToURNPtrOutput() URNPtrOutput
	ToURNPtrOutputWithContext(ctx context.Context) URNPtrOutput
}

type urnPtr URN

// URNPtr is an input type for *URN values.
func URNPtr(v URN) URNPtrInput {
	return (*urnPtr)(&v)
}

func URNPtrFromPtr(v *URN) URNPtrInput {
	if v == nil {
		return nil
	}
	return (*urnPtr)(v)
}

// ElementType returns the element type of this Input (*URN).
func (*urnPtr) ElementType() reflect.Type {
	return uRNPtrType
}

func (in *urnPtr) ToOutput(ctx context.Context) pulumix.Output[*URN] {
	return pulumix.Output[*URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in *urnPtr) ToURNPtrOutput() URNPtrOutput {
	return ToOutput(in).(URNPtrOutput)
}

func (in *urnPtr) ToURNPtrOutputWithContext(ctx context.Context) URNPtrOutput {
	return ToOutputWithContext(ctx, in).(URNPtrOutput)
}

// URNPtrOutput is an Output that returns *URN values.
type URNPtrOutput struct{ *OutputState }

func (URNPtrOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*URN] {
	return pulumix.Output[*URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (*URN).
func (URNPtrOutput) ElementType() reflect.Type {
	return uRNPtrType
}

func (o URNPtrOutput) ToURNPtrOutput() URNPtrOutput {
	return o
}

func (o URNPtrOutput) ToURNPtrOutputWithContext(ctx context.Context) URNPtrOutput {
	return o
}

// Elem dereferences the pointer value or returns the zero value of the approporiate type if the pointer is nil.
func (o URNPtrOutput) Elem() URNOutput {
	return o.ApplyT(func(v *URN) URN {
		var ret URN
		if v != nil {
			ret = *v
		}
		return ret
	}).(URNOutput)
}

var uRNArrayType = reflect.TypeOf((*[]URN)(nil)).Elem()

// URNArrayInput is an input type that accepts URNArray and URNArrayOutput values.
type URNArrayInput interface {
	Input

	ToURNArrayOutput() URNArrayOutput
	ToURNArrayOutputWithContext(ctx context.Context) URNArrayOutput
}

// URNArray is an input type for []URNInput values.
type URNArray []URNInput

// ElementType returns the element type of this Input ([]URN).
func (URNArray) ElementType() reflect.Type {
	return uRNArrayType
}

func (in URNArray) ToOutput(ctx context.Context) pulumix.Output[[]URN] {
	return pulumix.Output[[]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNArray) ToURNArrayOutput() URNArrayOutput {
	return ToOutput(in).(URNArrayOutput)
}

func (in URNArray) ToURNArrayOutputWithContext(ctx context.Context) URNArrayOutput {
	return ToOutputWithContext(ctx, in).(URNArrayOutput)
}

// URNArrayOutput is an Output that returns []URN values.
type URNArrayOutput struct{ *OutputState }

func (URNArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]URN] {
	return pulumix.Output[[]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]URN).
func (URNArrayOutput) ElementType() reflect.Type {
	return uRNArrayType
}

func (o URNArrayOutput) ToURNArrayOutput() URNArrayOutput {
	return o
}

func (o URNArrayOutput) ToURNArrayOutputWithContext(ctx context.Context) URNArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o URNArrayOutput) Index(i IntInput) URNOutput {
	return All(o, i).ApplyT(func(vs []any) URN {
		arr := vs[0].([]URN)
		idx := vs[1].(int)
		var ret URN
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(URNOutput)
}

func ToURNArray(in []URN) URNArray {
	a := make(URNArray, len(in))
	for i, v := range in {
		a[i] = (v)
	}
	return a
}

func ToURNArrayOutput(in []URNOutput) URNArrayOutput {
	a := make(URNArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToURNArrayOutput()
}

var uRNMapType = reflect.TypeOf((*map[string]URN)(nil)).Elem()

// URNMapInput is an input type that accepts URNMap and URNMapOutput values.
type URNMapInput interface {
	Input

	ToURNMapOutput() URNMapOutput
	ToURNMapOutputWithContext(ctx context.Context) URNMapOutput
}

// URNMap is an input type for map[string]URNInput values.
type URNMap map[string]URNInput

// ElementType returns the element type of this Input (map[string]URN).
func (URNMap) ElementType() reflect.Type {
	return uRNMapType
}

func (in URNMap) ToOutput(ctx context.Context) pulumix.Output[map[string]URN] {
	return pulumix.Output[map[string]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNMap) ToURNMapOutput() URNMapOutput {
	return ToOutput(in).(URNMapOutput)
}

func (in URNMap) ToURNMapOutputWithContext(ctx context.Context) URNMapOutput {
	return ToOutputWithContext(ctx, in).(URNMapOutput)
}

// URNMapOutput is an Output that returns map[string]URN values.
type URNMapOutput struct{ *OutputState }

func (URNMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]URN] {
	return pulumix.Output[map[string]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]URN).
func (URNMapOutput) ElementType() reflect.Type {
	return uRNMapType
}

func (o URNMapOutput) ToURNMapOutput() URNMapOutput {
	return o
}

func (o URNMapOutput) ToURNMapOutputWithContext(ctx context.Context) URNMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o URNMapOutput) MapIndex(k StringInput) URNOutput {
	return All(o, k).ApplyT(func(vs []any) URN {
		return vs[0].(map[string]URN)[vs[1].(string)]
	}).(URNOutput)
}

func ToURNMap(in map[string]URN) URNMap {
	m := make(URNMap)
	for k, v := range in {
		m[k] = (v)
	}
	return m
}

func ToURNMapOutput(in map[string]URNOutput) URNMapOutput {
	m := make(URNMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToURNMapOutput()
}

var uRNArrayMapType = reflect.TypeOf((*map[string][]URN)(nil)).Elem()

// URNArrayMapInput is an input type that accepts URNArrayMap and URNArrayMapOutput values.
type URNArrayMapInput interface {
	Input

	ToURNArrayMapOutput() URNArrayMapOutput
	ToURNArrayMapOutputWithContext(ctx context.Context) URNArrayMapOutput
}

// URNArrayMap is an input type for map[string]URNArrayInput values.
type URNArrayMap map[string]URNArrayInput

// ElementType returns the element type of this Input (map[string][]URN).
func (URNArrayMap) ElementType() reflect.Type {
	return uRNArrayMapType
}

func (in URNArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]URN] {
	return pulumix.Output[map[string][]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNArrayMap) ToURNArrayMapOutput() URNArrayMapOutput {
	return ToOutput(in).(URNArrayMapOutput)
}

func (in URNArrayMap) ToURNArrayMapOutputWithContext(ctx context.Context) URNArrayMapOutput {
	return ToOutputWithContext(ctx, in).(URNArrayMapOutput)
}

// URNArrayMapOutput is an Output that returns map[string][]URN values.
type URNArrayMapOutput struct{ *OutputState }

func (URNArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]URN] {
	return pulumix.Output[map[string][]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]URN).
func (URNArrayMapOutput) ElementType() reflect.Type {
	return uRNArrayMapType
}

func (o URNArrayMapOutput) ToURNArrayMapOutput() URNArrayMapOutput {
	return o
}

func (o URNArrayMapOutput) ToURNArrayMapOutputWithContext(ctx context.Context) URNArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o URNArrayMapOutput) MapIndex(k StringInput) URNArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []URN {
		return vs[0].(map[string][]URN)[vs[1].(string)]
	}).(URNArrayOutput)
}

func ToURNArrayMap(in map[string][]URN) URNArrayMap {
	m := make(URNArrayMap)
	for k, v := range in {
		m[k] = ToURNArray(v)
	}
	return m
}

func ToURNArrayMapOutput(in map[string]URNArrayOutput) URNArrayMapOutput {
	m := make(URNArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToURNArrayMapOutput()
}

var uRNMapArrayType = reflect.TypeOf((*[]map[string]URN)(nil)).Elem()

// URNMapArrayInput is an input type that accepts URNMapArray and URNMapArrayOutput values.
type URNMapArrayInput interface {
	Input

	ToURNMapArrayOutput() URNMapArrayOutput
	ToURNMapArrayOutputWithContext(ctx context.Context) URNMapArrayOutput
}

// URNMapArray is an input type for []URNMapInput values.
type URNMapArray []URNMapInput

// ElementType returns the element type of this Input ([]map[string]URN).
func (URNMapArray) ElementType() reflect.Type {
	return uRNMapArrayType
}

func (in URNMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]URN] {
	return pulumix.Output[[]map[string]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNMapArray) ToURNMapArrayOutput() URNMapArrayOutput {
	return ToOutput(in).(URNMapArrayOutput)
}

func (in URNMapArray) ToURNMapArrayOutputWithContext(ctx context.Context) URNMapArrayOutput {
	return ToOutputWithContext(ctx, in).(URNMapArrayOutput)
}

// URNMapArrayOutput is an Output that returns []map[string]URN values.
type URNMapArrayOutput struct{ *OutputState }

func (URNMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]URN] {
	return pulumix.Output[[]map[string]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]URN).
func (URNMapArrayOutput) ElementType() reflect.Type {
	return uRNMapArrayType
}

func (o URNMapArrayOutput) ToURNMapArrayOutput() URNMapArrayOutput {
	return o
}

func (o URNMapArrayOutput) ToURNMapArrayOutputWithContext(ctx context.Context) URNMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o URNMapArrayOutput) Index(i IntInput) URNMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]URN {
		arr := vs[0].([]map[string]URN)
		idx := vs[1].(int)
		var ret map[string]URN
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(URNMapOutput)
}

func ToURNMapArray(in []map[string]URN) URNMapArray {
	a := make(URNMapArray, len(in))
	for i, v := range in {
		a[i] = ToURNMap(v)
	}
	return a
}

func ToURNMapArrayOutput(in []URNMapOutput) URNMapArrayOutput {
	a := make(URNMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToURNMapArrayOutput()
}

var uRNMapMapType = reflect.TypeOf((*map[string]map[string]URN)(nil)).Elem()

// URNMapMapInput is an input type that accepts URNMapMap and URNMapMapOutput values.
type URNMapMapInput interface {
	Input

	ToURNMapMapOutput() URNMapMapOutput
	ToURNMapMapOutputWithContext(ctx context.Context) URNMapMapOutput
}

// URNMapMap is an input type for map[string]URNMapInput values.
type URNMapMap map[string]URNMapInput

// ElementType returns the element type of this Input (map[string]map[string]URN).
func (URNMapMap) ElementType() reflect.Type {
	return uRNMapMapType
}

func (in URNMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]URN] {
	return pulumix.Output[map[string]map[string]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNMapMap) ToURNMapMapOutput() URNMapMapOutput {
	return ToOutput(in).(URNMapMapOutput)
}

func (in URNMapMap) ToURNMapMapOutputWithContext(ctx context.Context) URNMapMapOutput {
	return ToOutputWithContext(ctx, in).(URNMapMapOutput)
}

// URNMapMapOutput is an Output that returns map[string]map[string]URN values.
type URNMapMapOutput struct{ *OutputState }

func (URNMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]URN] {
	return pulumix.Output[map[string]map[string]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]URN).
func (URNMapMapOutput) ElementType() reflect.Type {
	return uRNMapMapType
}

func (o URNMapMapOutput) ToURNMapMapOutput() URNMapMapOutput {
	return o
}

func (o URNMapMapOutput) ToURNMapMapOutputWithContext(ctx context.Context) URNMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o URNMapMapOutput) MapIndex(k StringInput) URNMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]URN {
		return vs[0].(map[string]map[string]URN)[vs[1].(string)]
	}).(URNMapOutput)
}

func ToURNMapMap(in map[string]map[string]URN) URNMapMap {
	m := make(URNMapMap)
	for k, v := range in {
		m[k] = ToURNMap(v)
	}
	return m
}

func ToURNMapMapOutput(in map[string]URNMapOutput) URNMapMapOutput {
	m := make(URNMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToURNMapMapOutput()
}

var uRNArrayArrayType = reflect.TypeOf((*[][]URN)(nil)).Elem()

// URNArrayArrayInput is an input type that accepts URNArrayArray and URNArrayArrayOutput values.
type URNArrayArrayInput interface {
	Input

	ToURNArrayArrayOutput() URNArrayArrayOutput
	ToURNArrayArrayOutputWithContext(ctx context.Context) URNArrayArrayOutput
}

// URNArrayArray is an input type for []URNArrayInput values.
type URNArrayArray []URNArrayInput

// ElementType returns the element type of this Input ([][]URN).
func (URNArrayArray) ElementType() reflect.Type {
	return uRNArrayArrayType
}

func (in URNArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][]URN] {
	return pulumix.Output[[][]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNArrayArray) ToURNArrayArrayOutput() URNArrayArrayOutput {
	return ToOutput(in).(URNArrayArrayOutput)
}

func (in URNArrayArray) ToURNArrayArrayOutputWithContext(ctx context.Context) URNArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(URNArrayArrayOutput)
}

// URNArrayArrayOutput is an Output that returns [][]URN values.
type URNArrayArrayOutput struct{ *OutputState }

func (URNArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][]URN] {
	return pulumix.Output[[][]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][]URN).
func (URNArrayArrayOutput) ElementType() reflect.Type {
	return uRNArrayArrayType
}

func (o URNArrayArrayOutput) ToURNArrayArrayOutput() URNArrayArrayOutput {
	return o
}

func (o URNArrayArrayOutput) ToURNArrayArrayOutputWithContext(ctx context.Context) URNArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o URNArrayArrayOutput) Index(i IntInput) URNArrayOutput {
	return All(o, i).ApplyT(func(vs []any) []URN {
		arr := vs[0].([][]URN)
		idx := vs[1].(int)
		var ret []URN
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(URNArrayOutput)
}

func ToURNArrayArray(in [][]URN) URNArrayArray {
	a := make(URNArrayArray, len(in))
	for i, v := range in {
		a[i] = ToURNArray(v)
	}
	return a
}

func ToURNArrayArrayOutput(in []URNArrayOutput) URNArrayArrayOutput {
	a := make(URNArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToURNArrayArrayOutput()
}

var uRNArrayMapMapType = reflect.TypeOf((*map[string]map[string][]URN)(nil)).Elem()

// URNArrayMapMapInput is an input type that accepts URNArrayMapMap and URNArrayMapMapOutput values.
type URNArrayMapMapInput interface {
	Input

	ToURNArrayMapMapOutput() URNArrayMapMapOutput
	ToURNArrayMapMapOutputWithContext(ctx context.Context) URNArrayMapMapOutput
}

// URNArrayMapMap is an input type for map[string]URNArrayMapInput values.
type URNArrayMapMap map[string]URNArrayMapInput

// ElementType returns the element type of this Input (map[string]map[string][]URN).
func (URNArrayMapMap) ElementType() reflect.Type {
	return uRNArrayMapMapType
}

func (in URNArrayMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]URN] {
	return pulumix.Output[map[string]map[string][]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNArrayMapMap) ToURNArrayMapMapOutput() URNArrayMapMapOutput {
	return ToOutput(in).(URNArrayMapMapOutput)
}

func (in URNArrayMapMap) ToURNArrayMapMapOutputWithContext(ctx context.Context) URNArrayMapMapOutput {
	return ToOutputWithContext(ctx, in).(URNArrayMapMapOutput)
}

// URNArrayMapMapOutput is an Output that returns map[string]map[string][]URN values.
type URNArrayMapMapOutput struct{ *OutputState }

func (URNArrayMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNArrayMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string][]URN] {
	return pulumix.Output[map[string]map[string][]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string][]URN).
func (URNArrayMapMapOutput) ElementType() reflect.Type {
	return uRNArrayMapMapType
}

func (o URNArrayMapMapOutput) ToURNArrayMapMapOutput() URNArrayMapMapOutput {
	return o
}

func (o URNArrayMapMapOutput) ToURNArrayMapMapOutputWithContext(ctx context.Context) URNArrayMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o URNArrayMapMapOutput) MapIndex(k StringInput) URNArrayMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string][]URN {
		return vs[0].(map[string]map[string][]URN)[vs[1].(string)]
	}).(URNArrayMapOutput)
}

func ToURNArrayMapMap(in map[string]map[string][]URN) URNArrayMapMap {
	m := make(URNArrayMapMap)
	for k, v := range in {
		m[k] = ToURNArrayMap(v)
	}
	return m
}

func ToURNArrayMapMapOutput(in map[string]URNArrayMapOutput) URNArrayMapMapOutput {
	m := make(URNArrayMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToURNArrayMapMapOutput()
}

var uRNMapArrayMapType = reflect.TypeOf((*map[string][]map[string]URN)(nil)).Elem()

// URNMapArrayMapInput is an input type that accepts URNMapArrayMap and URNMapArrayMapOutput values.
type URNMapArrayMapInput interface {
	Input

	ToURNMapArrayMapOutput() URNMapArrayMapOutput
	ToURNMapArrayMapOutputWithContext(ctx context.Context) URNMapArrayMapOutput
}

// URNMapArrayMap is an input type for map[string]URNMapArrayInput values.
type URNMapArrayMap map[string]URNMapArrayInput

// ElementType returns the element type of this Input (map[string][]map[string]URN).
func (URNMapArrayMap) ElementType() reflect.Type {
	return uRNMapArrayMapType
}

func (in URNMapArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]URN] {
	return pulumix.Output[map[string][]map[string]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNMapArrayMap) ToURNMapArrayMapOutput() URNMapArrayMapOutput {
	return ToOutput(in).(URNMapArrayMapOutput)
}

func (in URNMapArrayMap) ToURNMapArrayMapOutputWithContext(ctx context.Context) URNMapArrayMapOutput {
	return ToOutputWithContext(ctx, in).(URNMapArrayMapOutput)
}

// URNMapArrayMapOutput is an Output that returns map[string][]map[string]URN values.
type URNMapArrayMapOutput struct{ *OutputState }

func (URNMapArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNMapArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][]map[string]URN] {
	return pulumix.Output[map[string][]map[string]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][]map[string]URN).
func (URNMapArrayMapOutput) ElementType() reflect.Type {
	return uRNMapArrayMapType
}

func (o URNMapArrayMapOutput) ToURNMapArrayMapOutput() URNMapArrayMapOutput {
	return o
}

func (o URNMapArrayMapOutput) ToURNMapArrayMapOutputWithContext(ctx context.Context) URNMapArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o URNMapArrayMapOutput) MapIndex(k StringInput) URNMapArrayOutput {
	return All(o, k).ApplyT(func(vs []any) []map[string]URN {
		return vs[0].(map[string][]map[string]URN)[vs[1].(string)]
	}).(URNMapArrayOutput)
}

func ToURNMapArrayMap(in map[string][]map[string]URN) URNMapArrayMap {
	m := make(URNMapArrayMap)
	for k, v := range in {
		m[k] = ToURNMapArray(v)
	}
	return m
}

func ToURNMapArrayMapOutput(in map[string]URNMapArrayOutput) URNMapArrayMapOutput {
	m := make(URNMapArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToURNMapArrayMapOutput()
}

var uRNMapMapArrayType = reflect.TypeOf((*[]map[string]map[string]URN)(nil)).Elem()

// URNMapMapArrayInput is an input type that accepts URNMapMapArray and URNMapMapArrayOutput values.
type URNMapMapArrayInput interface {
	Input

	ToURNMapMapArrayOutput() URNMapMapArrayOutput
	ToURNMapMapArrayOutputWithContext(ctx context.Context) URNMapMapArrayOutput
}

// URNMapMapArray is an input type for []URNMapMapInput values.
type URNMapMapArray []URNMapMapInput

// ElementType returns the element type of this Input ([]map[string]map[string]URN).
func (URNMapMapArray) ElementType() reflect.Type {
	return uRNMapMapArrayType
}

func (in URNMapMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]URN] {
	return pulumix.Output[[]map[string]map[string]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNMapMapArray) ToURNMapMapArrayOutput() URNMapMapArrayOutput {
	return ToOutput(in).(URNMapMapArrayOutput)
}

func (in URNMapMapArray) ToURNMapMapArrayOutputWithContext(ctx context.Context) URNMapMapArrayOutput {
	return ToOutputWithContext(ctx, in).(URNMapMapArrayOutput)
}

// URNMapMapArrayOutput is an Output that returns []map[string]map[string]URN values.
type URNMapMapArrayOutput struct{ *OutputState }

func (URNMapMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNMapMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string]map[string]URN] {
	return pulumix.Output[[]map[string]map[string]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string]map[string]URN).
func (URNMapMapArrayOutput) ElementType() reflect.Type {
	return uRNMapMapArrayType
}

func (o URNMapMapArrayOutput) ToURNMapMapArrayOutput() URNMapMapArrayOutput {
	return o
}

func (o URNMapMapArrayOutput) ToURNMapMapArrayOutputWithContext(ctx context.Context) URNMapMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o URNMapMapArrayOutput) Index(i IntInput) URNMapMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string]map[string]URN {
		arr := vs[0].([]map[string]map[string]URN)
		idx := vs[1].(int)
		var ret map[string]map[string]URN
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(URNMapMapOutput)
}

func ToURNMapMapArray(in []map[string]map[string]URN) URNMapMapArray {
	a := make(URNMapMapArray, len(in))
	for i, v := range in {
		a[i] = ToURNMapMap(v)
	}
	return a
}

func ToURNMapMapArrayOutput(in []URNMapMapOutput) URNMapMapArrayOutput {
	a := make(URNMapMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToURNMapMapArrayOutput()
}

var uRNArrayMapArrayType = reflect.TypeOf((*[]map[string][]URN)(nil)).Elem()

// URNArrayMapArrayInput is an input type that accepts URNArrayMapArray and URNArrayMapArrayOutput values.
type URNArrayMapArrayInput interface {
	Input

	ToURNArrayMapArrayOutput() URNArrayMapArrayOutput
	ToURNArrayMapArrayOutputWithContext(ctx context.Context) URNArrayMapArrayOutput
}

// URNArrayMapArray is an input type for []URNArrayMapInput values.
type URNArrayMapArray []URNArrayMapInput

// ElementType returns the element type of this Input ([]map[string][]URN).
func (URNArrayMapArray) ElementType() reflect.Type {
	return uRNArrayMapArrayType
}

func (in URNArrayMapArray) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]URN] {
	return pulumix.Output[[]map[string][]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNArrayMapArray) ToURNArrayMapArrayOutput() URNArrayMapArrayOutput {
	return ToOutput(in).(URNArrayMapArrayOutput)
}

func (in URNArrayMapArray) ToURNArrayMapArrayOutputWithContext(ctx context.Context) URNArrayMapArrayOutput {
	return ToOutputWithContext(ctx, in).(URNArrayMapArrayOutput)
}

// URNArrayMapArrayOutput is an Output that returns []map[string][]URN values.
type URNArrayMapArrayOutput struct{ *OutputState }

func (URNArrayMapArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNArrayMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]map[string][]URN] {
	return pulumix.Output[[]map[string][]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([]map[string][]URN).
func (URNArrayMapArrayOutput) ElementType() reflect.Type {
	return uRNArrayMapArrayType
}

func (o URNArrayMapArrayOutput) ToURNArrayMapArrayOutput() URNArrayMapArrayOutput {
	return o
}

func (o URNArrayMapArrayOutput) ToURNArrayMapArrayOutputWithContext(ctx context.Context) URNArrayMapArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o URNArrayMapArrayOutput) Index(i IntInput) URNArrayMapOutput {
	return All(o, i).ApplyT(func(vs []any) map[string][]URN {
		arr := vs[0].([]map[string][]URN)
		idx := vs[1].(int)
		var ret map[string][]URN
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(URNArrayMapOutput)
}

func ToURNArrayMapArray(in []map[string][]URN) URNArrayMapArray {
	a := make(URNArrayMapArray, len(in))
	for i, v := range in {
		a[i] = ToURNArrayMap(v)
	}
	return a
}

func ToURNArrayMapArrayOutput(in []URNArrayMapOutput) URNArrayMapArrayOutput {
	a := make(URNArrayMapArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToURNArrayMapArrayOutput()
}

var uRNArrayArrayMapType = reflect.TypeOf((*map[string][][]URN)(nil)).Elem()

// URNArrayArrayMapInput is an input type that accepts URNArrayArrayMap and URNArrayArrayMapOutput values.
type URNArrayArrayMapInput interface {
	Input

	ToURNArrayArrayMapOutput() URNArrayArrayMapOutput
	ToURNArrayArrayMapOutputWithContext(ctx context.Context) URNArrayArrayMapOutput
}

// URNArrayArrayMap is an input type for map[string]URNArrayArrayInput values.
type URNArrayArrayMap map[string]URNArrayArrayInput

// ElementType returns the element type of this Input (map[string][][]URN).
func (URNArrayArrayMap) ElementType() reflect.Type {
	return uRNArrayArrayMapType
}

func (in URNArrayArrayMap) ToOutput(ctx context.Context) pulumix.Output[map[string][][]URN] {
	return pulumix.Output[map[string][][]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNArrayArrayMap) ToURNArrayArrayMapOutput() URNArrayArrayMapOutput {
	return ToOutput(in).(URNArrayArrayMapOutput)
}

func (in URNArrayArrayMap) ToURNArrayArrayMapOutputWithContext(ctx context.Context) URNArrayArrayMapOutput {
	return ToOutputWithContext(ctx, in).(URNArrayArrayMapOutput)
}

// URNArrayArrayMapOutput is an Output that returns map[string][][]URN values.
type URNArrayArrayMapOutput struct{ *OutputState }

func (URNArrayArrayMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNArrayArrayMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string][][]URN] {
	return pulumix.Output[map[string][][]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string][][]URN).
func (URNArrayArrayMapOutput) ElementType() reflect.Type {
	return uRNArrayArrayMapType
}

func (o URNArrayArrayMapOutput) ToURNArrayArrayMapOutput() URNArrayArrayMapOutput {
	return o
}

func (o URNArrayArrayMapOutput) ToURNArrayArrayMapOutputWithContext(ctx context.Context) URNArrayArrayMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o URNArrayArrayMapOutput) MapIndex(k StringInput) URNArrayArrayOutput {
	return All(o, k).ApplyT(func(vs []any) [][]URN {
		return vs[0].(map[string][][]URN)[vs[1].(string)]
	}).(URNArrayArrayOutput)
}

func ToURNArrayArrayMap(in map[string][][]URN) URNArrayArrayMap {
	m := make(URNArrayArrayMap)
	for k, v := range in {
		m[k] = ToURNArrayArray(v)
	}
	return m
}

func ToURNArrayArrayMapOutput(in map[string]URNArrayArrayOutput) URNArrayArrayMapOutput {
	m := make(URNArrayArrayMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToURNArrayArrayMapOutput()
}

var uRNArrayArrayArrayType = reflect.TypeOf((*[][][]URN)(nil)).Elem()

// URNArrayArrayArrayInput is an input type that accepts URNArrayArrayArray and URNArrayArrayArrayOutput values.
type URNArrayArrayArrayInput interface {
	Input

	ToURNArrayArrayArrayOutput() URNArrayArrayArrayOutput
	ToURNArrayArrayArrayOutputWithContext(ctx context.Context) URNArrayArrayArrayOutput
}

// URNArrayArrayArray is an input type for []URNArrayArrayInput values.
type URNArrayArrayArray []URNArrayArrayInput

// ElementType returns the element type of this Input ([][][]URN).
func (URNArrayArrayArray) ElementType() reflect.Type {
	return uRNArrayArrayArrayType
}

func (in URNArrayArrayArray) ToOutput(ctx context.Context) pulumix.Output[[][][]URN] {
	return pulumix.Output[[][][]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNArrayArrayArray) ToURNArrayArrayArrayOutput() URNArrayArrayArrayOutput {
	return ToOutput(in).(URNArrayArrayArrayOutput)
}

func (in URNArrayArrayArray) ToURNArrayArrayArrayOutputWithContext(ctx context.Context) URNArrayArrayArrayOutput {
	return ToOutputWithContext(ctx, in).(URNArrayArrayArrayOutput)
}

// URNArrayArrayArrayOutput is an Output that returns [][][]URN values.
type URNArrayArrayArrayOutput struct{ *OutputState }

func (URNArrayArrayArrayOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNArrayArrayArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[][][]URN] {
	return pulumix.Output[[][][]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output ([][][]URN).
func (URNArrayArrayArrayOutput) ElementType() reflect.Type {
	return uRNArrayArrayArrayType
}

func (o URNArrayArrayArrayOutput) ToURNArrayArrayArrayOutput() URNArrayArrayArrayOutput {
	return o
}

func (o URNArrayArrayArrayOutput) ToURNArrayArrayArrayOutputWithContext(ctx context.Context) URNArrayArrayArrayOutput {
	return o
}

// Index looks up the i'th element of the array if it is in bounds or returns the zero value of the appropriate
// type if the index is out of bounds.
func (o URNArrayArrayArrayOutput) Index(i IntInput) URNArrayArrayOutput {
	return All(o, i).ApplyT(func(vs []any) [][]URN {
		arr := vs[0].([][][]URN)
		idx := vs[1].(int)
		var ret [][]URN
		if idx >= 0 && idx < len(arr) {
			ret = arr[idx]
		}
		return ret
	}).(URNArrayArrayOutput)
}

func ToURNArrayArrayArray(in [][][]URN) URNArrayArrayArray {
	a := make(URNArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = ToURNArrayArray(v)
	}
	return a
}

func ToURNArrayArrayArrayOutput(in []URNArrayArrayOutput) URNArrayArrayArrayOutput {
	a := make(URNArrayArrayArray, len(in))
	for i, v := range in {
		a[i] = v
	}
	return a.ToURNArrayArrayArrayOutput()
}

var uRNMapMapMapType = reflect.TypeOf((*map[string]map[string]map[string]URN)(nil)).Elem()

// URNMapMapMapInput is an input type that accepts URNMapMapMap and URNMapMapMapOutput values.
type URNMapMapMapInput interface {
	Input

	ToURNMapMapMapOutput() URNMapMapMapOutput
	ToURNMapMapMapOutputWithContext(ctx context.Context) URNMapMapMapOutput
}

// URNMapMapMap is an input type for map[string]URNMapMapInput values.
type URNMapMapMap map[string]URNMapMapInput

// ElementType returns the element type of this Input (map[string]map[string]map[string]URN).
func (URNMapMapMap) ElementType() reflect.Type {
	return uRNMapMapMapType
}

func (in URNMapMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]URN] {
	return pulumix.Output[map[string]map[string]map[string]URN]{
		OutputState: internal.GetOutputState(ToOutputWithContext(ctx, in)),
	}
}

func (in URNMapMapMap) ToURNMapMapMapOutput() URNMapMapMapOutput {
	return ToOutput(in).(URNMapMapMapOutput)
}

func (in URNMapMapMap) ToURNMapMapMapOutputWithContext(ctx context.Context) URNMapMapMapOutput {
	return ToOutputWithContext(ctx, in).(URNMapMapMapOutput)
}

// URNMapMapMapOutput is an Output that returns map[string]map[string]map[string]URN values.
type URNMapMapMapOutput struct{ *OutputState }

func (URNMapMapMapOutput) MarshalJSON() ([]byte, error) {
	return nil, errors.New("Outputs can not be marshaled to JSON")
}

func (o URNMapMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]map[string]map[string]URN] {
	return pulumix.Output[map[string]map[string]map[string]URN]{
		OutputState: o.OutputState,
	}
}

// ElementType returns the element type of this Output (map[string]map[string]map[string]URN).
func (URNMapMapMapOutput) ElementType() reflect.Type {
	return uRNMapMapMapType
}

func (o URNMapMapMapOutput) ToURNMapMapMapOutput() URNMapMapMapOutput {
	return o
}

func (o URNMapMapMapOutput) ToURNMapMapMapOutputWithContext(ctx context.Context) URNMapMapMapOutput {
	return o
}

// MapIndex looks up the key k in the map.
func (o URNMapMapMapOutput) MapIndex(k StringInput) URNMapMapOutput {
	return All(o, k).ApplyT(func(vs []any) map[string]map[string]URN {
		return vs[0].(map[string]map[string]map[string]URN)[vs[1].(string)]
	}).(URNMapMapOutput)
}

func ToURNMapMapMap(in map[string]map[string]map[string]URN) URNMapMapMap {
	m := make(URNMapMapMap)
	for k, v := range in {
		m[k] = ToURNMapMap(v)
	}
	return m
}

func ToURNMapMapMapOutput(in map[string]URNMapMapOutput) URNMapMapMapOutput {
	m := make(URNMapMapMap)
	for k, v := range in {
		m[k] = v
	}
	return m.ToURNMapMapMapOutput()
}

func init() {
	internal.FullyResolvedTypes[reflect.TypeOf((*asset)(nil))] = struct{}{}
	internal.FullyResolvedTypes[reflect.TypeOf((*archive)(nil))] = struct{}{}
}

// AsArchiveOutput asserts that the type of the AnyOutput's underlying any value is
// Archive and returns a `ArchiveOutput` with that value. AsArchiveOutput panics if the value
// was not the expected type.
func (a AnyOutput) AsArchiveOutput() ArchiveOutput {
	return a.ApplyT(func(i any) Archive {
		return i.(Archive)
	}).(ArchiveOutput)
}

// AsArchiveArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []Archive or a compatible type and returns a `ArchiveArrayOutput` with that value.
// AsArchiveArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveArrayOutput() ArchiveArrayOutput {
	return a.ApplyT(func(i any) ([]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]Archive), nil
	}).(ArchiveArrayOutput)
}

// AsArchiveMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]Archive or a compatible type and returns a `ArchiveMapOutput` with that value.
// AsArchiveMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveMapOutput() ArchiveMapOutput {
	return a.ApplyT(func(i any) (map[string]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]Archive), nil
	}).(ArchiveMapOutput)
}

// AsArchiveArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]Archive or a compatible type and returns a `ArchiveArrayMapOutput` with that value.
// AsArchiveArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveArrayMapOutput() ArchiveArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]Archive), nil
	}).(ArchiveArrayMapOutput)
}

// AsArchiveMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]Archive or a compatible type and returns a `ArchiveMapArrayOutput` with that value.
// AsArchiveMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveMapArrayOutput() ArchiveMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]Archive), nil
	}).(ArchiveMapArrayOutput)
}

// AsArchiveMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]Archive or a compatible type and returns a `ArchiveMapMapOutput` with that value.
// AsArchiveMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveMapMapOutput() ArchiveMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]Archive), nil
	}).(ArchiveMapMapOutput)
}

// AsArchiveArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][]Archive or a compatible type and returns a `ArchiveArrayArrayOutput` with that value.
// AsArchiveArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveArrayArrayOutput() ArchiveArrayArrayOutput {
	return a.ApplyT(func(i any) ([][]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][]Archive), nil
	}).(ArchiveArrayArrayOutput)
}

// AsArchiveArrayMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string][]Archive or a compatible type and returns a `ArchiveArrayMapMapOutput` with that value.
// AsArchiveArrayMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveArrayMapMapOutput() ArchiveArrayMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string][]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string][]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string][]Archive), nil
	}).(ArchiveArrayMapMapOutput)
}

// AsArchiveMapArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]map[string]Archive or a compatible type and returns a `ArchiveMapArrayMapOutput` with that value.
// AsArchiveMapArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveMapArrayMapOutput() ArchiveMapArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]map[string]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]map[string]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]map[string]Archive), nil
	}).(ArchiveMapArrayMapOutput)
}

// AsArchiveMapMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]map[string]Archive or a compatible type and returns a `ArchiveMapMapArrayOutput` with that value.
// AsArchiveMapMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveMapMapArrayOutput() ArchiveMapMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]map[string]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]map[string]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]map[string]Archive), nil
	}).(ArchiveMapMapArrayOutput)
}

// AsArchiveArrayMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string][]Archive or a compatible type and returns a `ArchiveArrayMapArrayOutput` with that value.
// AsArchiveArrayMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveArrayMapArrayOutput() ArchiveArrayMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string][]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string][]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string][]Archive), nil
	}).(ArchiveArrayMapArrayOutput)
}

// AsArchiveArrayArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][][]Archive or a compatible type and returns a `ArchiveArrayArrayMapOutput` with that value.
// AsArchiveArrayArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveArrayArrayMapOutput() ArchiveArrayArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][][]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][][]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][][]Archive), nil
	}).(ArchiveArrayArrayMapOutput)
}

// AsArchiveArrayArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][][]Archive or a compatible type and returns a `ArchiveArrayArrayArrayOutput` with that value.
// AsArchiveArrayArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveArrayArrayArrayOutput() ArchiveArrayArrayArrayOutput {
	return a.ApplyT(func(i any) ([][][]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][][]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][][]Archive), nil
	}).(ArchiveArrayArrayArrayOutput)
}

// AsArchiveMapMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]map[string]Archive or a compatible type and returns a `ArchiveMapMapMapOutput` with that value.
// AsArchiveMapMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArchiveMapMapMapOutput() ArchiveMapMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]map[string]Archive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]map[string]Archive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]map[string]Archive), nil
	}).(ArchiveMapMapMapOutput)
}

// AsAssetOutput asserts that the type of the AnyOutput's underlying any value is
// Asset and returns a `AssetOutput` with that value. AsAssetOutput panics if the value
// was not the expected type.
func (a AnyOutput) AsAssetOutput() AssetOutput {
	return a.ApplyT(func(i any) Asset {
		return i.(Asset)
	}).(AssetOutput)
}

// AsAssetArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []Asset or a compatible type and returns a `AssetArrayOutput` with that value.
// AsAssetArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetArrayOutput() AssetArrayOutput {
	return a.ApplyT(func(i any) ([]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]Asset), nil
	}).(AssetArrayOutput)
}

// AsAssetMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]Asset or a compatible type and returns a `AssetMapOutput` with that value.
// AsAssetMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetMapOutput() AssetMapOutput {
	return a.ApplyT(func(i any) (map[string]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]Asset), nil
	}).(AssetMapOutput)
}

// AsAssetArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]Asset or a compatible type and returns a `AssetArrayMapOutput` with that value.
// AsAssetArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetArrayMapOutput() AssetArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]Asset), nil
	}).(AssetArrayMapOutput)
}

// AsAssetMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]Asset or a compatible type and returns a `AssetMapArrayOutput` with that value.
// AsAssetMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetMapArrayOutput() AssetMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]Asset), nil
	}).(AssetMapArrayOutput)
}

// AsAssetMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]Asset or a compatible type and returns a `AssetMapMapOutput` with that value.
// AsAssetMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetMapMapOutput() AssetMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]Asset), nil
	}).(AssetMapMapOutput)
}

// AsAssetArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][]Asset or a compatible type and returns a `AssetArrayArrayOutput` with that value.
// AsAssetArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetArrayArrayOutput() AssetArrayArrayOutput {
	return a.ApplyT(func(i any) ([][]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][]Asset), nil
	}).(AssetArrayArrayOutput)
}

// AsAssetArrayMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string][]Asset or a compatible type and returns a `AssetArrayMapMapOutput` with that value.
// AsAssetArrayMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetArrayMapMapOutput() AssetArrayMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string][]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string][]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string][]Asset), nil
	}).(AssetArrayMapMapOutput)
}

// AsAssetMapArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]map[string]Asset or a compatible type and returns a `AssetMapArrayMapOutput` with that value.
// AsAssetMapArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetMapArrayMapOutput() AssetMapArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]map[string]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]map[string]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]map[string]Asset), nil
	}).(AssetMapArrayMapOutput)
}

// AsAssetMapMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]map[string]Asset or a compatible type and returns a `AssetMapMapArrayOutput` with that value.
// AsAssetMapMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetMapMapArrayOutput() AssetMapMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]map[string]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]map[string]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]map[string]Asset), nil
	}).(AssetMapMapArrayOutput)
}

// AsAssetArrayMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string][]Asset or a compatible type and returns a `AssetArrayMapArrayOutput` with that value.
// AsAssetArrayMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetArrayMapArrayOutput() AssetArrayMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string][]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string][]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string][]Asset), nil
	}).(AssetArrayMapArrayOutput)
}

// AsAssetArrayArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][][]Asset or a compatible type and returns a `AssetArrayArrayMapOutput` with that value.
// AsAssetArrayArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetArrayArrayMapOutput() AssetArrayArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][][]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][][]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][][]Asset), nil
	}).(AssetArrayArrayMapOutput)
}

// AsAssetArrayArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][][]Asset or a compatible type and returns a `AssetArrayArrayArrayOutput` with that value.
// AsAssetArrayArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetArrayArrayArrayOutput() AssetArrayArrayArrayOutput {
	return a.ApplyT(func(i any) ([][][]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][][]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][][]Asset), nil
	}).(AssetArrayArrayArrayOutput)
}

// AsAssetMapMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]map[string]Asset or a compatible type and returns a `AssetMapMapMapOutput` with that value.
// AsAssetMapMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetMapMapMapOutput() AssetMapMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]map[string]Asset, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]map[string]Asset)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]map[string]Asset), nil
	}).(AssetMapMapMapOutput)
}

// AsAssetOrArchiveOutput asserts that the type of the AnyOutput's underlying any value is
// AssetOrArchive and returns a `AssetOrArchiveOutput` with that value. AsAssetOrArchiveOutput panics if the value
// was not the expected type.
func (a AnyOutput) AsAssetOrArchiveOutput() AssetOrArchiveOutput {
	return a.ApplyT(func(i any) AssetOrArchive {
		return i.(AssetOrArchive)
	}).(AssetOrArchiveOutput)
}

// AsAssetOrArchiveArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []AssetOrArchive or a compatible type and returns a `AssetOrArchiveArrayOutput` with that value.
// AsAssetOrArchiveArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveArrayOutput() AssetOrArchiveArrayOutput {
	return a.ApplyT(func(i any) ([]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]AssetOrArchive), nil
	}).(AssetOrArchiveArrayOutput)
}

// AsAssetOrArchiveMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]AssetOrArchive or a compatible type and returns a `AssetOrArchiveMapOutput` with that value.
// AsAssetOrArchiveMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveMapOutput() AssetOrArchiveMapOutput {
	return a.ApplyT(func(i any) (map[string]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]AssetOrArchive), nil
	}).(AssetOrArchiveMapOutput)
}

// AsAssetOrArchiveArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]AssetOrArchive or a compatible type and returns a `AssetOrArchiveArrayMapOutput` with that value.
// AsAssetOrArchiveArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveArrayMapOutput() AssetOrArchiveArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]AssetOrArchive), nil
	}).(AssetOrArchiveArrayMapOutput)
}

// AsAssetOrArchiveMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]AssetOrArchive or a compatible type and returns a `AssetOrArchiveMapArrayOutput` with that value.
// AsAssetOrArchiveMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveMapArrayOutput() AssetOrArchiveMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]AssetOrArchive), nil
	}).(AssetOrArchiveMapArrayOutput)
}

// AsAssetOrArchiveMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]AssetOrArchive or a compatible type and returns a `AssetOrArchiveMapMapOutput` with that value.
// AsAssetOrArchiveMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveMapMapOutput() AssetOrArchiveMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]AssetOrArchive), nil
	}).(AssetOrArchiveMapMapOutput)
}

// AsAssetOrArchiveArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][]AssetOrArchive or a compatible type and returns a `AssetOrArchiveArrayArrayOutput` with that value.
// AsAssetOrArchiveArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveArrayArrayOutput() AssetOrArchiveArrayArrayOutput {
	return a.ApplyT(func(i any) ([][]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][]AssetOrArchive), nil
	}).(AssetOrArchiveArrayArrayOutput)
}

// AsAssetOrArchiveArrayMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string][]AssetOrArchive or a compatible type and returns a `AssetOrArchiveArrayMapMapOutput` with that value.
// AsAssetOrArchiveArrayMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveArrayMapMapOutput() AssetOrArchiveArrayMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string][]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string][]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string][]AssetOrArchive), nil
	}).(AssetOrArchiveArrayMapMapOutput)
}

// AsAssetOrArchiveMapArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]map[string]AssetOrArchive or a compatible type and returns a `AssetOrArchiveMapArrayMapOutput` with that value.
// AsAssetOrArchiveMapArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveMapArrayMapOutput() AssetOrArchiveMapArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]map[string]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]map[string]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]map[string]AssetOrArchive), nil
	}).(AssetOrArchiveMapArrayMapOutput)
}

// AsAssetOrArchiveMapMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]map[string]AssetOrArchive or a compatible type and returns a `AssetOrArchiveMapMapArrayOutput` with that value.
// AsAssetOrArchiveMapMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveMapMapArrayOutput() AssetOrArchiveMapMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]map[string]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]map[string]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]map[string]AssetOrArchive), nil
	}).(AssetOrArchiveMapMapArrayOutput)
}

// AsAssetOrArchiveArrayMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string][]AssetOrArchive or a compatible type and returns a `AssetOrArchiveArrayMapArrayOutput` with that value.
// AsAssetOrArchiveArrayMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveArrayMapArrayOutput() AssetOrArchiveArrayMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string][]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string][]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string][]AssetOrArchive), nil
	}).(AssetOrArchiveArrayMapArrayOutput)
}

// AsAssetOrArchiveArrayArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][][]AssetOrArchive or a compatible type and returns a `AssetOrArchiveArrayArrayMapOutput` with that value.
// AsAssetOrArchiveArrayArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveArrayArrayMapOutput() AssetOrArchiveArrayArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][][]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][][]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][][]AssetOrArchive), nil
	}).(AssetOrArchiveArrayArrayMapOutput)
}

// AsAssetOrArchiveArrayArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][][]AssetOrArchive or a compatible type and returns a `AssetOrArchiveArrayArrayArrayOutput` with that value.
// AsAssetOrArchiveArrayArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveArrayArrayArrayOutput() AssetOrArchiveArrayArrayArrayOutput {
	return a.ApplyT(func(i any) ([][][]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][][]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][][]AssetOrArchive), nil
	}).(AssetOrArchiveArrayArrayArrayOutput)
}

// AsAssetOrArchiveMapMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]map[string]AssetOrArchive or a compatible type and returns a `AssetOrArchiveMapMapMapOutput` with that value.
// AsAssetOrArchiveMapMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsAssetOrArchiveMapMapMapOutput() AssetOrArchiveMapMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]map[string]AssetOrArchive, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]map[string]AssetOrArchive)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]map[string]AssetOrArchive), nil
	}).(AssetOrArchiveMapMapMapOutput)
}

// AsBoolOutput asserts that the type of the AnyOutput's underlying any value is
// bool and returns a `BoolOutput` with that value. AsBoolOutput panics if the value
// was not the expected type.
func (a AnyOutput) AsBoolOutput() BoolOutput {
	return a.ApplyT(func(i any) bool {
		return i.(bool)
	}).(BoolOutput)
}

// AsBoolPtrOutput asserts that the type of the AnyOutput's underlying any value is
// *bool or a compatible type and returns a `BoolPtrOutput` with that value.
// AsBoolPtrOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolPtrOutput() BoolPtrOutput {
	return a.ApplyT(func(i any) (*bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((**bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(*bool), nil
	}).(BoolPtrOutput)
}

// AsBoolArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []bool or a compatible type and returns a `BoolArrayOutput` with that value.
// AsBoolArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolArrayOutput() BoolArrayOutput {
	return a.ApplyT(func(i any) ([]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]bool), nil
	}).(BoolArrayOutput)
}

// AsBoolMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]bool or a compatible type and returns a `BoolMapOutput` with that value.
// AsBoolMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolMapOutput() BoolMapOutput {
	return a.ApplyT(func(i any) (map[string]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]bool), nil
	}).(BoolMapOutput)
}

// AsBoolArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]bool or a compatible type and returns a `BoolArrayMapOutput` with that value.
// AsBoolArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolArrayMapOutput() BoolArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]bool), nil
	}).(BoolArrayMapOutput)
}

// AsBoolMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]bool or a compatible type and returns a `BoolMapArrayOutput` with that value.
// AsBoolMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolMapArrayOutput() BoolMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]bool), nil
	}).(BoolMapArrayOutput)
}

// AsBoolMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]bool or a compatible type and returns a `BoolMapMapOutput` with that value.
// AsBoolMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolMapMapOutput() BoolMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]bool), nil
	}).(BoolMapMapOutput)
}

// AsBoolArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][]bool or a compatible type and returns a `BoolArrayArrayOutput` with that value.
// AsBoolArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolArrayArrayOutput() BoolArrayArrayOutput {
	return a.ApplyT(func(i any) ([][]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][]bool), nil
	}).(BoolArrayArrayOutput)
}

// AsBoolArrayMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string][]bool or a compatible type and returns a `BoolArrayMapMapOutput` with that value.
// AsBoolArrayMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolArrayMapMapOutput() BoolArrayMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string][]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string][]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string][]bool), nil
	}).(BoolArrayMapMapOutput)
}

// AsBoolMapArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]map[string]bool or a compatible type and returns a `BoolMapArrayMapOutput` with that value.
// AsBoolMapArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolMapArrayMapOutput() BoolMapArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]map[string]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]map[string]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]map[string]bool), nil
	}).(BoolMapArrayMapOutput)
}

// AsBoolMapMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]map[string]bool or a compatible type and returns a `BoolMapMapArrayOutput` with that value.
// AsBoolMapMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolMapMapArrayOutput() BoolMapMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]map[string]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]map[string]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]map[string]bool), nil
	}).(BoolMapMapArrayOutput)
}

// AsBoolArrayMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string][]bool or a compatible type and returns a `BoolArrayMapArrayOutput` with that value.
// AsBoolArrayMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolArrayMapArrayOutput() BoolArrayMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string][]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string][]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string][]bool), nil
	}).(BoolArrayMapArrayOutput)
}

// AsBoolArrayArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][][]bool or a compatible type and returns a `BoolArrayArrayMapOutput` with that value.
// AsBoolArrayArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolArrayArrayMapOutput() BoolArrayArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][][]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][][]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][][]bool), nil
	}).(BoolArrayArrayMapOutput)
}

// AsBoolArrayArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][][]bool or a compatible type and returns a `BoolArrayArrayArrayOutput` with that value.
// AsBoolArrayArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolArrayArrayArrayOutput() BoolArrayArrayArrayOutput {
	return a.ApplyT(func(i any) ([][][]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][][]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][][]bool), nil
	}).(BoolArrayArrayArrayOutput)
}

// AsBoolMapMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]map[string]bool or a compatible type and returns a `BoolMapMapMapOutput` with that value.
// AsBoolMapMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsBoolMapMapMapOutput() BoolMapMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]map[string]bool, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]map[string]bool)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]map[string]bool), nil
	}).(BoolMapMapMapOutput)
}

// AsFloat64Output asserts that the type of the AnyOutput's underlying any value is
// float64 and returns a `Float64Output` with that value. AsFloat64Output panics if the value
// was not the expected type.
func (a AnyOutput) AsFloat64Output() Float64Output {
	return a.ApplyT(func(i any) float64 {
		return i.(float64)
	}).(Float64Output)
}

// AsFloat64PtrOutput asserts that the type of the AnyOutput's underlying any value is
// *float64 or a compatible type and returns a `Float64PtrOutput` with that value.
// AsFloat64PtrOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64PtrOutput() Float64PtrOutput {
	return a.ApplyT(func(i any) (*float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((**float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(*float64), nil
	}).(Float64PtrOutput)
}

// AsFloat64ArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []float64 or a compatible type and returns a `Float64ArrayOutput` with that value.
// AsFloat64ArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64ArrayOutput() Float64ArrayOutput {
	return a.ApplyT(func(i any) ([]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]float64), nil
	}).(Float64ArrayOutput)
}

// AsFloat64MapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]float64 or a compatible type and returns a `Float64MapOutput` with that value.
// AsFloat64MapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64MapOutput() Float64MapOutput {
	return a.ApplyT(func(i any) (map[string]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]float64), nil
	}).(Float64MapOutput)
}

// AsFloat64ArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]float64 or a compatible type and returns a `Float64ArrayMapOutput` with that value.
// AsFloat64ArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64ArrayMapOutput() Float64ArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]float64), nil
	}).(Float64ArrayMapOutput)
}

// AsFloat64MapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]float64 or a compatible type and returns a `Float64MapArrayOutput` with that value.
// AsFloat64MapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64MapArrayOutput() Float64MapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]float64), nil
	}).(Float64MapArrayOutput)
}

// AsFloat64MapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]float64 or a compatible type and returns a `Float64MapMapOutput` with that value.
// AsFloat64MapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64MapMapOutput() Float64MapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]float64), nil
	}).(Float64MapMapOutput)
}

// AsFloat64ArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][]float64 or a compatible type and returns a `Float64ArrayArrayOutput` with that value.
// AsFloat64ArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64ArrayArrayOutput() Float64ArrayArrayOutput {
	return a.ApplyT(func(i any) ([][]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][]float64), nil
	}).(Float64ArrayArrayOutput)
}

// AsFloat64ArrayMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string][]float64 or a compatible type and returns a `Float64ArrayMapMapOutput` with that value.
// AsFloat64ArrayMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64ArrayMapMapOutput() Float64ArrayMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string][]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string][]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string][]float64), nil
	}).(Float64ArrayMapMapOutput)
}

// AsFloat64MapArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]map[string]float64 or a compatible type and returns a `Float64MapArrayMapOutput` with that value.
// AsFloat64MapArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64MapArrayMapOutput() Float64MapArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]map[string]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]map[string]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]map[string]float64), nil
	}).(Float64MapArrayMapOutput)
}

// AsFloat64MapMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]map[string]float64 or a compatible type and returns a `Float64MapMapArrayOutput` with that value.
// AsFloat64MapMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64MapMapArrayOutput() Float64MapMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]map[string]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]map[string]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]map[string]float64), nil
	}).(Float64MapMapArrayOutput)
}

// AsFloat64ArrayMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string][]float64 or a compatible type and returns a `Float64ArrayMapArrayOutput` with that value.
// AsFloat64ArrayMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64ArrayMapArrayOutput() Float64ArrayMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string][]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string][]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string][]float64), nil
	}).(Float64ArrayMapArrayOutput)
}

// AsFloat64ArrayArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][][]float64 or a compatible type and returns a `Float64ArrayArrayMapOutput` with that value.
// AsFloat64ArrayArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64ArrayArrayMapOutput() Float64ArrayArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][][]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][][]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][][]float64), nil
	}).(Float64ArrayArrayMapOutput)
}

// AsFloat64ArrayArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][][]float64 or a compatible type and returns a `Float64ArrayArrayArrayOutput` with that value.
// AsFloat64ArrayArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64ArrayArrayArrayOutput() Float64ArrayArrayArrayOutput {
	return a.ApplyT(func(i any) ([][][]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][][]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][][]float64), nil
	}).(Float64ArrayArrayArrayOutput)
}

// AsFloat64MapMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]map[string]float64 or a compatible type and returns a `Float64MapMapMapOutput` with that value.
// AsFloat64MapMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsFloat64MapMapMapOutput() Float64MapMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]map[string]float64, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]map[string]float64)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]map[string]float64), nil
	}).(Float64MapMapMapOutput)
}

// AsIDOutput asserts that the type of the AnyOutput's underlying any value is
// ID and returns a `IDOutput` with that value. AsIDOutput panics if the value
// was not the expected type.
func (a AnyOutput) AsIDOutput() IDOutput {
	return a.ApplyT(func(i any) ID {
		return i.(ID)
	}).(IDOutput)
}

// AsIDPtrOutput asserts that the type of the AnyOutput's underlying any value is
// *ID or a compatible type and returns a `IDPtrOutput` with that value.
// AsIDPtrOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDPtrOutput() IDPtrOutput {
	return a.ApplyT(func(i any) (*ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((**ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(*ID), nil
	}).(IDPtrOutput)
}

// AsIDArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []ID or a compatible type and returns a `IDArrayOutput` with that value.
// AsIDArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDArrayOutput() IDArrayOutput {
	return a.ApplyT(func(i any) ([]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]ID), nil
	}).(IDArrayOutput)
}

// AsIDMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]ID or a compatible type and returns a `IDMapOutput` with that value.
// AsIDMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDMapOutput() IDMapOutput {
	return a.ApplyT(func(i any) (map[string]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]ID), nil
	}).(IDMapOutput)
}

// AsIDArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]ID or a compatible type and returns a `IDArrayMapOutput` with that value.
// AsIDArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDArrayMapOutput() IDArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]ID), nil
	}).(IDArrayMapOutput)
}

// AsIDMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]ID or a compatible type and returns a `IDMapArrayOutput` with that value.
// AsIDMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDMapArrayOutput() IDMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]ID), nil
	}).(IDMapArrayOutput)
}

// AsIDMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]ID or a compatible type and returns a `IDMapMapOutput` with that value.
// AsIDMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDMapMapOutput() IDMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]ID), nil
	}).(IDMapMapOutput)
}

// AsIDArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][]ID or a compatible type and returns a `IDArrayArrayOutput` with that value.
// AsIDArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDArrayArrayOutput() IDArrayArrayOutput {
	return a.ApplyT(func(i any) ([][]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][]ID), nil
	}).(IDArrayArrayOutput)
}

// AsIDArrayMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string][]ID or a compatible type and returns a `IDArrayMapMapOutput` with that value.
// AsIDArrayMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDArrayMapMapOutput() IDArrayMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string][]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string][]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string][]ID), nil
	}).(IDArrayMapMapOutput)
}

// AsIDMapArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]map[string]ID or a compatible type and returns a `IDMapArrayMapOutput` with that value.
// AsIDMapArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDMapArrayMapOutput() IDMapArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]map[string]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]map[string]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]map[string]ID), nil
	}).(IDMapArrayMapOutput)
}

// AsIDMapMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]map[string]ID or a compatible type and returns a `IDMapMapArrayOutput` with that value.
// AsIDMapMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDMapMapArrayOutput() IDMapMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]map[string]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]map[string]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]map[string]ID), nil
	}).(IDMapMapArrayOutput)
}

// AsIDArrayMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string][]ID or a compatible type and returns a `IDArrayMapArrayOutput` with that value.
// AsIDArrayMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDArrayMapArrayOutput() IDArrayMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string][]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string][]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string][]ID), nil
	}).(IDArrayMapArrayOutput)
}

// AsIDArrayArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][][]ID or a compatible type and returns a `IDArrayArrayMapOutput` with that value.
// AsIDArrayArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDArrayArrayMapOutput() IDArrayArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][][]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][][]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][][]ID), nil
	}).(IDArrayArrayMapOutput)
}

// AsIDArrayArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][][]ID or a compatible type and returns a `IDArrayArrayArrayOutput` with that value.
// AsIDArrayArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDArrayArrayArrayOutput() IDArrayArrayArrayOutput {
	return a.ApplyT(func(i any) ([][][]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][][]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][][]ID), nil
	}).(IDArrayArrayArrayOutput)
}

// AsIDMapMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]map[string]ID or a compatible type and returns a `IDMapMapMapOutput` with that value.
// AsIDMapMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIDMapMapMapOutput() IDMapMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]map[string]ID, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]map[string]ID)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]map[string]ID), nil
	}).(IDMapMapMapOutput)
}

// AsArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []any or a compatible type and returns a `ArrayOutput` with that value.
// AsArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArrayOutput() ArrayOutput {
	return a.ApplyT(func(i any) ([]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]any), nil
	}).(ArrayOutput)
}

// AsMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]any or a compatible type and returns a `MapOutput` with that value.
// AsMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsMapOutput() MapOutput {
	return a.ApplyT(func(i any) (map[string]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]any), nil
	}).(MapOutput)
}

// AsArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]any or a compatible type and returns a `ArrayMapOutput` with that value.
// AsArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArrayMapOutput() ArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]any), nil
	}).(ArrayMapOutput)
}

// AsMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]any or a compatible type and returns a `MapArrayOutput` with that value.
// AsMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsMapArrayOutput() MapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]any), nil
	}).(MapArrayOutput)
}

// AsMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]any or a compatible type and returns a `MapMapOutput` with that value.
// AsMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsMapMapOutput() MapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]any), nil
	}).(MapMapOutput)
}

// AsArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][]any or a compatible type and returns a `ArrayArrayOutput` with that value.
// AsArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArrayArrayOutput() ArrayArrayOutput {
	return a.ApplyT(func(i any) ([][]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][]any), nil
	}).(ArrayArrayOutput)
}

// AsArrayMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string][]any or a compatible type and returns a `ArrayMapMapOutput` with that value.
// AsArrayMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArrayMapMapOutput() ArrayMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string][]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string][]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string][]any), nil
	}).(ArrayMapMapOutput)
}

// AsMapArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]map[string]any or a compatible type and returns a `MapArrayMapOutput` with that value.
// AsMapArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsMapArrayMapOutput() MapArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]map[string]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]map[string]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]map[string]any), nil
	}).(MapArrayMapOutput)
}

// AsMapMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]map[string]any or a compatible type and returns a `MapMapArrayOutput` with that value.
// AsMapMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsMapMapArrayOutput() MapMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]map[string]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]map[string]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]map[string]any), nil
	}).(MapMapArrayOutput)
}

// AsArrayMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string][]any or a compatible type and returns a `ArrayMapArrayOutput` with that value.
// AsArrayMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArrayMapArrayOutput() ArrayMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string][]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string][]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string][]any), nil
	}).(ArrayMapArrayOutput)
}

// AsArrayArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][][]any or a compatible type and returns a `ArrayArrayMapOutput` with that value.
// AsArrayArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArrayArrayMapOutput() ArrayArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][][]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][][]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][][]any), nil
	}).(ArrayArrayMapOutput)
}

// AsArrayArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][][]any or a compatible type and returns a `ArrayArrayArrayOutput` with that value.
// AsArrayArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsArrayArrayArrayOutput() ArrayArrayArrayOutput {
	return a.ApplyT(func(i any) ([][][]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][][]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][][]any), nil
	}).(ArrayArrayArrayOutput)
}

// AsMapMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]map[string]any or a compatible type and returns a `MapMapMapOutput` with that value.
// AsMapMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsMapMapMapOutput() MapMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]map[string]any, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]map[string]any)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]map[string]any), nil
	}).(MapMapMapOutput)
}

// AsIntOutput asserts that the type of the AnyOutput's underlying any value is
// int and returns a `IntOutput` with that value. AsIntOutput panics if the value
// was not the expected type.
func (a AnyOutput) AsIntOutput() IntOutput {
	return a.ApplyT(func(i any) int {
		return i.(int)
	}).(IntOutput)
}

// AsIntPtrOutput asserts that the type of the AnyOutput's underlying any value is
// *int or a compatible type and returns a `IntPtrOutput` with that value.
// AsIntPtrOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntPtrOutput() IntPtrOutput {
	return a.ApplyT(func(i any) (*int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((**int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(*int), nil
	}).(IntPtrOutput)
}

// AsIntArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []int or a compatible type and returns a `IntArrayOutput` with that value.
// AsIntArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntArrayOutput() IntArrayOutput {
	return a.ApplyT(func(i any) ([]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]int), nil
	}).(IntArrayOutput)
}

// AsIntMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]int or a compatible type and returns a `IntMapOutput` with that value.
// AsIntMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntMapOutput() IntMapOutput {
	return a.ApplyT(func(i any) (map[string]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]int), nil
	}).(IntMapOutput)
}

// AsIntArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]int or a compatible type and returns a `IntArrayMapOutput` with that value.
// AsIntArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntArrayMapOutput() IntArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]int), nil
	}).(IntArrayMapOutput)
}

// AsIntMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]int or a compatible type and returns a `IntMapArrayOutput` with that value.
// AsIntMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntMapArrayOutput() IntMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]int), nil
	}).(IntMapArrayOutput)
}

// AsIntMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]int or a compatible type and returns a `IntMapMapOutput` with that value.
// AsIntMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntMapMapOutput() IntMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]int), nil
	}).(IntMapMapOutput)
}

// AsIntArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][]int or a compatible type and returns a `IntArrayArrayOutput` with that value.
// AsIntArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntArrayArrayOutput() IntArrayArrayOutput {
	return a.ApplyT(func(i any) ([][]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][]int), nil
	}).(IntArrayArrayOutput)
}

// AsIntArrayMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string][]int or a compatible type and returns a `IntArrayMapMapOutput` with that value.
// AsIntArrayMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntArrayMapMapOutput() IntArrayMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string][]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string][]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string][]int), nil
	}).(IntArrayMapMapOutput)
}

// AsIntMapArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]map[string]int or a compatible type and returns a `IntMapArrayMapOutput` with that value.
// AsIntMapArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntMapArrayMapOutput() IntMapArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]map[string]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]map[string]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]map[string]int), nil
	}).(IntMapArrayMapOutput)
}

// AsIntMapMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]map[string]int or a compatible type and returns a `IntMapMapArrayOutput` with that value.
// AsIntMapMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntMapMapArrayOutput() IntMapMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]map[string]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]map[string]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]map[string]int), nil
	}).(IntMapMapArrayOutput)
}

// AsIntArrayMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string][]int or a compatible type and returns a `IntArrayMapArrayOutput` with that value.
// AsIntArrayMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntArrayMapArrayOutput() IntArrayMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string][]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string][]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string][]int), nil
	}).(IntArrayMapArrayOutput)
}

// AsIntArrayArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][][]int or a compatible type and returns a `IntArrayArrayMapOutput` with that value.
// AsIntArrayArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntArrayArrayMapOutput() IntArrayArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][][]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][][]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][][]int), nil
	}).(IntArrayArrayMapOutput)
}

// AsIntArrayArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][][]int or a compatible type and returns a `IntArrayArrayArrayOutput` with that value.
// AsIntArrayArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntArrayArrayArrayOutput() IntArrayArrayArrayOutput {
	return a.ApplyT(func(i any) ([][][]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][][]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][][]int), nil
	}).(IntArrayArrayArrayOutput)
}

// AsIntMapMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]map[string]int or a compatible type and returns a `IntMapMapMapOutput` with that value.
// AsIntMapMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsIntMapMapMapOutput() IntMapMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]map[string]int, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]map[string]int)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]map[string]int), nil
	}).(IntMapMapMapOutput)
}

// AsStringOutput asserts that the type of the AnyOutput's underlying any value is
// string and returns a `StringOutput` with that value. AsStringOutput panics if the value
// was not the expected type.
func (a AnyOutput) AsStringOutput() StringOutput {
	return a.ApplyT(func(i any) string {
		return i.(string)
	}).(StringOutput)
}

// AsStringPtrOutput asserts that the type of the AnyOutput's underlying any value is
// *string or a compatible type and returns a `StringPtrOutput` with that value.
// AsStringPtrOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringPtrOutput() StringPtrOutput {
	return a.ApplyT(func(i any) (*string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((**string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(*string), nil
	}).(StringPtrOutput)
}

// AsStringArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []string or a compatible type and returns a `StringArrayOutput` with that value.
// AsStringArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringArrayOutput() StringArrayOutput {
	return a.ApplyT(func(i any) ([]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]string), nil
	}).(StringArrayOutput)
}

// AsStringMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]string or a compatible type and returns a `StringMapOutput` with that value.
// AsStringMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringMapOutput() StringMapOutput {
	return a.ApplyT(func(i any) (map[string]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]string), nil
	}).(StringMapOutput)
}

// AsStringArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]string or a compatible type and returns a `StringArrayMapOutput` with that value.
// AsStringArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringArrayMapOutput() StringArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]string), nil
	}).(StringArrayMapOutput)
}

// AsStringMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]string or a compatible type and returns a `StringMapArrayOutput` with that value.
// AsStringMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringMapArrayOutput() StringMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]string), nil
	}).(StringMapArrayOutput)
}

// AsStringMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]string or a compatible type and returns a `StringMapMapOutput` with that value.
// AsStringMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringMapMapOutput() StringMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]string), nil
	}).(StringMapMapOutput)
}

// AsStringArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][]string or a compatible type and returns a `StringArrayArrayOutput` with that value.
// AsStringArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringArrayArrayOutput() StringArrayArrayOutput {
	return a.ApplyT(func(i any) ([][]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][]string), nil
	}).(StringArrayArrayOutput)
}

// AsStringArrayMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string][]string or a compatible type and returns a `StringArrayMapMapOutput` with that value.
// AsStringArrayMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringArrayMapMapOutput() StringArrayMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string][]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string][]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string][]string), nil
	}).(StringArrayMapMapOutput)
}

// AsStringMapArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]map[string]string or a compatible type and returns a `StringMapArrayMapOutput` with that value.
// AsStringMapArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringMapArrayMapOutput() StringMapArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]map[string]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]map[string]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]map[string]string), nil
	}).(StringMapArrayMapOutput)
}

// AsStringMapMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]map[string]string or a compatible type and returns a `StringMapMapArrayOutput` with that value.
// AsStringMapMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringMapMapArrayOutput() StringMapMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]map[string]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]map[string]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]map[string]string), nil
	}).(StringMapMapArrayOutput)
}

// AsStringArrayMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string][]string or a compatible type and returns a `StringArrayMapArrayOutput` with that value.
// AsStringArrayMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringArrayMapArrayOutput() StringArrayMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string][]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string][]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string][]string), nil
	}).(StringArrayMapArrayOutput)
}

// AsStringArrayArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][][]string or a compatible type and returns a `StringArrayArrayMapOutput` with that value.
// AsStringArrayArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringArrayArrayMapOutput() StringArrayArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][][]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][][]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][][]string), nil
	}).(StringArrayArrayMapOutput)
}

// AsStringArrayArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][][]string or a compatible type and returns a `StringArrayArrayArrayOutput` with that value.
// AsStringArrayArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringArrayArrayArrayOutput() StringArrayArrayArrayOutput {
	return a.ApplyT(func(i any) ([][][]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][][]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][][]string), nil
	}).(StringArrayArrayArrayOutput)
}

// AsStringMapMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]map[string]string or a compatible type and returns a `StringMapMapMapOutput` with that value.
// AsStringMapMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsStringMapMapMapOutput() StringMapMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]map[string]string, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]map[string]string)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]map[string]string), nil
	}).(StringMapMapMapOutput)
}

// AsURNOutput asserts that the type of the AnyOutput's underlying any value is
// URN and returns a `URNOutput` with that value. AsURNOutput panics if the value
// was not the expected type.
func (a AnyOutput) AsURNOutput() URNOutput {
	return a.ApplyT(func(i any) URN {
		return i.(URN)
	}).(URNOutput)
}

// AsURNPtrOutput asserts that the type of the AnyOutput's underlying any value is
// *URN or a compatible type and returns a `URNPtrOutput` with that value.
// AsURNPtrOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNPtrOutput() URNPtrOutput {
	return a.ApplyT(func(i any) (*URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((**URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(*URN), nil
	}).(URNPtrOutput)
}

// AsURNArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []URN or a compatible type and returns a `URNArrayOutput` with that value.
// AsURNArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNArrayOutput() URNArrayOutput {
	return a.ApplyT(func(i any) ([]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]URN), nil
	}).(URNArrayOutput)
}

// AsURNMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]URN or a compatible type and returns a `URNMapOutput` with that value.
// AsURNMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNMapOutput() URNMapOutput {
	return a.ApplyT(func(i any) (map[string]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]URN), nil
	}).(URNMapOutput)
}

// AsURNArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]URN or a compatible type and returns a `URNArrayMapOutput` with that value.
// AsURNArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNArrayMapOutput() URNArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]URN), nil
	}).(URNArrayMapOutput)
}

// AsURNMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]URN or a compatible type and returns a `URNMapArrayOutput` with that value.
// AsURNMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNMapArrayOutput() URNMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]URN), nil
	}).(URNMapArrayOutput)
}

// AsURNMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]URN or a compatible type and returns a `URNMapMapOutput` with that value.
// AsURNMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNMapMapOutput() URNMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]URN), nil
	}).(URNMapMapOutput)
}

// AsURNArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][]URN or a compatible type and returns a `URNArrayArrayOutput` with that value.
// AsURNArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNArrayArrayOutput() URNArrayArrayOutput {
	return a.ApplyT(func(i any) ([][]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][]URN), nil
	}).(URNArrayArrayOutput)
}

// AsURNArrayMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string][]URN or a compatible type and returns a `URNArrayMapMapOutput` with that value.
// AsURNArrayMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNArrayMapMapOutput() URNArrayMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string][]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string][]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string][]URN), nil
	}).(URNArrayMapMapOutput)
}

// AsURNMapArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][]map[string]URN or a compatible type and returns a `URNMapArrayMapOutput` with that value.
// AsURNMapArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNMapArrayMapOutput() URNMapArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][]map[string]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][]map[string]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][]map[string]URN), nil
	}).(URNMapArrayMapOutput)
}

// AsURNMapMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string]map[string]URN or a compatible type and returns a `URNMapMapArrayOutput` with that value.
// AsURNMapMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNMapMapArrayOutput() URNMapMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string]map[string]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string]map[string]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string]map[string]URN), nil
	}).(URNMapMapArrayOutput)
}

// AsURNArrayMapArrayOutput asserts that the type of the AnyOutput's underlying any value is
// []map[string][]URN or a compatible type and returns a `URNArrayMapArrayOutput` with that value.
// AsURNArrayMapArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNArrayMapArrayOutput() URNArrayMapArrayOutput {
	return a.ApplyT(func(i any) ([]map[string][]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[]map[string][]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([]map[string][]URN), nil
	}).(URNArrayMapArrayOutput)
}

// AsURNArrayArrayMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string][][]URN or a compatible type and returns a `URNArrayArrayMapOutput` with that value.
// AsURNArrayArrayMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNArrayArrayMapOutput() URNArrayArrayMapOutput {
	return a.ApplyT(func(i any) (map[string][][]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string][][]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string][][]URN), nil
	}).(URNArrayArrayMapOutput)
}

// AsURNArrayArrayArrayOutput asserts that the type of the AnyOutput's underlying any value is
// [][][]URN or a compatible type and returns a `URNArrayArrayArrayOutput` with that value.
// AsURNArrayArrayArrayOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNArrayArrayArrayOutput() URNArrayArrayArrayOutput {
	return a.ApplyT(func(i any) ([][][]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*[][][]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.([][][]URN), nil
	}).(URNArrayArrayArrayOutput)
}

// AsURNMapMapMapOutput asserts that the type of the AnyOutput's underlying any value is
// map[string]map[string]map[string]URN or a compatible type and returns a `URNMapMapMapOutput` with that value.
// AsURNMapMapMapOutput panics if the value was not the expected type or a compatible type.
func (a AnyOutput) AsURNMapMapMapOutput() URNMapMapMapOutput {
	return a.ApplyT(func(i any) (map[string]map[string]map[string]URN, error) {
		v, err := coerceTypeConversion(i, reflect.TypeOf((*map[string]map[string]map[string]URN)(nil)).Elem())
		if err != nil {
			return nil, err
		}
		return v.(map[string]map[string]map[string]URN), nil
	}).(URNMapMapMapOutput)
}

func init() {
	RegisterInputType(reflect.TypeOf((*ArchiveArrayInput)(nil)).Elem(), ArchiveArray{})
	RegisterInputType(reflect.TypeOf((*ArchiveMapInput)(nil)).Elem(), ArchiveMap{})
	RegisterInputType(reflect.TypeOf((*ArchiveArrayMapInput)(nil)).Elem(), ArchiveArrayMap{})
	RegisterInputType(reflect.TypeOf((*ArchiveMapArrayInput)(nil)).Elem(), ArchiveMapArray{})
	RegisterInputType(reflect.TypeOf((*ArchiveMapMapInput)(nil)).Elem(), ArchiveMapMap{})
	RegisterInputType(reflect.TypeOf((*ArchiveArrayArrayInput)(nil)).Elem(), ArchiveArrayArray{})
	RegisterInputType(reflect.TypeOf((*ArchiveArrayMapMapInput)(nil)).Elem(), ArchiveArrayMapMap{})
	RegisterInputType(reflect.TypeOf((*ArchiveMapArrayMapInput)(nil)).Elem(), ArchiveMapArrayMap{})
	RegisterInputType(reflect.TypeOf((*ArchiveMapMapArrayInput)(nil)).Elem(), ArchiveMapMapArray{})
	RegisterInputType(reflect.TypeOf((*ArchiveArrayMapArrayInput)(nil)).Elem(), ArchiveArrayMapArray{})
	RegisterInputType(reflect.TypeOf((*ArchiveArrayArrayMapInput)(nil)).Elem(), ArchiveArrayArrayMap{})
	RegisterInputType(reflect.TypeOf((*ArchiveArrayArrayArrayInput)(nil)).Elem(), ArchiveArrayArrayArray{})
	RegisterInputType(reflect.TypeOf((*ArchiveMapMapMapInput)(nil)).Elem(), ArchiveMapMapMap{})
	RegisterInputType(reflect.TypeOf((*AssetArrayInput)(nil)).Elem(), AssetArray{})
	RegisterInputType(reflect.TypeOf((*AssetMapInput)(nil)).Elem(), AssetMap{})
	RegisterInputType(reflect.TypeOf((*AssetArrayMapInput)(nil)).Elem(), AssetArrayMap{})
	RegisterInputType(reflect.TypeOf((*AssetMapArrayInput)(nil)).Elem(), AssetMapArray{})
	RegisterInputType(reflect.TypeOf((*AssetMapMapInput)(nil)).Elem(), AssetMapMap{})
	RegisterInputType(reflect.TypeOf((*AssetArrayArrayInput)(nil)).Elem(), AssetArrayArray{})
	RegisterInputType(reflect.TypeOf((*AssetArrayMapMapInput)(nil)).Elem(), AssetArrayMapMap{})
	RegisterInputType(reflect.TypeOf((*AssetMapArrayMapInput)(nil)).Elem(), AssetMapArrayMap{})
	RegisterInputType(reflect.TypeOf((*AssetMapMapArrayInput)(nil)).Elem(), AssetMapMapArray{})
	RegisterInputType(reflect.TypeOf((*AssetArrayMapArrayInput)(nil)).Elem(), AssetArrayMapArray{})
	RegisterInputType(reflect.TypeOf((*AssetArrayArrayMapInput)(nil)).Elem(), AssetArrayArrayMap{})
	RegisterInputType(reflect.TypeOf((*AssetArrayArrayArrayInput)(nil)).Elem(), AssetArrayArrayArray{})
	RegisterInputType(reflect.TypeOf((*AssetMapMapMapInput)(nil)).Elem(), AssetMapMapMap{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveArrayInput)(nil)).Elem(), AssetOrArchiveArray{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveMapInput)(nil)).Elem(), AssetOrArchiveMap{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveArrayMapInput)(nil)).Elem(), AssetOrArchiveArrayMap{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveMapArrayInput)(nil)).Elem(), AssetOrArchiveMapArray{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveMapMapInput)(nil)).Elem(), AssetOrArchiveMapMap{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveArrayArrayInput)(nil)).Elem(), AssetOrArchiveArrayArray{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveArrayMapMapInput)(nil)).Elem(), AssetOrArchiveArrayMapMap{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveMapArrayMapInput)(nil)).Elem(), AssetOrArchiveMapArrayMap{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveMapMapArrayInput)(nil)).Elem(), AssetOrArchiveMapMapArray{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveArrayMapArrayInput)(nil)).Elem(), AssetOrArchiveArrayMapArray{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveArrayArrayMapInput)(nil)).Elem(), AssetOrArchiveArrayArrayMap{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveArrayArrayArrayInput)(nil)).Elem(), AssetOrArchiveArrayArrayArray{})
	RegisterInputType(reflect.TypeOf((*AssetOrArchiveMapMapMapInput)(nil)).Elem(), AssetOrArchiveMapMapMap{})
	RegisterInputType(reflect.TypeOf((*BoolInput)(nil)).Elem(), Bool(false))
	RegisterInputType(reflect.TypeOf((*BoolPtrInput)(nil)).Elem(), Bool(false))
	RegisterInputType(reflect.TypeOf((*BoolArrayInput)(nil)).Elem(), BoolArray{})
	RegisterInputType(reflect.TypeOf((*BoolMapInput)(nil)).Elem(), BoolMap{})
	RegisterInputType(reflect.TypeOf((*BoolArrayMapInput)(nil)).Elem(), BoolArrayMap{})
	RegisterInputType(reflect.TypeOf((*BoolMapArrayInput)(nil)).Elem(), BoolMapArray{})
	RegisterInputType(reflect.TypeOf((*BoolMapMapInput)(nil)).Elem(), BoolMapMap{})
	RegisterInputType(reflect.TypeOf((*BoolArrayArrayInput)(nil)).Elem(), BoolArrayArray{})
	RegisterInputType(reflect.TypeOf((*BoolArrayMapMapInput)(nil)).Elem(), BoolArrayMapMap{})
	RegisterInputType(reflect.TypeOf((*BoolMapArrayMapInput)(nil)).Elem(), BoolMapArrayMap{})
	RegisterInputType(reflect.TypeOf((*BoolMapMapArrayInput)(nil)).Elem(), BoolMapMapArray{})
	RegisterInputType(reflect.TypeOf((*BoolArrayMapArrayInput)(nil)).Elem(), BoolArrayMapArray{})
	RegisterInputType(reflect.TypeOf((*BoolArrayArrayMapInput)(nil)).Elem(), BoolArrayArrayMap{})
	RegisterInputType(reflect.TypeOf((*BoolArrayArrayArrayInput)(nil)).Elem(), BoolArrayArrayArray{})
	RegisterInputType(reflect.TypeOf((*BoolMapMapMapInput)(nil)).Elem(), BoolMapMapMap{})
	RegisterInputType(reflect.TypeOf((*Float64Input)(nil)).Elem(), Float64(0))
	RegisterInputType(reflect.TypeOf((*Float64PtrInput)(nil)).Elem(), Float64(0))
	RegisterInputType(reflect.TypeOf((*Float64ArrayInput)(nil)).Elem(), Float64Array{})
	RegisterInputType(reflect.TypeOf((*Float64MapInput)(nil)).Elem(), Float64Map{})
	RegisterInputType(reflect.TypeOf((*Float64ArrayMapInput)(nil)).Elem(), Float64ArrayMap{})
	RegisterInputType(reflect.TypeOf((*Float64MapArrayInput)(nil)).Elem(), Float64MapArray{})
	RegisterInputType(reflect.TypeOf((*Float64MapMapInput)(nil)).Elem(), Float64MapMap{})
	RegisterInputType(reflect.TypeOf((*Float64ArrayArrayInput)(nil)).Elem(), Float64ArrayArray{})
	RegisterInputType(reflect.TypeOf((*Float64ArrayMapMapInput)(nil)).Elem(), Float64ArrayMapMap{})
	RegisterInputType(reflect.TypeOf((*Float64MapArrayMapInput)(nil)).Elem(), Float64MapArrayMap{})
	RegisterInputType(reflect.TypeOf((*Float64MapMapArrayInput)(nil)).Elem(), Float64MapMapArray{})
	RegisterInputType(reflect.TypeOf((*Float64ArrayMapArrayInput)(nil)).Elem(), Float64ArrayMapArray{})
	RegisterInputType(reflect.TypeOf((*Float64ArrayArrayMapInput)(nil)).Elem(), Float64ArrayArrayMap{})
	RegisterInputType(reflect.TypeOf((*Float64ArrayArrayArrayInput)(nil)).Elem(), Float64ArrayArrayArray{})
	RegisterInputType(reflect.TypeOf((*Float64MapMapMapInput)(nil)).Elem(), Float64MapMapMap{})
	RegisterInputType(reflect.TypeOf((*IDInput)(nil)).Elem(), ID(""))
	RegisterInputType(reflect.TypeOf((*IDPtrInput)(nil)).Elem(), ID(""))
	RegisterInputType(reflect.TypeOf((*IDArrayInput)(nil)).Elem(), IDArray{})
	RegisterInputType(reflect.TypeOf((*IDMapInput)(nil)).Elem(), IDMap{})
	RegisterInputType(reflect.TypeOf((*IDArrayMapInput)(nil)).Elem(), IDArrayMap{})
	RegisterInputType(reflect.TypeOf((*IDMapArrayInput)(nil)).Elem(), IDMapArray{})
	RegisterInputType(reflect.TypeOf((*IDMapMapInput)(nil)).Elem(), IDMapMap{})
	RegisterInputType(reflect.TypeOf((*IDArrayArrayInput)(nil)).Elem(), IDArrayArray{})
	RegisterInputType(reflect.TypeOf((*IDArrayMapMapInput)(nil)).Elem(), IDArrayMapMap{})
	RegisterInputType(reflect.TypeOf((*IDMapArrayMapInput)(nil)).Elem(), IDMapArrayMap{})
	RegisterInputType(reflect.TypeOf((*IDMapMapArrayInput)(nil)).Elem(), IDMapMapArray{})
	RegisterInputType(reflect.TypeOf((*IDArrayMapArrayInput)(nil)).Elem(), IDArrayMapArray{})
	RegisterInputType(reflect.TypeOf((*IDArrayArrayMapInput)(nil)).Elem(), IDArrayArrayMap{})
	RegisterInputType(reflect.TypeOf((*IDArrayArrayArrayInput)(nil)).Elem(), IDArrayArrayArray{})
	RegisterInputType(reflect.TypeOf((*IDMapMapMapInput)(nil)).Elem(), IDMapMapMap{})
	RegisterInputType(reflect.TypeOf((*ArrayInput)(nil)).Elem(), Array{})
	RegisterInputType(reflect.TypeOf((*MapInput)(nil)).Elem(), Map{})
	RegisterInputType(reflect.TypeOf((*ArrayMapInput)(nil)).Elem(), ArrayMap{})
	RegisterInputType(reflect.TypeOf((*MapArrayInput)(nil)).Elem(), MapArray{})
	RegisterInputType(reflect.TypeOf((*MapMapInput)(nil)).Elem(), MapMap{})
	RegisterInputType(reflect.TypeOf((*ArrayArrayInput)(nil)).Elem(), ArrayArray{})
	RegisterInputType(reflect.TypeOf((*ArrayMapMapInput)(nil)).Elem(), ArrayMapMap{})
	RegisterInputType(reflect.TypeOf((*MapArrayMapInput)(nil)).Elem(), MapArrayMap{})
	RegisterInputType(reflect.TypeOf((*MapMapArrayInput)(nil)).Elem(), MapMapArray{})
	RegisterInputType(reflect.TypeOf((*ArrayMapArrayInput)(nil)).Elem(), ArrayMapArray{})
	RegisterInputType(reflect.TypeOf((*ArrayArrayMapInput)(nil)).Elem(), ArrayArrayMap{})
	RegisterInputType(reflect.TypeOf((*ArrayArrayArrayInput)(nil)).Elem(), ArrayArrayArray{})
	RegisterInputType(reflect.TypeOf((*MapMapMapInput)(nil)).Elem(), MapMapMap{})
	RegisterInputType(reflect.TypeOf((*IntInput)(nil)).Elem(), Int(0))
	RegisterInputType(reflect.TypeOf((*IntPtrInput)(nil)).Elem(), Int(0))
	RegisterInputType(reflect.TypeOf((*IntArrayInput)(nil)).Elem(), IntArray{})
	RegisterInputType(reflect.TypeOf((*IntMapInput)(nil)).Elem(), IntMap{})
	RegisterInputType(reflect.TypeOf((*IntArrayMapInput)(nil)).Elem(), IntArrayMap{})
	RegisterInputType(reflect.TypeOf((*IntMapArrayInput)(nil)).Elem(), IntMapArray{})
	RegisterInputType(reflect.TypeOf((*IntMapMapInput)(nil)).Elem(), IntMapMap{})
	RegisterInputType(reflect.TypeOf((*IntArrayArrayInput)(nil)).Elem(), IntArrayArray{})
	RegisterInputType(reflect.TypeOf((*IntArrayMapMapInput)(nil)).Elem(), IntArrayMapMap{})
	RegisterInputType(reflect.TypeOf((*IntMapArrayMapInput)(nil)).Elem(), IntMapArrayMap{})
	RegisterInputType(reflect.TypeOf((*IntMapMapArrayInput)(nil)).Elem(), IntMapMapArray{})
	RegisterInputType(reflect.TypeOf((*IntArrayMapArrayInput)(nil)).Elem(), IntArrayMapArray{})
	RegisterInputType(reflect.TypeOf((*IntArrayArrayMapInput)(nil)).Elem(), IntArrayArrayMap{})
	RegisterInputType(reflect.TypeOf((*IntArrayArrayArrayInput)(nil)).Elem(), IntArrayArrayArray{})
	RegisterInputType(reflect.TypeOf((*IntMapMapMapInput)(nil)).Elem(), IntMapMapMap{})
	RegisterInputType(reflect.TypeOf((*StringInput)(nil)).Elem(), String(""))
	RegisterInputType(reflect.TypeOf((*StringPtrInput)(nil)).Elem(), String(""))
	RegisterInputType(reflect.TypeOf((*StringArrayInput)(nil)).Elem(), StringArray{})
	RegisterInputType(reflect.TypeOf((*StringMapInput)(nil)).Elem(), StringMap{})
	RegisterInputType(reflect.TypeOf((*StringArrayMapInput)(nil)).Elem(), StringArrayMap{})
	RegisterInputType(reflect.TypeOf((*StringMapArrayInput)(nil)).Elem(), StringMapArray{})
	RegisterInputType(reflect.TypeOf((*StringMapMapInput)(nil)).Elem(), StringMapMap{})
	RegisterInputType(reflect.TypeOf((*StringArrayArrayInput)(nil)).Elem(), StringArrayArray{})
	RegisterInputType(reflect.TypeOf((*StringArrayMapMapInput)(nil)).Elem(), StringArrayMapMap{})
	RegisterInputType(reflect.TypeOf((*StringMapArrayMapInput)(nil)).Elem(), StringMapArrayMap{})
	RegisterInputType(reflect.TypeOf((*StringMapMapArrayInput)(nil)).Elem(), StringMapMapArray{})
	RegisterInputType(reflect.TypeOf((*StringArrayMapArrayInput)(nil)).Elem(), StringArrayMapArray{})
	RegisterInputType(reflect.TypeOf((*StringArrayArrayMapInput)(nil)).Elem(), StringArrayArrayMap{})
	RegisterInputType(reflect.TypeOf((*StringArrayArrayArrayInput)(nil)).Elem(), StringArrayArrayArray{})
	RegisterInputType(reflect.TypeOf((*StringMapMapMapInput)(nil)).Elem(), StringMapMapMap{})
	RegisterInputType(reflect.TypeOf((*URNInput)(nil)).Elem(), URN(""))
	RegisterInputType(reflect.TypeOf((*URNPtrInput)(nil)).Elem(), URN(""))
	RegisterInputType(reflect.TypeOf((*URNArrayInput)(nil)).Elem(), URNArray{})
	RegisterInputType(reflect.TypeOf((*URNMapInput)(nil)).Elem(), URNMap{})
	RegisterInputType(reflect.TypeOf((*URNArrayMapInput)(nil)).Elem(), URNArrayMap{})
	RegisterInputType(reflect.TypeOf((*URNMapArrayInput)(nil)).Elem(), URNMapArray{})
	RegisterInputType(reflect.TypeOf((*URNMapMapInput)(nil)).Elem(), URNMapMap{})
	RegisterInputType(reflect.TypeOf((*URNArrayArrayInput)(nil)).Elem(), URNArrayArray{})
	RegisterInputType(reflect.TypeOf((*URNArrayMapMapInput)(nil)).Elem(), URNArrayMapMap{})
	RegisterInputType(reflect.TypeOf((*URNMapArrayMapInput)(nil)).Elem(), URNMapArrayMap{})
	RegisterInputType(reflect.TypeOf((*URNMapMapArrayInput)(nil)).Elem(), URNMapMapArray{})
	RegisterInputType(reflect.TypeOf((*URNArrayMapArrayInput)(nil)).Elem(), URNArrayMapArray{})
	RegisterInputType(reflect.TypeOf((*URNArrayArrayMapInput)(nil)).Elem(), URNArrayArrayMap{})
	RegisterInputType(reflect.TypeOf((*URNArrayArrayArrayInput)(nil)).Elem(), URNArrayArrayArray{})
	RegisterInputType(reflect.TypeOf((*URNMapMapMapInput)(nil)).Elem(), URNMapMapMap{})
	RegisterOutputType(ArchiveOutput{})
	RegisterOutputType(ArchiveArrayOutput{})
	RegisterOutputType(ArchiveMapOutput{})
	RegisterOutputType(ArchiveArrayMapOutput{})
	RegisterOutputType(ArchiveMapArrayOutput{})
	RegisterOutputType(ArchiveMapMapOutput{})
	RegisterOutputType(ArchiveArrayArrayOutput{})
	RegisterOutputType(ArchiveArrayMapMapOutput{})
	RegisterOutputType(ArchiveMapArrayMapOutput{})
	RegisterOutputType(ArchiveMapMapArrayOutput{})
	RegisterOutputType(ArchiveArrayMapArrayOutput{})
	RegisterOutputType(ArchiveArrayArrayMapOutput{})
	RegisterOutputType(ArchiveArrayArrayArrayOutput{})
	RegisterOutputType(ArchiveMapMapMapOutput{})
	RegisterOutputType(AssetOutput{})
	RegisterOutputType(AssetArrayOutput{})
	RegisterOutputType(AssetMapOutput{})
	RegisterOutputType(AssetArrayMapOutput{})
	RegisterOutputType(AssetMapArrayOutput{})
	RegisterOutputType(AssetMapMapOutput{})
	RegisterOutputType(AssetArrayArrayOutput{})
	RegisterOutputType(AssetArrayMapMapOutput{})
	RegisterOutputType(AssetMapArrayMapOutput{})
	RegisterOutputType(AssetMapMapArrayOutput{})
	RegisterOutputType(AssetArrayMapArrayOutput{})
	RegisterOutputType(AssetArrayArrayMapOutput{})
	RegisterOutputType(AssetArrayArrayArrayOutput{})
	RegisterOutputType(AssetMapMapMapOutput{})
	RegisterOutputType(AssetOrArchiveOutput{})
	RegisterOutputType(AssetOrArchiveArrayOutput{})
	RegisterOutputType(AssetOrArchiveMapOutput{})
	RegisterOutputType(AssetOrArchiveArrayMapOutput{})
	RegisterOutputType(AssetOrArchiveMapArrayOutput{})
	RegisterOutputType(AssetOrArchiveMapMapOutput{})
	RegisterOutputType(AssetOrArchiveArrayArrayOutput{})
	RegisterOutputType(AssetOrArchiveArrayMapMapOutput{})
	RegisterOutputType(AssetOrArchiveMapArrayMapOutput{})
	RegisterOutputType(AssetOrArchiveMapMapArrayOutput{})
	RegisterOutputType(AssetOrArchiveArrayMapArrayOutput{})
	RegisterOutputType(AssetOrArchiveArrayArrayMapOutput{})
	RegisterOutputType(AssetOrArchiveArrayArrayArrayOutput{})
	RegisterOutputType(AssetOrArchiveMapMapMapOutput{})
	RegisterOutputType(BoolOutput{})
	RegisterOutputType(BoolPtrOutput{})
	RegisterOutputType(BoolArrayOutput{})
	RegisterOutputType(BoolMapOutput{})
	RegisterOutputType(BoolArrayMapOutput{})
	RegisterOutputType(BoolMapArrayOutput{})
	RegisterOutputType(BoolMapMapOutput{})
	RegisterOutputType(BoolArrayArrayOutput{})
	RegisterOutputType(BoolArrayMapMapOutput{})
	RegisterOutputType(BoolMapArrayMapOutput{})
	RegisterOutputType(BoolMapMapArrayOutput{})
	RegisterOutputType(BoolArrayMapArrayOutput{})
	RegisterOutputType(BoolArrayArrayMapOutput{})
	RegisterOutputType(BoolArrayArrayArrayOutput{})
	RegisterOutputType(BoolMapMapMapOutput{})
	RegisterOutputType(Float64Output{})
	RegisterOutputType(Float64PtrOutput{})
	RegisterOutputType(Float64ArrayOutput{})
	RegisterOutputType(Float64MapOutput{})
	RegisterOutputType(Float64ArrayMapOutput{})
	RegisterOutputType(Float64MapArrayOutput{})
	RegisterOutputType(Float64MapMapOutput{})
	RegisterOutputType(Float64ArrayArrayOutput{})
	RegisterOutputType(Float64ArrayMapMapOutput{})
	RegisterOutputType(Float64MapArrayMapOutput{})
	RegisterOutputType(Float64MapMapArrayOutput{})
	RegisterOutputType(Float64ArrayMapArrayOutput{})
	RegisterOutputType(Float64ArrayArrayMapOutput{})
	RegisterOutputType(Float64ArrayArrayArrayOutput{})
	RegisterOutputType(Float64MapMapMapOutput{})
	RegisterOutputType(IDOutput{})
	RegisterOutputType(IDPtrOutput{})
	RegisterOutputType(IDArrayOutput{})
	RegisterOutputType(IDMapOutput{})
	RegisterOutputType(IDArrayMapOutput{})
	RegisterOutputType(IDMapArrayOutput{})
	RegisterOutputType(IDMapMapOutput{})
	RegisterOutputType(IDArrayArrayOutput{})
	RegisterOutputType(IDArrayMapMapOutput{})
	RegisterOutputType(IDMapArrayMapOutput{})
	RegisterOutputType(IDMapMapArrayOutput{})
	RegisterOutputType(IDArrayMapArrayOutput{})
	RegisterOutputType(IDArrayArrayMapOutput{})
	RegisterOutputType(IDArrayArrayArrayOutput{})
	RegisterOutputType(IDMapMapMapOutput{})
	RegisterOutputType(ArrayOutput{})
	RegisterOutputType(MapOutput{})
	RegisterOutputType(ArrayMapOutput{})
	RegisterOutputType(MapArrayOutput{})
	RegisterOutputType(MapMapOutput{})
	RegisterOutputType(ArrayArrayOutput{})
	RegisterOutputType(ArrayMapMapOutput{})
	RegisterOutputType(MapArrayMapOutput{})
	RegisterOutputType(MapMapArrayOutput{})
	RegisterOutputType(ArrayMapArrayOutput{})
	RegisterOutputType(ArrayArrayMapOutput{})
	RegisterOutputType(ArrayArrayArrayOutput{})
	RegisterOutputType(MapMapMapOutput{})
	RegisterOutputType(IntOutput{})
	RegisterOutputType(IntPtrOutput{})
	RegisterOutputType(IntArrayOutput{})
	RegisterOutputType(IntMapOutput{})
	RegisterOutputType(IntArrayMapOutput{})
	RegisterOutputType(IntMapArrayOutput{})
	RegisterOutputType(IntMapMapOutput{})
	RegisterOutputType(IntArrayArrayOutput{})
	RegisterOutputType(IntArrayMapMapOutput{})
	RegisterOutputType(IntMapArrayMapOutput{})
	RegisterOutputType(IntMapMapArrayOutput{})
	RegisterOutputType(IntArrayMapArrayOutput{})
	RegisterOutputType(IntArrayArrayMapOutput{})
	RegisterOutputType(IntArrayArrayArrayOutput{})
	RegisterOutputType(IntMapMapMapOutput{})
	RegisterOutputType(StringOutput{})
	RegisterOutputType(StringPtrOutput{})
	RegisterOutputType(StringArrayOutput{})
	RegisterOutputType(StringMapOutput{})
	RegisterOutputType(StringArrayMapOutput{})
	RegisterOutputType(StringMapArrayOutput{})
	RegisterOutputType(StringMapMapOutput{})
	RegisterOutputType(StringArrayArrayOutput{})
	RegisterOutputType(StringArrayMapMapOutput{})
	RegisterOutputType(StringMapArrayMapOutput{})
	RegisterOutputType(StringMapMapArrayOutput{})
	RegisterOutputType(StringArrayMapArrayOutput{})
	RegisterOutputType(StringArrayArrayMapOutput{})
	RegisterOutputType(StringArrayArrayArrayOutput{})
	RegisterOutputType(StringMapMapMapOutput{})
	RegisterOutputType(URNOutput{})
	RegisterOutputType(URNPtrOutput{})
	RegisterOutputType(URNArrayOutput{})
	RegisterOutputType(URNMapOutput{})
	RegisterOutputType(URNArrayMapOutput{})
	RegisterOutputType(URNMapArrayOutput{})
	RegisterOutputType(URNMapMapOutput{})
	RegisterOutputType(URNArrayArrayOutput{})
	RegisterOutputType(URNArrayMapMapOutput{})
	RegisterOutputType(URNMapArrayMapOutput{})
	RegisterOutputType(URNMapMapArrayOutput{})
	RegisterOutputType(URNArrayMapArrayOutput{})
	RegisterOutputType(URNArrayArrayMapOutput{})
	RegisterOutputType(URNArrayArrayArrayOutput{})
	RegisterOutputType(URNMapMapMapOutput{})
}
