// Copyright 2016-2023, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.5
// source: pulumi/language.proto

package pulumirpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LanguageRuntime_Handshake_FullMethodName              = "/pulumirpc.LanguageRuntime/Handshake"
	LanguageRuntime_GetRequiredPlugins_FullMethodName     = "/pulumirpc.LanguageRuntime/GetRequiredPlugins"
	LanguageRuntime_GetRequiredPackages_FullMethodName    = "/pulumirpc.LanguageRuntime/GetRequiredPackages"
	LanguageRuntime_Run_FullMethodName                    = "/pulumirpc.LanguageRuntime/Run"
	LanguageRuntime_GetPluginInfo_FullMethodName          = "/pulumirpc.LanguageRuntime/GetPluginInfo"
	LanguageRuntime_InstallDependencies_FullMethodName    = "/pulumirpc.LanguageRuntime/InstallDependencies"
	LanguageRuntime_RuntimeOptionsPrompts_FullMethodName  = "/pulumirpc.LanguageRuntime/RuntimeOptionsPrompts"
	LanguageRuntime_About_FullMethodName                  = "/pulumirpc.LanguageRuntime/About"
	LanguageRuntime_GetProgramDependencies_FullMethodName = "/pulumirpc.LanguageRuntime/GetProgramDependencies"
	LanguageRuntime_RunPlugin_FullMethodName              = "/pulumirpc.LanguageRuntime/RunPlugin"
	LanguageRuntime_GenerateProgram_FullMethodName        = "/pulumirpc.LanguageRuntime/GenerateProgram"
	LanguageRuntime_GenerateProject_FullMethodName        = "/pulumirpc.LanguageRuntime/GenerateProject"
	LanguageRuntime_GeneratePackage_FullMethodName        = "/pulumirpc.LanguageRuntime/GeneratePackage"
	LanguageRuntime_Pack_FullMethodName                   = "/pulumirpc.LanguageRuntime/Pack"
	LanguageRuntime_Link_FullMethodName                   = "/pulumirpc.LanguageRuntime/Link"
	LanguageRuntime_Cancel_FullMethodName                 = "/pulumirpc.LanguageRuntime/Cancel"
)

// LanguageRuntimeClient is the client API for LanguageRuntime service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The LanguageRuntime service defines a standard interface for [language hosts/runtimes](languages). At a high level, a
// language runtime provides the ability to execute programs, install and query dependencies, and generate code for a
// specific language.
type LanguageRuntimeClient interface {
	// `Handshake` is the first call made by the engine to a language host. It is used to pass the engine's address to
	// the language host so that it may establish its own connections back, and to establish protocol configuration that
	// will be used to communicate between the two parties.
	Handshake(ctx context.Context, in *LanguageHandshakeRequest, opts ...grpc.CallOption) (*LanguageHandshakeResponse, error)
	// Deprecated: Do not use.
	// `GetRequiredPlugins` computes the complete set of anticipated [plugins](plugins) required by a Pulumi program.
	// Among other things, it is intended to be used to pre-install plugins before running a program with
	// [](pulumirpc.LanguageRuntime.Run), to avoid the need to install them on-demand in response to [resource
	// registrations](resource-registration) sent back from the running program to the engine.
	//
	// :::{important}
	// The use of `GetRequiredPlugins` is deprecated in favour of [](pulumirpc.LanguageRuntime.GetRequiredPackages),
	// which returns more granular information about which plugins are required by which packages.
	// :::
	GetRequiredPlugins(ctx context.Context, in *GetRequiredPluginsRequest, opts ...grpc.CallOption) (*GetRequiredPluginsResponse, error)
	// `GetRequiredPackages` computes the complete set of anticipated [packages](pulumirpc.PackageDependency) required
	// by a program. It is used to pre-install packages before running a program with [](pulumirpc.LanguageRuntime.Run),
	// to avoid the need to install them on-demand in response to [resource registrations](resource-registration) sent
	// back from the running program to the engine. Moreover, when importing resources into a stack, it is used to
	// determine which plugins are required to service the import of a given resource, since given the presence of
	// [parameterized providers](parameterized-providers), it is not in general true that a package name corresponds 1:1
	// with a plugin name. It replaces [](pulumirpc.LanguageRuntime.GetRequiredPlugins) in the face of [parameterized
	// providers](parameterized-providers), which as mentioned above can enable multiple instances of the same plugin to
	// provide multiple packages.
	GetRequiredPackages(ctx context.Context, in *GetRequiredPackagesRequest, opts ...grpc.CallOption) (*GetRequiredPackagesResponse, error)
	// `Run` executes a Pulumi program, returning information about whether or not the program produced an error.
	Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*RunResponse, error)
	// `GetPluginInfo` returns information about the [plugin](plugins) implementing this language runtime.
	GetPluginInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo, error)
	// `InstallDependencies` accepts a request specifying a Pulumi project and program that can be executed with
	// [](pulumirpc.LanguageRuntime.Run) and installs the dependencies for that program (e.g. by running `npm install`
	// for NodeJS, or `pip install` for Python). Since dependency installation could take a while, and callers may wish
	// to report on its progress, this method returns a stream of [](pulumirpc.InstallDependenciesResponse) messages
	// containing information about standard error and output.
	InstallDependencies(ctx context.Context, in *InstallDependenciesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InstallDependenciesResponse], error)
	// `RuntimeOptionsPrompts` accepts a request specifying a Pulumi project and returns a list of additional prompts to
	// ask during `pulumi new`.
	RuntimeOptionsPrompts(ctx context.Context, in *RuntimeOptionsRequest, opts ...grpc.CallOption) (*RuntimeOptionsResponse, error)
	// `About` returns information about the language runtime being used.
	About(ctx context.Context, in *AboutRequest, opts ...grpc.CallOption) (*AboutResponse, error)
	// `GetProgramDependencies` computes the set of language-level dependencies (e.g. NPM packages for NodeJS, or Maven
	// libraries for Java) required by a program.
	GetProgramDependencies(ctx context.Context, in *GetProgramDependenciesRequest, opts ...grpc.CallOption) (*GetProgramDependenciesResponse, error)
	// `RunPlugin` is used to execute a program written in this host's language that implements a Pulumi
	// [plugin](plugins). It it is plugins what [](pulumirpc.LanguageRuntime.Run) is to programs. Since a plugin is not
	// expected to terminate until instructed/for a long time, this method returns a stream of
	// [](pulumirpc.RunPluginResponse) messages containing information about standard error and output, as well as the
	// exit code of the plugin when it does terminate.
	RunPlugin(ctx context.Context, in *RunPluginRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RunPluginResponse], error)
	// `GenerateProgram` generates code in this host's language that implements the given [PCL](pcl) program. Unlike
	// [](pulumirpc.LanguageRuntime.GenerateProject), this method *only* generates program code, and does not e.g.
	// generate a `package.json` for a NodeJS project that details how to run that code.
	// [](pulumirpc.LanguageRuntime.GenerateProject), this method underpins ["programgen"](programgen) and the main
	// functionality powering `pulumi convert`.
	GenerateProgram(ctx context.Context, in *GenerateProgramRequest, opts ...grpc.CallOption) (*GenerateProgramResponse, error)
	// `GenerateProject` generates code in this host's language that implements the given [PCL](pcl) program and wraps
	// it in some language-specific notion of a "project", where a project is a buildable or runnable artifact. In this
	// sense, `GenerateProject`'s output is a superset of that of [](pulumirpc.LanguageRuntime.GenerateProgram). For
	// instance, when generating a NodeJS project, this method might generate a corresponding `package.json` file, as
	// well as the relevant NodeJS program code. Along with [](pulumirpc.LanguageRuntime.GenerateProgram), this method
	// underpins ["programgen"](programgen) and the main functionality powering `pulumi convert`.
	GenerateProject(ctx context.Context, in *GenerateProjectRequest, opts ...grpc.CallOption) (*GenerateProjectResponse, error)
	// `GeneratePackage` generates code in this host's language that implements an [SDK](sdkgen) ("sdkgen") for the
	// given Pulumi package, as specified by a [schema](schema).
	GeneratePackage(ctx context.Context, in *GeneratePackageRequest, opts ...grpc.CallOption) (*GeneratePackageResponse, error)
	// `Pack` accepts a request specifying a generated SDK package and packs it into a language-specific artifact. For
	// instance, in the case of Java, it might produce a JAR file from a list of `.java` sources; in the case of NodeJS,
	// a `.tgz` file might be produced from a list of `.js` sources; and so on. Presently, `Pack` is primarily used in
	// [language conformance tests](language-conformance-tests), though it is intended to be used more widely in future
	// to standardise e.g. provider publishing workflows.
	Pack(ctx context.Context, in *PackRequest, opts ...grpc.CallOption) (*PackResponse, error)
	// `Link` links a local dependency into a project.
	Link(ctx context.Context, in *LinkRequest, opts ...grpc.CallOption) (*LinkResponse, error)
	// `Cancel` signals the language runtime to gracefully shut down and abort any ongoing operations.
	// Operations aborted in this way will return an error.
	Cancel(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type languageRuntimeClient struct {
	cc grpc.ClientConnInterface
}

func NewLanguageRuntimeClient(cc grpc.ClientConnInterface) LanguageRuntimeClient {
	return &languageRuntimeClient{cc}
}

func (c *languageRuntimeClient) Handshake(ctx context.Context, in *LanguageHandshakeRequest, opts ...grpc.CallOption) (*LanguageHandshakeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LanguageHandshakeResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_Handshake_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *languageRuntimeClient) GetRequiredPlugins(ctx context.Context, in *GetRequiredPluginsRequest, opts ...grpc.CallOption) (*GetRequiredPluginsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRequiredPluginsResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_GetRequiredPlugins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) GetRequiredPackages(ctx context.Context, in *GetRequiredPackagesRequest, opts ...grpc.CallOption) (*GetRequiredPackagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRequiredPackagesResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_GetRequiredPackages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*RunResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_Run_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) GetPluginInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PluginInfo)
	err := c.cc.Invoke(ctx, LanguageRuntime_GetPluginInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) InstallDependencies(ctx context.Context, in *InstallDependenciesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InstallDependenciesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LanguageRuntime_ServiceDesc.Streams[0], LanguageRuntime_InstallDependencies_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InstallDependenciesRequest, InstallDependenciesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LanguageRuntime_InstallDependenciesClient = grpc.ServerStreamingClient[InstallDependenciesResponse]

func (c *languageRuntimeClient) RuntimeOptionsPrompts(ctx context.Context, in *RuntimeOptionsRequest, opts ...grpc.CallOption) (*RuntimeOptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuntimeOptionsResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_RuntimeOptionsPrompts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) About(ctx context.Context, in *AboutRequest, opts ...grpc.CallOption) (*AboutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AboutResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_About_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) GetProgramDependencies(ctx context.Context, in *GetProgramDependenciesRequest, opts ...grpc.CallOption) (*GetProgramDependenciesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProgramDependenciesResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_GetProgramDependencies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) RunPlugin(ctx context.Context, in *RunPluginRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RunPluginResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LanguageRuntime_ServiceDesc.Streams[1], LanguageRuntime_RunPlugin_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RunPluginRequest, RunPluginResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LanguageRuntime_RunPluginClient = grpc.ServerStreamingClient[RunPluginResponse]

func (c *languageRuntimeClient) GenerateProgram(ctx context.Context, in *GenerateProgramRequest, opts ...grpc.CallOption) (*GenerateProgramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateProgramResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_GenerateProgram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) GenerateProject(ctx context.Context, in *GenerateProjectRequest, opts ...grpc.CallOption) (*GenerateProjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateProjectResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_GenerateProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) GeneratePackage(ctx context.Context, in *GeneratePackageRequest, opts ...grpc.CallOption) (*GeneratePackageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GeneratePackageResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_GeneratePackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) Pack(ctx context.Context, in *PackRequest, opts ...grpc.CallOption) (*PackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PackResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_Pack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) Link(ctx context.Context, in *LinkRequest, opts ...grpc.CallOption) (*LinkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LinkResponse)
	err := c.cc.Invoke(ctx, LanguageRuntime_Link_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageRuntimeClient) Cancel(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LanguageRuntime_Cancel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LanguageRuntimeServer is the server API for LanguageRuntime service.
// All implementations must embed UnimplementedLanguageRuntimeServer
// for forward compatibility.
//
// The LanguageRuntime service defines a standard interface for [language hosts/runtimes](languages). At a high level, a
// language runtime provides the ability to execute programs, install and query dependencies, and generate code for a
// specific language.
type LanguageRuntimeServer interface {
	// `Handshake` is the first call made by the engine to a language host. It is used to pass the engine's address to
	// the language host so that it may establish its own connections back, and to establish protocol configuration that
	// will be used to communicate between the two parties.
	Handshake(context.Context, *LanguageHandshakeRequest) (*LanguageHandshakeResponse, error)
	// Deprecated: Do not use.
	// `GetRequiredPlugins` computes the complete set of anticipated [plugins](plugins) required by a Pulumi program.
	// Among other things, it is intended to be used to pre-install plugins before running a program with
	// [](pulumirpc.LanguageRuntime.Run), to avoid the need to install them on-demand in response to [resource
	// registrations](resource-registration) sent back from the running program to the engine.
	//
	// :::{important}
	// The use of `GetRequiredPlugins` is deprecated in favour of [](pulumirpc.LanguageRuntime.GetRequiredPackages),
	// which returns more granular information about which plugins are required by which packages.
	// :::
	GetRequiredPlugins(context.Context, *GetRequiredPluginsRequest) (*GetRequiredPluginsResponse, error)
	// `GetRequiredPackages` computes the complete set of anticipated [packages](pulumirpc.PackageDependency) required
	// by a program. It is used to pre-install packages before running a program with [](pulumirpc.LanguageRuntime.Run),
	// to avoid the need to install them on-demand in response to [resource registrations](resource-registration) sent
	// back from the running program to the engine. Moreover, when importing resources into a stack, it is used to
	// determine which plugins are required to service the import of a given resource, since given the presence of
	// [parameterized providers](parameterized-providers), it is not in general true that a package name corresponds 1:1
	// with a plugin name. It replaces [](pulumirpc.LanguageRuntime.GetRequiredPlugins) in the face of [parameterized
	// providers](parameterized-providers), which as mentioned above can enable multiple instances of the same plugin to
	// provide multiple packages.
	GetRequiredPackages(context.Context, *GetRequiredPackagesRequest) (*GetRequiredPackagesResponse, error)
	// `Run` executes a Pulumi program, returning information about whether or not the program produced an error.
	Run(context.Context, *RunRequest) (*RunResponse, error)
	// `GetPluginInfo` returns information about the [plugin](plugins) implementing this language runtime.
	GetPluginInfo(context.Context, *emptypb.Empty) (*PluginInfo, error)
	// `InstallDependencies` accepts a request specifying a Pulumi project and program that can be executed with
	// [](pulumirpc.LanguageRuntime.Run) and installs the dependencies for that program (e.g. by running `npm install`
	// for NodeJS, or `pip install` for Python). Since dependency installation could take a while, and callers may wish
	// to report on its progress, this method returns a stream of [](pulumirpc.InstallDependenciesResponse) messages
	// containing information about standard error and output.
	InstallDependencies(*InstallDependenciesRequest, grpc.ServerStreamingServer[InstallDependenciesResponse]) error
	// `RuntimeOptionsPrompts` accepts a request specifying a Pulumi project and returns a list of additional prompts to
	// ask during `pulumi new`.
	RuntimeOptionsPrompts(context.Context, *RuntimeOptionsRequest) (*RuntimeOptionsResponse, error)
	// `About` returns information about the language runtime being used.
	About(context.Context, *AboutRequest) (*AboutResponse, error)
	// `GetProgramDependencies` computes the set of language-level dependencies (e.g. NPM packages for NodeJS, or Maven
	// libraries for Java) required by a program.
	GetProgramDependencies(context.Context, *GetProgramDependenciesRequest) (*GetProgramDependenciesResponse, error)
	// `RunPlugin` is used to execute a program written in this host's language that implements a Pulumi
	// [plugin](plugins). It it is plugins what [](pulumirpc.LanguageRuntime.Run) is to programs. Since a plugin is not
	// expected to terminate until instructed/for a long time, this method returns a stream of
	// [](pulumirpc.RunPluginResponse) messages containing information about standard error and output, as well as the
	// exit code of the plugin when it does terminate.
	RunPlugin(*RunPluginRequest, grpc.ServerStreamingServer[RunPluginResponse]) error
	// `GenerateProgram` generates code in this host's language that implements the given [PCL](pcl) program. Unlike
	// [](pulumirpc.LanguageRuntime.GenerateProject), this method *only* generates program code, and does not e.g.
	// generate a `package.json` for a NodeJS project that details how to run that code.
	// [](pulumirpc.LanguageRuntime.GenerateProject), this method underpins ["programgen"](programgen) and the main
	// functionality powering `pulumi convert`.
	GenerateProgram(context.Context, *GenerateProgramRequest) (*GenerateProgramResponse, error)
	// `GenerateProject` generates code in this host's language that implements the given [PCL](pcl) program and wraps
	// it in some language-specific notion of a "project", where a project is a buildable or runnable artifact. In this
	// sense, `GenerateProject`'s output is a superset of that of [](pulumirpc.LanguageRuntime.GenerateProgram). For
	// instance, when generating a NodeJS project, this method might generate a corresponding `package.json` file, as
	// well as the relevant NodeJS program code. Along with [](pulumirpc.LanguageRuntime.GenerateProgram), this method
	// underpins ["programgen"](programgen) and the main functionality powering `pulumi convert`.
	GenerateProject(context.Context, *GenerateProjectRequest) (*GenerateProjectResponse, error)
	// `GeneratePackage` generates code in this host's language that implements an [SDK](sdkgen) ("sdkgen") for the
	// given Pulumi package, as specified by a [schema](schema).
	GeneratePackage(context.Context, *GeneratePackageRequest) (*GeneratePackageResponse, error)
	// `Pack` accepts a request specifying a generated SDK package and packs it into a language-specific artifact. For
	// instance, in the case of Java, it might produce a JAR file from a list of `.java` sources; in the case of NodeJS,
	// a `.tgz` file might be produced from a list of `.js` sources; and so on. Presently, `Pack` is primarily used in
	// [language conformance tests](language-conformance-tests), though it is intended to be used more widely in future
	// to standardise e.g. provider publishing workflows.
	Pack(context.Context, *PackRequest) (*PackResponse, error)
	// `Link` links a local dependency into a project.
	Link(context.Context, *LinkRequest) (*LinkResponse, error)
	// `Cancel` signals the language runtime to gracefully shut down and abort any ongoing operations.
	// Operations aborted in this way will return an error.
	Cancel(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedLanguageRuntimeServer()
}

// UnimplementedLanguageRuntimeServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLanguageRuntimeServer struct{}

func (UnimplementedLanguageRuntimeServer) Handshake(context.Context, *LanguageHandshakeRequest) (*LanguageHandshakeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Handshake not implemented")
}
func (UnimplementedLanguageRuntimeServer) GetRequiredPlugins(context.Context, *GetRequiredPluginsRequest) (*GetRequiredPluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRequiredPlugins not implemented")
}
func (UnimplementedLanguageRuntimeServer) GetRequiredPackages(context.Context, *GetRequiredPackagesRequest) (*GetRequiredPackagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRequiredPackages not implemented")
}
func (UnimplementedLanguageRuntimeServer) Run(context.Context, *RunRequest) (*RunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Run not implemented")
}
func (UnimplementedLanguageRuntimeServer) GetPluginInfo(context.Context, *emptypb.Empty) (*PluginInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPluginInfo not implemented")
}
func (UnimplementedLanguageRuntimeServer) InstallDependencies(*InstallDependenciesRequest, grpc.ServerStreamingServer[InstallDependenciesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method InstallDependencies not implemented")
}
func (UnimplementedLanguageRuntimeServer) RuntimeOptionsPrompts(context.Context, *RuntimeOptionsRequest) (*RuntimeOptionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuntimeOptionsPrompts not implemented")
}
func (UnimplementedLanguageRuntimeServer) About(context.Context, *AboutRequest) (*AboutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method About not implemented")
}
func (UnimplementedLanguageRuntimeServer) GetProgramDependencies(context.Context, *GetProgramDependenciesRequest) (*GetProgramDependenciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgramDependencies not implemented")
}
func (UnimplementedLanguageRuntimeServer) RunPlugin(*RunPluginRequest, grpc.ServerStreamingServer[RunPluginResponse]) error {
	return status.Errorf(codes.Unimplemented, "method RunPlugin not implemented")
}
func (UnimplementedLanguageRuntimeServer) GenerateProgram(context.Context, *GenerateProgramRequest) (*GenerateProgramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateProgram not implemented")
}
func (UnimplementedLanguageRuntimeServer) GenerateProject(context.Context, *GenerateProjectRequest) (*GenerateProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateProject not implemented")
}
func (UnimplementedLanguageRuntimeServer) GeneratePackage(context.Context, *GeneratePackageRequest) (*GeneratePackageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GeneratePackage not implemented")
}
func (UnimplementedLanguageRuntimeServer) Pack(context.Context, *PackRequest) (*PackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pack not implemented")
}
func (UnimplementedLanguageRuntimeServer) Link(context.Context, *LinkRequest) (*LinkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Link not implemented")
}
func (UnimplementedLanguageRuntimeServer) Cancel(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (UnimplementedLanguageRuntimeServer) mustEmbedUnimplementedLanguageRuntimeServer() {}
func (UnimplementedLanguageRuntimeServer) testEmbeddedByValue()                         {}

// UnsafeLanguageRuntimeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LanguageRuntimeServer will
// result in compilation errors.
type UnsafeLanguageRuntimeServer interface {
	mustEmbedUnimplementedLanguageRuntimeServer()
}

func RegisterLanguageRuntimeServer(s grpc.ServiceRegistrar, srv LanguageRuntimeServer) {
	// If the following call pancis, it indicates UnimplementedLanguageRuntimeServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LanguageRuntime_ServiceDesc, srv)
}

func _LanguageRuntime_Handshake_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LanguageHandshakeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).Handshake(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_Handshake_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).Handshake(ctx, req.(*LanguageHandshakeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_GetRequiredPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequiredPluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).GetRequiredPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_GetRequiredPlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).GetRequiredPlugins(ctx, req.(*GetRequiredPluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_GetRequiredPackages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequiredPackagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).GetRequiredPackages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_GetRequiredPackages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).GetRequiredPackages(ctx, req.(*GetRequiredPackagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_Run_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).Run(ctx, req.(*RunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_GetPluginInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).GetPluginInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_GetPluginInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).GetPluginInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_InstallDependencies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallDependenciesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LanguageRuntimeServer).InstallDependencies(m, &grpc.GenericServerStream[InstallDependenciesRequest, InstallDependenciesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LanguageRuntime_InstallDependenciesServer = grpc.ServerStreamingServer[InstallDependenciesResponse]

func _LanguageRuntime_RuntimeOptionsPrompts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuntimeOptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).RuntimeOptionsPrompts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_RuntimeOptionsPrompts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).RuntimeOptionsPrompts(ctx, req.(*RuntimeOptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_About_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AboutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).About(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_About_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).About(ctx, req.(*AboutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_GetProgramDependencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgramDependenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).GetProgramDependencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_GetProgramDependencies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).GetProgramDependencies(ctx, req.(*GetProgramDependenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_RunPlugin_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunPluginRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LanguageRuntimeServer).RunPlugin(m, &grpc.GenericServerStream[RunPluginRequest, RunPluginResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LanguageRuntime_RunPluginServer = grpc.ServerStreamingServer[RunPluginResponse]

func _LanguageRuntime_GenerateProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateProgramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).GenerateProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_GenerateProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).GenerateProgram(ctx, req.(*GenerateProgramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_GenerateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).GenerateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_GenerateProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).GenerateProject(ctx, req.(*GenerateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_GeneratePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeneratePackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).GeneratePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_GeneratePackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).GeneratePackage(ctx, req.(*GeneratePackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_Pack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).Pack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_Pack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).Pack(ctx, req.(*PackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_Link_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).Link(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_Link_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).Link(ctx, req.(*LinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageRuntime_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageRuntimeServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LanguageRuntime_Cancel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageRuntimeServer).Cancel(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// LanguageRuntime_ServiceDesc is the grpc.ServiceDesc for LanguageRuntime service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LanguageRuntime_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pulumirpc.LanguageRuntime",
	HandlerType: (*LanguageRuntimeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Handshake",
			Handler:    _LanguageRuntime_Handshake_Handler,
		},
		{
			MethodName: "GetRequiredPlugins",
			Handler:    _LanguageRuntime_GetRequiredPlugins_Handler,
		},
		{
			MethodName: "GetRequiredPackages",
			Handler:    _LanguageRuntime_GetRequiredPackages_Handler,
		},
		{
			MethodName: "Run",
			Handler:    _LanguageRuntime_Run_Handler,
		},
		{
			MethodName: "GetPluginInfo",
			Handler:    _LanguageRuntime_GetPluginInfo_Handler,
		},
		{
			MethodName: "RuntimeOptionsPrompts",
			Handler:    _LanguageRuntime_RuntimeOptionsPrompts_Handler,
		},
		{
			MethodName: "About",
			Handler:    _LanguageRuntime_About_Handler,
		},
		{
			MethodName: "GetProgramDependencies",
			Handler:    _LanguageRuntime_GetProgramDependencies_Handler,
		},
		{
			MethodName: "GenerateProgram",
			Handler:    _LanguageRuntime_GenerateProgram_Handler,
		},
		{
			MethodName: "GenerateProject",
			Handler:    _LanguageRuntime_GenerateProject_Handler,
		},
		{
			MethodName: "GeneratePackage",
			Handler:    _LanguageRuntime_GeneratePackage_Handler,
		},
		{
			MethodName: "Pack",
			Handler:    _LanguageRuntime_Pack_Handler,
		},
		{
			MethodName: "Link",
			Handler:    _LanguageRuntime_Link_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _LanguageRuntime_Cancel_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "InstallDependencies",
			Handler:       _LanguageRuntime_InstallDependencies_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RunPlugin",
			Handler:       _LanguageRuntime_RunPlugin_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pulumi/language.proto",
}
