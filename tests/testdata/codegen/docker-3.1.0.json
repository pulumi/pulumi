{
  "name": "docker",
  "description": "A Pulumi package for interacting with Docker in Pulumi programs",
  "keywords": [
    "pulumi",
    "docker"
  ],
  "homepage": "https://pulumi.io",
  "license": "Apache-2.0",
  "attribution": "This Pulumi package is based on the [`docker` Terraform Provider](https://github.com/terraform-providers/terraform-provider-docker).",
  "repository": "https://github.com/pulumi/pulumi-docker",
  "meta": {
    "moduleFormat": "(.*)(?:/[^/]*)"
  },
  "config": {
    "variables": {
      "caMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker host CA certificate\n"
      },
      "certMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker client certificate\n"
      },
      "certPath": {
        "type": "string",
        "description": "Path to directory with Docker TLS config\n"
      },
      "host": {
        "type": "string",
        "description": "The Docker daemon address\n",
        "default": "unix:///var/run/docker.sock",
        "defaultInfo": {
          "environment": [
            "DOCKER_HOST"
          ]
        }
      },
      "keyMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker client private key\n"
      },
      "registryAuth": {
        "type": "array",
        "items": {
          "$ref": "#/types/docker:config/registryAuth:registryAuth"
        }
      }
    },
    "defaults": [
      "host"
    ]
  },
  "types": {
    "docker:config/registryAuth:registryAuth": {
      "properties": {
        "address": {
          "type": "string"
        },
        "configFile": {
          "type": "string"
        },
        "configFileContent": {
          "type": "string"
        },
        "password": {
          "type": "string"
        },
        "username": {
          "type": "string"
        }
      },
      "type": "object",
      "required": [
        "address"
      ],
      "language": {
        "nodejs": {
          "requiredInputs": []
        }
      }
    },
    "docker:index/ContainerCapabilities:ContainerCapabilities": {
      "properties": {
        "adds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "drops": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ContainerDevice:ContainerDevice": {
      "properties": {
        "containerPath": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "hostPath": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "permissions": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "hostPath"
      ]
    },
    "docker:index/ContainerHealthcheck:ContainerHealthcheck": {
      "properties": {
        "interval": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "retries": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "startPeriod": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tests": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "timeout": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "tests"
      ]
    },
    "docker:index/ContainerHost:ContainerHost": {
      "properties": {
        "host": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ip": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "host",
        "ip"
      ]
    },
    "docker:index/ContainerLabel:ContainerLabel": {
      "properties": {
        "label": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ContainerMount:ContainerMount": {
      "properties": {
        "bindOptions": {
          "$ref": "#/types/docker:index/ContainerMountBindOptions:ContainerMountBindOptions",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "readOnly": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "source": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "target": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tmpfsOptions": {
          "$ref": "#/types/docker:index/ContainerMountTmpfsOptions:ContainerMountTmpfsOptions",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "volumeOptions": {
          "$ref": "#/types/docker:index/ContainerMountVolumeOptions:ContainerMountVolumeOptions",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "target",
        "type"
      ]
    },
    "docker:index/ContainerMountBindOptions:ContainerMountBindOptions": {
      "properties": {
        "propagation": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ContainerMountTmpfsOptions:ContainerMountTmpfsOptions": {
      "properties": {
        "mode": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "sizeBytes": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ContainerMountVolumeOptions:ContainerMountVolumeOptions": {
      "properties": {
        "driverName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "driverOptions": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerMountVolumeOptionsLabel:ContainerMountVolumeOptionsLabel"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "noCopy": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ContainerMountVolumeOptionsLabel:ContainerMountVolumeOptionsLabel": {
      "properties": {
        "label": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ContainerNetworkData:ContainerNetworkData": {
      "properties": {
        "gateway": {
          "type": "string",
          "deprecationMessage": "Use `network_data` instead. The network gateway of the container as read from its NetworkSettings.",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "globalIpv6Address": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "globalIpv6PrefixLength": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipAddress": {
          "type": "string",
          "deprecationMessage": "Use `network_data` instead. The IP address of the container's first network it.",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipPrefixLength": {
          "type": "integer",
          "deprecationMessage": "Use `network_data` instead. The IP prefix length of the container as read from its NetworkSettings.",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6Gateway": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "gateway",
            "globalIpv6Address",
            "globalIpv6PrefixLength",
            "ipAddress",
            "ipPrefixLength",
            "ipv6Gateway",
            "networkName"
          ]
        }
      }
    },
    "docker:index/ContainerNetworksAdvanced:ContainerNetworksAdvanced": {
      "properties": {
        "aliases": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv4Address": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6Address": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "name"
      ]
    },
    "docker:index/ContainerPort:ContainerPort": {
      "properties": {
        "external": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "internal": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ip": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "protocol": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "internal"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "external",
            "internal"
          ]
        }
      }
    },
    "docker:index/ContainerUlimit:ContainerUlimit": {
      "properties": {
        "hard": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "soft": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "hard",
        "name",
        "soft"
      ]
    },
    "docker:index/ContainerUpload:ContainerUpload": {
      "properties": {
        "content": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "contentBase64": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "executable": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "file": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "source": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "sourceHash": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "file"
      ]
    },
    "docker:index/ContainerVolume:ContainerVolume": {
      "properties": {
        "containerPath": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fromContainer": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "hostPath": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "readOnly": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "volumeName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/NetworkIpamConfig:NetworkIpamConfig": {
      "properties": {
        "auxAddress": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "gateway": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipRange": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnet": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/NetworkLabel:NetworkLabel": {
      "properties": {
        "label": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/PluginGrantPermission:PluginGrantPermission": {
      "properties": {
        "name": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "name",
        "values"
      ]
    },
    "docker:index/ProviderRegistryAuth:ProviderRegistryAuth": {
      "properties": {
        "address": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "configFile": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "configFileContent": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "password": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "username": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "address"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": []
        }
      }
    },
    "docker:index/RegistryImageBuild:RegistryImageBuild": {
      "properties": {
        "authConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/RegistryImageBuildAuthConfig:RegistryImageBuildAuthConfig"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "buildArgs": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "buildId": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cacheFroms": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cgroupParent": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "context": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cpuPeriod": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cpuQuota": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cpuSetCpus": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cpuSetMems": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cpuShares": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "dockerfile": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "extraHosts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "forceRemove": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "isolation": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "memory": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "memorySwap": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkMode": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "noCache": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "platform": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "pullParent": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "remoteContext": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "remove": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "securityOpts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "sessionId": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "shmSize": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "squash": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "suppressOutput": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "target": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ulimits": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/RegistryImageBuildUlimit:RegistryImageBuildUlimit"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "version": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "context"
      ]
    },
    "docker:index/RegistryImageBuildAuthConfig:RegistryImageBuildAuthConfig": {
      "properties": {
        "auth": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "email": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "hostName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "identityToken": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "password": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "registryToken": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "serverAddress": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "userName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "hostName"
      ]
    },
    "docker:index/RegistryImageBuildUlimit:RegistryImageBuildUlimit": {
      "properties": {
        "hard": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "soft": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "hard",
        "name",
        "soft"
      ]
    },
    "docker:index/RemoteImageBuild:RemoteImageBuild": {
      "properties": {
        "buildArg": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "dockerfile": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "forceRemove": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "label": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "noCache": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "path": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "remove": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "target": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "path"
      ]
    },
    "docker:index/SecretLabel:SecretLabel": {
      "properties": {
        "label": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ServiceAuth:ServiceAuth": {
      "properties": {
        "password": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "serverAddress": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "username": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "serverAddress"
      ]
    },
    "docker:index/ServiceConvergeConfig:ServiceConvergeConfig": {
      "properties": {
        "delay": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "timeout": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceEndpointSpec:ServiceEndpointSpec": {
      "properties": {
        "mode": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ports": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ServiceEndpointSpecPort:ServiceEndpointSpecPort"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "mode"
          ]
        }
      }
    },
    "docker:index/ServiceEndpointSpecPort:ServiceEndpointSpecPort": {
      "properties": {
        "name": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "protocol": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publishMode": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publishedPort": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "targetPort": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "targetPort"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "publishedPort",
            "targetPort"
          ]
        }
      }
    },
    "docker:index/ServiceLabel:ServiceLabel": {
      "properties": {
        "label": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ServiceMode:ServiceMode": {
      "properties": {
        "global": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "replicated": {
          "$ref": "#/types/docker:index/ServiceModeReplicated:ServiceModeReplicated",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "replicated"
          ]
        }
      }
    },
    "docker:index/ServiceModeReplicated:ServiceModeReplicated": {
      "properties": {
        "replicas": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceRollbackConfig:ServiceRollbackConfig": {
      "properties": {
        "delay": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "failureAction": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxFailureRatio": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "monitor": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "order": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "parallelism": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpec:ServiceTaskSpec": {
      "properties": {
        "containerSpec": {
          "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpec:ServiceTaskSpecContainerSpec",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "forceUpdate": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "logDriver": {
          "$ref": "#/types/docker:index/ServiceTaskSpecLogDriver:ServiceTaskSpecLogDriver",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networks": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "placement": {
          "$ref": "#/types/docker:index/ServiceTaskSpecPlacement:ServiceTaskSpecPlacement",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "resources": {
          "$ref": "#/types/docker:index/ServiceTaskSpecResources:ServiceTaskSpecResources",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "restartPolicy": {
          "$ref": "#/types/docker:index/ServiceTaskSpecRestartPolicy:ServiceTaskSpecRestartPolicy",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "runtime": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "containerSpec"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "containerSpec",
            "forceUpdate",
            "placement",
            "resources",
            "restartPolicy",
            "runtime"
          ]
        }
      }
    },
    "docker:index/ServiceTaskSpecContainerSpec:ServiceTaskSpecContainerSpec": {
      "properties": {
        "args": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "commands": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "configs": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecConfig:ServiceTaskSpecContainerSpecConfig"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "dir": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "dnsConfig": {
          "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecDnsConfig:ServiceTaskSpecContainerSpecDnsConfig",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "env": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "healthcheck": {
          "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecHealthcheck:ServiceTaskSpecContainerSpecHealthcheck",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "hostname": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecHost:ServiceTaskSpecContainerSpecHost"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "image": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "isolation": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecLabel:ServiceTaskSpecContainerSpecLabel"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "mounts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecMount:ServiceTaskSpecContainerSpecMount"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "privileges": {
          "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecPrivileges:ServiceTaskSpecContainerSpecPrivileges",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "readOnly": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "secrets": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecSecret:ServiceTaskSpecContainerSpecSecret"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "stopGracePeriod": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "stopSignal": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "user": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "image"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "dnsConfig",
            "healthcheck",
            "image",
            "stopGracePeriod"
          ]
        }
      }
    },
    "docker:index/ServiceTaskSpecContainerSpecConfig:ServiceTaskSpecContainerSpecConfig": {
      "properties": {
        "configId": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "configName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileGid": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileMode": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileUid": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "configId",
        "fileName"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecDnsConfig:ServiceTaskSpecContainerSpecDnsConfig": {
      "properties": {
        "nameservers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "options": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "searches": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "nameservers"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecHealthcheck:ServiceTaskSpecContainerSpecHealthcheck": {
      "properties": {
        "interval": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "retries": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "startPeriod": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tests": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "timeout": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "tests"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecHost:ServiceTaskSpecContainerSpecHost": {
      "properties": {
        "host": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ip": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "host",
        "ip"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecLabel:ServiceTaskSpecContainerSpecLabel": {
      "properties": {
        "label": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecMount:ServiceTaskSpecContainerSpecMount": {
      "properties": {
        "bindOptions": {
          "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecMountBindOptions:ServiceTaskSpecContainerSpecMountBindOptions",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "readOnly": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "source": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "target": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tmpfsOptions": {
          "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecMountTmpfsOptions:ServiceTaskSpecContainerSpecMountTmpfsOptions",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "volumeOptions": {
          "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecMountVolumeOptions:ServiceTaskSpecContainerSpecMountVolumeOptions",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "target",
        "type"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecMountBindOptions:ServiceTaskSpecContainerSpecMountBindOptions": {
      "properties": {
        "propagation": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecMountTmpfsOptions:ServiceTaskSpecContainerSpecMountTmpfsOptions": {
      "properties": {
        "mode": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "sizeBytes": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecMountVolumeOptions:ServiceTaskSpecContainerSpecMountVolumeOptions": {
      "properties": {
        "driverName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "driverOptions": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecMountVolumeOptionsLabel:ServiceTaskSpecContainerSpecMountVolumeOptionsLabel"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "noCopy": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecMountVolumeOptionsLabel:ServiceTaskSpecContainerSpecMountVolumeOptionsLabel": {
      "properties": {
        "label": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecPrivileges:ServiceTaskSpecContainerSpecPrivileges": {
      "properties": {
        "credentialSpec": {
          "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecPrivilegesCredentialSpec:ServiceTaskSpecContainerSpecPrivilegesCredentialSpec",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "seLinuxContext": {
          "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext:ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecPrivilegesCredentialSpec:ServiceTaskSpecContainerSpecPrivilegesCredentialSpec": {
      "properties": {
        "file": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "registry": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext:ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext": {
      "properties": {
        "disable": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "level": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "role": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "user": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecSecret:ServiceTaskSpecContainerSpecSecret": {
      "properties": {
        "fileGid": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileMode": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileUid": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "secretId": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "secretName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "fileName",
        "secretId"
      ]
    },
    "docker:index/ServiceTaskSpecLogDriver:ServiceTaskSpecLogDriver": {
      "properties": {
        "name": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "options": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "name"
      ]
    },
    "docker:index/ServiceTaskSpecPlacement:ServiceTaskSpecPlacement": {
      "properties": {
        "constraints": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxReplicas": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "platforms": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ServiceTaskSpecPlacementPlatform:ServiceTaskSpecPlacementPlatform"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "prefs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecPlacementPlatform:ServiceTaskSpecPlacementPlatform": {
      "properties": {
        "architecture": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "os": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "architecture",
        "os"
      ]
    },
    "docker:index/ServiceTaskSpecResources:ServiceTaskSpecResources": {
      "properties": {
        "limits": {
          "$ref": "#/types/docker:index/ServiceTaskSpecResourcesLimits:ServiceTaskSpecResourcesLimits",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "reservation": {
          "$ref": "#/types/docker:index/ServiceTaskSpecResourcesReservation:ServiceTaskSpecResourcesReservation",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecResourcesLimits:ServiceTaskSpecResourcesLimits": {
      "properties": {
        "memoryBytes": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nanoCpus": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecResourcesReservation:ServiceTaskSpecResourcesReservation": {
      "properties": {
        "genericResources": {
          "$ref": "#/types/docker:index/ServiceTaskSpecResourcesReservationGenericResources:ServiceTaskSpecResourcesReservationGenericResources",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "memoryBytes": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nanoCpus": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecResourcesReservationGenericResources:ServiceTaskSpecResourcesReservationGenericResources": {
      "properties": {
        "discreteResourcesSpecs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "namedResourcesSpecs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecRestartPolicy:ServiceTaskSpecRestartPolicy": {
      "properties": {
        "condition": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "delay": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxAttempts": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "window": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceUpdateConfig:ServiceUpdateConfig": {
      "properties": {
        "delay": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "failureAction": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxFailureRatio": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "monitor": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "order": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "parallelism": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/VolumeLabel:VolumeLabel": {
      "properties": {
        "label": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/getNetworkIpamConfig:getNetworkIpamConfig": {
      "properties": {
        "auxAddress": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "gateway": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipRange": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnet": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    }
  },
  "provider": {
    "description": "The provider type for the docker package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
    "inputProperties": {
      "caMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker host CA certificate\n"
      },
      "certMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker client certificate\n"
      },
      "certPath": {
        "type": "string",
        "description": "Path to directory with Docker TLS config\n"
      },
      "host": {
        "type": "string",
        "description": "The Docker daemon address\n",
        "default": "unix:///var/run/docker.sock",
        "defaultInfo": {
          "environment": [
            "DOCKER_HOST"
          ]
        }
      },
      "keyMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker client private key\n"
      },
      "registryAuth": {
        "type": "array",
        "items": {
          "$ref": "#/types/docker:index/ProviderRegistryAuth:ProviderRegistryAuth"
        }
      }
    }
  },
  "resources": {
    "docker:index/container:Container": {
      "description": "\n\n\n## Import\n\n### Example Assuming you created a `container` as follows #!/bin/bash docker run --name foo -p8080:80 -d nginx\n\n# prints the container ID\n\n9a550c0f0163d39d77222d3efd58701b625d47676c25c686c95b5b92d1cba6fd you provide the definition for the resource as follows terraform resource \"docker_container\" \"foo\" {\n\n name\n\n= \"foo\"\n\n image = \"nginx\"\n\n ports {\n\n\n\n internal = \"80\"\n\n\n\n external = \"8080\"\n\n } } then the import command is as follows #!/bin/bash\n\n```sh\n $ pulumi import docker:index/container:Container foo 9a550c0f0163d39d77222d3efd58701b625d47676c25c686c95b5b92d1cba6fd\n```\n\n ",
      "properties": {
        "attach": {
          "type": "boolean",
          "description": "If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.\n"
        },
        "bridge": {
          "type": "string",
          "description": "The network bridge of the container as read from its NetworkSettings.\n"
        },
        "capabilities": {
          "$ref": "#/types/docker:index/ContainerCapabilities:ContainerCapabilities",
          "description": "Add or drop certrain linux capabilities.\n"
        },
        "command": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be\n`[\"/usr/bin/myprogram\",\"-\",\"baz.con\"]`.\n"
        },
        "containerLogs": {
          "type": "string",
          "description": "The logs of the container if its execution is done (`attach` must be disabled).\n"
        },
        "cpuSet": {
          "type": "string",
          "description": "A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.\n"
        },
        "cpuShares": {
          "type": "integer",
          "description": "CPU shares (relative weight) for the container.\n"
        },
        "destroyGraceSeconds": {
          "type": "integer",
          "description": "If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on\nsuccessful stop.\n"
        },
        "devices": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerDevice:ContainerDevice"
          },
          "description": "Bind devices to the container.\n"
        },
        "dns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS servers to use.\n"
        },
        "dnsOpts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.\n"
        },
        "dnsSearches": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS search domains that are used when bare unqualified hostnames are used inside of the container.\n"
        },
        "domainname": {
          "type": "string",
          "description": "Domain name of the container.\n"
        },
        "entrypoints": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an\nexecutable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be\n`\"/usr/bin/myprogra\"]`.\n"
        },
        "envs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
        },
        "exitCode": {
          "type": "integer",
          "description": "The exit code of the container if its execution is done (`must_run` must be disabled).\n"
        },
        "gateway": {
          "type": "string",
          "description": "The network gateway of the container.\n",
          "deprecationMessage": "Use `network_data` instead. The network gateway of the container as read from its NetworkSettings."
        },
        "groupAdds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Additional groups for the container user\n"
        },
        "healthcheck": {
          "$ref": "#/types/docker:index/ContainerHealthcheck:ContainerHealthcheck",
          "description": "A test to perform to check that the container is healthy\n"
        },
        "hostname": {
          "type": "string",
          "description": "Hostname of the container.\n"
        },
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerHost:ContainerHost"
          },
          "description": "Additional hosts to add to the container.\n"
        },
        "image": {
          "type": "string",
          "description": "The ID of the image to back this container. The easiest way to get this value is to use the `docker_image` resource as\nis shown in the example.\n"
        },
        "init": {
          "type": "boolean",
          "description": "Configured whether an init process should be injected for this container. If unset this will default to the `dockerd`\ndefaults.\n"
        },
        "ipAddress": {
          "type": "string",
          "description": "The IP address of the container.\n",
          "deprecationMessage": "Use `network_data` instead. The IP address of the container's first network it."
        },
        "ipPrefixLength": {
          "type": "integer",
          "description": "The IP prefix length of the container.\n",
          "deprecationMessage": "Use `network_data` instead. The IP prefix length of the container as read from its NetworkSettings."
        },
        "ipcMode": {
          "type": "string",
          "description": "IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:<name|id>` or\n`host`.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerLabel:ContainerLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "links": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Set of links for link based connectivity between containers that are running on the same host.\n",
          "deprecationMessage": "The --link flag is a legacy feature of Docker. It may eventually be removed."
        },
        "logDriver": {
          "type": "string",
          "description": "The logging driver to use for the container. Defaults to `json-file`.\n"
        },
        "logOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Key/value pairs to use as options for the logging driver.\n"
        },
        "logs": {
          "type": "boolean",
          "description": "Save the container logs (`attach` must be enabled). Defaults to `false`.\n"
        },
        "maxRetryCount": {
          "type": "integer",
          "description": "The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.\n"
        },
        "memory": {
          "type": "integer",
          "description": "The memory limit for the container in MBs.\n"
        },
        "memorySwap": {
          "type": "integer",
          "description": "The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform\napply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.\n"
        },
        "mounts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerMount:ContainerMount"
          },
          "description": "Specification for mounts to be added to containers created as part of the service.\n"
        },
        "mustRun": {
          "type": "boolean",
          "description": "If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform\nassumes it is successful. Defaults to `true`.\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the container.\n"
        },
        "networkAliases": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Set an alias for the container in all specified networks\n",
          "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
        },
        "networkDatas": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerNetworkData:ContainerNetworkData"
          },
          "description": "The data of the networks the container is connected to.\n"
        },
        "networkMode": {
          "type": "string",
          "description": "Network mode of the container.\n"
        },
        "networks": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "ID of the networks in which the container is.\n",
          "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
        },
        "networksAdvanced": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerNetworksAdvanced:ContainerNetworksAdvanced"
          },
          "description": "The networks the container is attached to\n"
        },
        "pidMode": {
          "type": "string",
          "description": "he PID (Process) Namespace mode for the container. Either `container:<name|id>` or `host`.\n"
        },
        "ports": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerPort:ContainerPort"
          },
          "description": "Publish a container's port(s) to the host.\n"
        },
        "privileged": {
          "type": "boolean",
          "description": "If `true`, the container runs in privileged mode.\n"
        },
        "publishAllPorts": {
          "type": "boolean",
          "description": "Publish all ports of the container.\n"
        },
        "readOnly": {
          "type": "boolean",
          "description": "If `true`, the container will be started as readonly. Defaults to `false`.\n"
        },
        "removeVolumes": {
          "type": "boolean",
          "description": "If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.\n"
        },
        "restart": {
          "type": "string",
          "description": "The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.\n"
        },
        "rm": {
          "type": "boolean",
          "description": "If `true`, then the container will be automatically removed after his execution. Terraform won't check this container\nafter creation. Defaults to `false`.\n"
        },
        "securityOpts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of string values to customize labels for MLS systems, such as SELinux. See\nhttps://docs.docker.com/engine/reference/run/#security-configuration.\n"
        },
        "shmSize": {
          "type": "integer",
          "description": "Size of `/dev/shm` in MBs.\n"
        },
        "start": {
          "type": "boolean",
          "description": "If `true`, then the Docker container will be started after creation. If `false`, then the container is only created.\nDefaults to `true`.\n"
        },
        "stdinOpen": {
          "type": "boolean",
          "description": "If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.\n"
        },
        "storageOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Key/value pairs for the storage driver options, e.g. `size`: `120G`\n"
        },
        "sysctls": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of kernel parameters (sysctls) to set in the container.\n"
        },
        "tmpfs": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.\n"
        },
        "tty": {
          "type": "boolean",
          "description": "If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.\n"
        },
        "ulimits": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerUlimit:ContainerUlimit"
          },
          "description": "Ulimit options to add.\n"
        },
        "uploads": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerUpload:ContainerUpload"
          },
          "description": "Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and\nat least one of them has to be set.\n"
        },
        "user": {
          "type": "string",
          "description": "User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by\nname.\n"
        },
        "usernsMode": {
          "type": "string",
          "description": "Sets the usernamespace mode for the container when usernamespace remapping option is enabled.\n"
        },
        "volumes": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerVolume:ContainerVolume"
          },
          "description": "Spec for mounting volumes in the container.\n"
        },
        "workingDir": {
          "type": "string",
          "description": "The working directory for commands to run in.\n"
        }
      },
      "required": [
        "bridge",
        "command",
        "containerLogs",
        "entrypoints",
        "envs",
        "exitCode",
        "gateway",
        "healthcheck",
        "hostname",
        "image",
        "init",
        "ipAddress",
        "ipPrefixLength",
        "ipcMode",
        "labels",
        "name",
        "networkDatas",
        "securityOpts",
        "shmSize"
      ],
      "inputProperties": {
        "attach": {
          "type": "boolean",
          "description": "If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.\n"
        },
        "capabilities": {
          "$ref": "#/types/docker:index/ContainerCapabilities:ContainerCapabilities",
          "description": "Add or drop certrain linux capabilities.\n"
        },
        "command": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be\n`[\"/usr/bin/myprogram\",\"-\",\"baz.con\"]`.\n"
        },
        "cpuSet": {
          "type": "string",
          "description": "A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.\n"
        },
        "cpuShares": {
          "type": "integer",
          "description": "CPU shares (relative weight) for the container.\n"
        },
        "destroyGraceSeconds": {
          "type": "integer",
          "description": "If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on\nsuccessful stop.\n"
        },
        "devices": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerDevice:ContainerDevice"
          },
          "description": "Bind devices to the container.\n"
        },
        "dns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS servers to use.\n"
        },
        "dnsOpts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.\n"
        },
        "dnsSearches": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS search domains that are used when bare unqualified hostnames are used inside of the container.\n"
        },
        "domainname": {
          "type": "string",
          "description": "Domain name of the container.\n"
        },
        "entrypoints": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an\nexecutable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be\n`\"/usr/bin/myprogra\"]`.\n"
        },
        "envs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
        },
        "groupAdds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Additional groups for the container user\n"
        },
        "healthcheck": {
          "$ref": "#/types/docker:index/ContainerHealthcheck:ContainerHealthcheck",
          "description": "A test to perform to check that the container is healthy\n"
        },
        "hostname": {
          "type": "string",
          "description": "Hostname of the container.\n"
        },
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerHost:ContainerHost"
          },
          "description": "Additional hosts to add to the container.\n"
        },
        "image": {
          "type": "string",
          "description": "The ID of the image to back this container. The easiest way to get this value is to use the `docker_image` resource as\nis shown in the example.\n"
        },
        "init": {
          "type": "boolean",
          "description": "Configured whether an init process should be injected for this container. If unset this will default to the `dockerd`\ndefaults.\n"
        },
        "ipcMode": {
          "type": "string",
          "description": "IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:<name|id>` or\n`host`.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerLabel:ContainerLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "links": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Set of links for link based connectivity between containers that are running on the same host.\n",
          "deprecationMessage": "The --link flag is a legacy feature of Docker. It may eventually be removed."
        },
        "logDriver": {
          "type": "string",
          "description": "The logging driver to use for the container. Defaults to `json-file`.\n"
        },
        "logOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Key/value pairs to use as options for the logging driver.\n"
        },
        "logs": {
          "type": "boolean",
          "description": "Save the container logs (`attach` must be enabled). Defaults to `false`.\n"
        },
        "maxRetryCount": {
          "type": "integer",
          "description": "The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.\n"
        },
        "memory": {
          "type": "integer",
          "description": "The memory limit for the container in MBs.\n"
        },
        "memorySwap": {
          "type": "integer",
          "description": "The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform\napply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.\n"
        },
        "mounts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerMount:ContainerMount"
          },
          "description": "Specification for mounts to be added to containers created as part of the service.\n"
        },
        "mustRun": {
          "type": "boolean",
          "description": "If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform\nassumes it is successful. Defaults to `true`.\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the container.\n"
        },
        "networkAliases": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Set an alias for the container in all specified networks\n",
          "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
        },
        "networkMode": {
          "type": "string",
          "description": "Network mode of the container.\n"
        },
        "networks": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "ID of the networks in which the container is.\n",
          "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
        },
        "networksAdvanced": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerNetworksAdvanced:ContainerNetworksAdvanced"
          },
          "description": "The networks the container is attached to\n"
        },
        "pidMode": {
          "type": "string",
          "description": "he PID (Process) Namespace mode for the container. Either `container:<name|id>` or `host`.\n"
        },
        "ports": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerPort:ContainerPort"
          },
          "description": "Publish a container's port(s) to the host.\n"
        },
        "privileged": {
          "type": "boolean",
          "description": "If `true`, the container runs in privileged mode.\n"
        },
        "publishAllPorts": {
          "type": "boolean",
          "description": "Publish all ports of the container.\n"
        },
        "readOnly": {
          "type": "boolean",
          "description": "If `true`, the container will be started as readonly. Defaults to `false`.\n"
        },
        "removeVolumes": {
          "type": "boolean",
          "description": "If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.\n"
        },
        "restart": {
          "type": "string",
          "description": "The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.\n"
        },
        "rm": {
          "type": "boolean",
          "description": "If `true`, then the container will be automatically removed after his execution. Terraform won't check this container\nafter creation. Defaults to `false`.\n"
        },
        "securityOpts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of string values to customize labels for MLS systems, such as SELinux. See\nhttps://docs.docker.com/engine/reference/run/#security-configuration.\n"
        },
        "shmSize": {
          "type": "integer",
          "description": "Size of `/dev/shm` in MBs.\n"
        },
        "start": {
          "type": "boolean",
          "description": "If `true`, then the Docker container will be started after creation. If `false`, then the container is only created.\nDefaults to `true`.\n"
        },
        "stdinOpen": {
          "type": "boolean",
          "description": "If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.\n"
        },
        "storageOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Key/value pairs for the storage driver options, e.g. `size`: `120G`\n"
        },
        "sysctls": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of kernel parameters (sysctls) to set in the container.\n"
        },
        "tmpfs": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.\n"
        },
        "tty": {
          "type": "boolean",
          "description": "If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.\n"
        },
        "ulimits": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerUlimit:ContainerUlimit"
          },
          "description": "Ulimit options to add.\n"
        },
        "uploads": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerUpload:ContainerUpload"
          },
          "description": "Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and\nat least one of them has to be set.\n"
        },
        "user": {
          "type": "string",
          "description": "User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by\nname.\n"
        },
        "usernsMode": {
          "type": "string",
          "description": "Sets the usernamespace mode for the container when usernamespace remapping option is enabled.\n"
        },
        "volumes": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ContainerVolume:ContainerVolume"
          },
          "description": "Spec for mounting volumes in the container.\n"
        },
        "workingDir": {
          "type": "string",
          "description": "The working directory for commands to run in.\n"
        }
      },
      "requiredInputs": [
        "image"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Container resources.\n",
        "properties": {
          "attach": {
            "type": "boolean",
            "description": "If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.\n"
          },
          "bridge": {
            "type": "string",
            "description": "The network bridge of the container as read from its NetworkSettings.\n"
          },
          "capabilities": {
            "$ref": "#/types/docker:index/ContainerCapabilities:ContainerCapabilities",
            "description": "Add or drop certrain linux capabilities.\n"
          },
          "command": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be\n`[\"/usr/bin/myprogram\",\"-\",\"baz.con\"]`.\n"
          },
          "containerLogs": {
            "type": "string",
            "description": "The logs of the container if its execution is done (`attach` must be disabled).\n"
          },
          "cpuSet": {
            "type": "string",
            "description": "A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.\n"
          },
          "cpuShares": {
            "type": "integer",
            "description": "CPU shares (relative weight) for the container.\n"
          },
          "destroyGraceSeconds": {
            "type": "integer",
            "description": "If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on\nsuccessful stop.\n"
          },
          "devices": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ContainerDevice:ContainerDevice"
            },
            "description": "Bind devices to the container.\n"
          },
          "dns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DNS servers to use.\n"
          },
          "dnsOpts": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.\n"
          },
          "dnsSearches": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DNS search domains that are used when bare unqualified hostnames are used inside of the container.\n"
          },
          "domainname": {
            "type": "string",
            "description": "Domain name of the container.\n"
          },
          "entrypoints": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an\nexecutable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be\n`\"/usr/bin/myprogra\"]`.\n"
          },
          "envs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
          },
          "exitCode": {
            "type": "integer",
            "description": "The exit code of the container if its execution is done (`must_run` must be disabled).\n"
          },
          "gateway": {
            "type": "string",
            "description": "The network gateway of the container.\n",
            "deprecationMessage": "Use `network_data` instead. The network gateway of the container as read from its NetworkSettings."
          },
          "groupAdds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Additional groups for the container user\n"
          },
          "healthcheck": {
            "$ref": "#/types/docker:index/ContainerHealthcheck:ContainerHealthcheck",
            "description": "A test to perform to check that the container is healthy\n"
          },
          "hostname": {
            "type": "string",
            "description": "Hostname of the container.\n"
          },
          "hosts": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ContainerHost:ContainerHost"
            },
            "description": "Additional hosts to add to the container.\n"
          },
          "image": {
            "type": "string",
            "description": "The ID of the image to back this container. The easiest way to get this value is to use the `docker_image` resource as\nis shown in the example.\n"
          },
          "init": {
            "type": "boolean",
            "description": "Configured whether an init process should be injected for this container. If unset this will default to the `dockerd`\ndefaults.\n"
          },
          "ipAddress": {
            "type": "string",
            "description": "The IP address of the container.\n",
            "deprecationMessage": "Use `network_data` instead. The IP address of the container's first network it."
          },
          "ipPrefixLength": {
            "type": "integer",
            "description": "The IP prefix length of the container.\n",
            "deprecationMessage": "Use `network_data` instead. The IP prefix length of the container as read from its NetworkSettings."
          },
          "ipcMode": {
            "type": "string",
            "description": "IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:<name|id>` or\n`host`.\n"
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ContainerLabel:ContainerLabel"
            },
            "description": "User-defined key/value metadata\n"
          },
          "links": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Set of links for link based connectivity between containers that are running on the same host.\n",
            "deprecationMessage": "The --link flag is a legacy feature of Docker. It may eventually be removed."
          },
          "logDriver": {
            "type": "string",
            "description": "The logging driver to use for the container. Defaults to `json-file`.\n"
          },
          "logOpts": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "Key/value pairs to use as options for the logging driver.\n"
          },
          "logs": {
            "type": "boolean",
            "description": "Save the container logs (`attach` must be enabled). Defaults to `false`.\n"
          },
          "maxRetryCount": {
            "type": "integer",
            "description": "The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.\n"
          },
          "memory": {
            "type": "integer",
            "description": "The memory limit for the container in MBs.\n"
          },
          "memorySwap": {
            "type": "integer",
            "description": "The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform\napply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.\n"
          },
          "mounts": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ContainerMount:ContainerMount"
            },
            "description": "Specification for mounts to be added to containers created as part of the service.\n"
          },
          "mustRun": {
            "type": "boolean",
            "description": "If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform\nassumes it is successful. Defaults to `true`.\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the container.\n"
          },
          "networkAliases": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Set an alias for the container in all specified networks\n",
            "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
          },
          "networkDatas": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ContainerNetworkData:ContainerNetworkData"
            },
            "description": "The data of the networks the container is connected to.\n"
          },
          "networkMode": {
            "type": "string",
            "description": "Network mode of the container.\n"
          },
          "networks": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "ID of the networks in which the container is.\n",
            "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
          },
          "networksAdvanced": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ContainerNetworksAdvanced:ContainerNetworksAdvanced"
            },
            "description": "The networks the container is attached to\n"
          },
          "pidMode": {
            "type": "string",
            "description": "he PID (Process) Namespace mode for the container. Either `container:<name|id>` or `host`.\n"
          },
          "ports": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ContainerPort:ContainerPort"
            },
            "description": "Publish a container's port(s) to the host.\n"
          },
          "privileged": {
            "type": "boolean",
            "description": "If `true`, the container runs in privileged mode.\n"
          },
          "publishAllPorts": {
            "type": "boolean",
            "description": "Publish all ports of the container.\n"
          },
          "readOnly": {
            "type": "boolean",
            "description": "If `true`, the container will be started as readonly. Defaults to `false`.\n"
          },
          "removeVolumes": {
            "type": "boolean",
            "description": "If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.\n"
          },
          "restart": {
            "type": "string",
            "description": "The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.\n"
          },
          "rm": {
            "type": "boolean",
            "description": "If `true`, then the container will be automatically removed after his execution. Terraform won't check this container\nafter creation. Defaults to `false`.\n"
          },
          "securityOpts": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of string values to customize labels for MLS systems, such as SELinux. See\nhttps://docs.docker.com/engine/reference/run/#security-configuration.\n"
          },
          "shmSize": {
            "type": "integer",
            "description": "Size of `/dev/shm` in MBs.\n"
          },
          "start": {
            "type": "boolean",
            "description": "If `true`, then the Docker container will be started after creation. If `false`, then the container is only created.\nDefaults to `true`.\n"
          },
          "stdinOpen": {
            "type": "boolean",
            "description": "If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.\n"
          },
          "storageOpts": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "Key/value pairs for the storage driver options, e.g. `size`: `120G`\n"
          },
          "sysctls": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "A map of kernel parameters (sysctls) to set in the container.\n"
          },
          "tmpfs": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.\n"
          },
          "tty": {
            "type": "boolean",
            "description": "If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.\n"
          },
          "ulimits": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ContainerUlimit:ContainerUlimit"
            },
            "description": "Ulimit options to add.\n"
          },
          "uploads": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ContainerUpload:ContainerUpload"
            },
            "description": "Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and\nat least one of them has to be set.\n"
          },
          "user": {
            "type": "string",
            "description": "User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by\nname.\n"
          },
          "usernsMode": {
            "type": "string",
            "description": "Sets the usernamespace mode for the container when usernamespace remapping option is enabled.\n"
          },
          "volumes": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ContainerVolume:ContainerVolume"
            },
            "description": "Spec for mounting volumes in the container.\n"
          },
          "workingDir": {
            "type": "string",
            "description": "The working directory for commands to run in.\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/network:Network": {
      "description": "<!-- Bug: Type and Name are switched -->\n`docker.Network` provides details about a specific Docker Network.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst privateNetwork = new docker.Network(\"private_network\", {});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nprivate_network = docker.Network(\"privateNetwork\")\n```\n```csharp\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var privateNetwork = new Docker.Network(\"privateNetwork\", new Docker.NetworkArgs\n        {\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewNetwork(ctx, \"privateNetwork\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n<!-- schema generated by tfplugindocs -->\n{{% /example %}}\n{{% /examples %}}\n## Schema\n\n### Required\n\n- **name** (String) The name of the Docker network.\n\n### Optional\n\n- **attachable** (Boolean) Enable manual container attachment to the network.\n- **check_duplicate** (Boolean) Requests daemon to check for networks with same name.\n- **driver** (String) The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network docs](https://docs.docker.com/network/#network-drivers) for more details.\n- **id** (String) The ID of this resource.\n- **ingress** (Boolean) Create swarm routing-mesh network. Defaults to `false`.\n- **internal** (Boolean) Whether the network is internal.\n- **ipam_config** (Block Set) The IPAM configuration options (see below for nested schema)\n- **ipam_driver** (String) Driver used by the custom IP scheme of the network. Defaults to `default`\n- **ipv6** (Boolean) Enable IPv6 networking. Defaults to `false`.\n- **labels** (Block Set) User-defined key/value metadata (see below for nested schema)\n- **options** (Map of String) Only available with bridge networks. See [bridge options docs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n\n### Read-Only\n\n- **scope** (String) Scope of the network. One of `swarm`, `global`, or `local`.\n\n<a id=\"nestedblock--ipam_config\"></a>\n### Nested Schema for `ipam_config`\n\nOptional:\n\n- **aux_address** (Map of String) Auxiliary IPv4 or IPv6 addresses used by Network driver\n- **gateway** (String) The IP address of the gateway\n- **ip_range** (String) The ip range in CIDR form\n- **subnet** (String) The subnet in CIDR form\n\n\n<a id=\"nestedblock--labels\"></a>\n### Nested Schema for `labels`\n\nRequired:\n\n- **label** (String) Name of the label\n- **value** (String) Value of the label\n\n\n## Import\n\n### Example Assuming you created a `network` as follows #!/bin/bash docker network create foo # prints the long ID 87b57a9b91ecab2db2a6dbf38df74c67d7c7108cbe479d6576574ec2cd8c2d73 you provide the definition for the resource as follows terraform resource \"docker_network\" \"foo\" {\n\n name = \"foo\" } then the import command is as follows #!/bin/bash\n\n```sh\n $ pulumi import docker:index/network:Network foo 87b57a9b91ecab2db2a6dbf38df74c67d7c7108cbe479d6576574ec2cd8c2d73\n```\n\n ",
      "properties": {
        "attachable": {
          "type": "boolean",
          "description": "Enable manual container attachment to the network.\n"
        },
        "checkDuplicate": {
          "type": "boolean",
          "description": "Requests daemon to check for networks with same name.\n"
        },
        "driver": {
          "type": "string",
          "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network\ndocs](https://docs.docker.com/network/#network-drivers) for more details.\n"
        },
        "ingress": {
          "type": "boolean",
          "description": "Create swarm routing-mesh network. Defaults to `false`.\n"
        },
        "internal": {
          "type": "boolean",
          "description": "Whether the network is internal.\n"
        },
        "ipamConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/NetworkIpamConfig:NetworkIpamConfig"
          },
          "description": "The IPAM configuration options\n"
        },
        "ipamDriver": {
          "type": "string",
          "description": "Driver used by the custom IP scheme of the network. Defaults to `default`\n"
        },
        "ipv6": {
          "type": "boolean",
          "description": "Enable IPv6 networking. Defaults to `false`.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/NetworkLabel:NetworkLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker network.\n"
        },
        "options": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Only available with bridge networks. See [bridge options\ndocs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n"
        },
        "scope": {
          "type": "string",
          "description": "Scope of the network. One of `swarm`, `global`, or `local`.\n"
        }
      },
      "required": [
        "driver",
        "internal",
        "ipamConfigs",
        "name",
        "options",
        "scope"
      ],
      "inputProperties": {
        "attachable": {
          "type": "boolean",
          "description": "Enable manual container attachment to the network.\n"
        },
        "checkDuplicate": {
          "type": "boolean",
          "description": "Requests daemon to check for networks with same name.\n"
        },
        "driver": {
          "type": "string",
          "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network\ndocs](https://docs.docker.com/network/#network-drivers) for more details.\n"
        },
        "ingress": {
          "type": "boolean",
          "description": "Create swarm routing-mesh network. Defaults to `false`.\n"
        },
        "internal": {
          "type": "boolean",
          "description": "Whether the network is internal.\n"
        },
        "ipamConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/NetworkIpamConfig:NetworkIpamConfig"
          },
          "description": "The IPAM configuration options\n"
        },
        "ipamDriver": {
          "type": "string",
          "description": "Driver used by the custom IP scheme of the network. Defaults to `default`\n"
        },
        "ipv6": {
          "type": "boolean",
          "description": "Enable IPv6 networking. Defaults to `false`.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/NetworkLabel:NetworkLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker network.\n"
        },
        "options": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Only available with bridge networks. See [bridge options\ndocs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n"
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Network resources.\n",
        "properties": {
          "attachable": {
            "type": "boolean",
            "description": "Enable manual container attachment to the network.\n"
          },
          "checkDuplicate": {
            "type": "boolean",
            "description": "Requests daemon to check for networks with same name.\n"
          },
          "driver": {
            "type": "string",
            "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network\ndocs](https://docs.docker.com/network/#network-drivers) for more details.\n"
          },
          "ingress": {
            "type": "boolean",
            "description": "Create swarm routing-mesh network. Defaults to `false`.\n"
          },
          "internal": {
            "type": "boolean",
            "description": "Whether the network is internal.\n"
          },
          "ipamConfigs": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/NetworkIpamConfig:NetworkIpamConfig"
            },
            "description": "The IPAM configuration options\n"
          },
          "ipamDriver": {
            "type": "string",
            "description": "Driver used by the custom IP scheme of the network. Defaults to `default`\n"
          },
          "ipv6": {
            "type": "boolean",
            "description": "Enable IPv6 networking. Defaults to `false`.\n"
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/NetworkLabel:NetworkLabel"
            },
            "description": "User-defined key/value metadata\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker network.\n"
          },
          "options": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "Only available with bridge networks. See [bridge options\ndocs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n"
          },
          "scope": {
            "type": "string",
            "description": "Scope of the network. One of `swarm`, `global`, or `local`.\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/plugin:Plugin": {
      "description": "<!-- Bug: Type and Name are switched -->\nManages the lifecycle of a Docker plugin.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst sample_volume_plugin = new docker.Plugin(\"sample-volume-plugin\", {\n    alias: \"sample-volume-plugin\",\n    enableTimeout: 60,\n    enabled: false,\n    envs: [\"DEBUG=1\"],\n    forceDestroy: true,\n    forceDisable: true,\n    grantAllPermissions: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nsample_volume_plugin = docker.Plugin(\"sample-volume-plugin\",\n    alias=\"sample-volume-plugin\",\n    enable_timeout=60,\n    enabled=False,\n    envs=[\"DEBUG=1\"],\n    force_destroy=True,\n    force_disable=True,\n    grant_all_permissions=True)\n```\n```csharp\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var sample_volume_plugin = new Docker.Plugin(\"sample-volume-plugin\", new Docker.PluginArgs\n        {\n            Alias = \"sample-volume-plugin\",\n            EnableTimeout = 60,\n            Enabled = false,\n            Envs = \n            {\n                \"DEBUG=1\",\n            },\n            ForceDestroy = true,\n            ForceDisable = true,\n            GrantAllPermissions = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewPlugin(ctx, \"sample_volume_plugin\", &docker.PluginArgs{\n\t\t\tAlias:         pulumi.String(\"sample-volume-plugin\"),\n\t\t\tEnableTimeout: pulumi.Int(60),\n\t\t\tEnabled:       pulumi.Bool(false),\n\t\t\tEnvs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"DEBUG=1\"),\n\t\t\t},\n\t\t\tForceDestroy:        pulumi.Bool(true),\n\t\t\tForceDisable:        pulumi.Bool(true),\n\t\t\tGrantAllPermissions: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n<!-- schema generated by tfplugindocs -->\n{{% /example %}}\n{{% /examples %}}\n## Schema\n\n### Required\n\n- **name** (String) Docker Plugin name\n\n### Optional\n\n- **alias** (String) Docker Plugin alias\n- **enable_timeout** (Number) HTTP client timeout to enable the plugin\n- **enabled** (Boolean) If `true` the plugin is enabled. Defaults to `true`\n- **env** (Set of String) The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n- **force_destroy** (Boolean) If true, then the plugin is destroyed forcibly\n- **force_disable** (Boolean) If true, then the plugin is disabled forcibly\n- **grant_all_permissions** (Boolean) If true, grant all permissions necessary to run the plugin\n- **grant_permissions** (Block Set) Grant specific permissions only (see below for nested schema)\n- **id** (String) The ID of this resource.\n\n### Read-Only\n\n- **plugin_reference** (String) Docker Plugin Reference\n\n<a id=\"nestedblock--grant_permissions\"></a>\n### Nested Schema for `grant_permissions`\n\nRequired:\n\n- **name** (String) The name of the permission\n- **value** (Set of String) The value of the permission\n\n\n## Import\n\nImport is supported using the following syntax#!/bin/bash\n\n```sh\n $ pulumi import docker:index/plugin:Plugin sample-volume-plugin \"$(docker plugin inspect -f {{.ID}} tiborvass/sample-volume-plugin:latest)\"\n```\n\n ",
      "properties": {
        "alias": {
          "type": "string",
          "description": "Docker Plugin alias\n"
        },
        "enableTimeout": {
          "type": "integer",
          "description": "HTTP client timeout to enable the plugin\n"
        },
        "enabled": {
          "type": "boolean",
          "description": "If `true` the plugin is enabled. Defaults to `true`\n"
        },
        "envs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
        },
        "forceDestroy": {
          "type": "boolean",
          "description": "If true, then the plugin is destroyed forcibly\n"
        },
        "forceDisable": {
          "type": "boolean",
          "description": "If true, then the plugin is disabled forcibly\n"
        },
        "grantAllPermissions": {
          "type": "boolean",
          "description": "If true, grant all permissions necessary to run the plugin\n"
        },
        "grantPermissions": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/PluginGrantPermission:PluginGrantPermission"
          },
          "description": "Grant specific permissions only\n"
        },
        "name": {
          "type": "string",
          "description": "Docker Plugin name\n"
        },
        "pluginReference": {
          "type": "string",
          "description": "Docker Plugin Reference\n"
        }
      },
      "required": [
        "alias",
        "envs",
        "name",
        "pluginReference"
      ],
      "inputProperties": {
        "alias": {
          "type": "string",
          "description": "Docker Plugin alias\n"
        },
        "enableTimeout": {
          "type": "integer",
          "description": "HTTP client timeout to enable the plugin\n"
        },
        "enabled": {
          "type": "boolean",
          "description": "If `true` the plugin is enabled. Defaults to `true`\n"
        },
        "envs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
        },
        "forceDestroy": {
          "type": "boolean",
          "description": "If true, then the plugin is destroyed forcibly\n"
        },
        "forceDisable": {
          "type": "boolean",
          "description": "If true, then the plugin is disabled forcibly\n"
        },
        "grantAllPermissions": {
          "type": "boolean",
          "description": "If true, grant all permissions necessary to run the plugin\n"
        },
        "grantPermissions": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/PluginGrantPermission:PluginGrantPermission"
          },
          "description": "Grant specific permissions only\n"
        },
        "name": {
          "type": "string",
          "description": "Docker Plugin name\n"
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Plugin resources.\n",
        "properties": {
          "alias": {
            "type": "string",
            "description": "Docker Plugin alias\n"
          },
          "enableTimeout": {
            "type": "integer",
            "description": "HTTP client timeout to enable the plugin\n"
          },
          "enabled": {
            "type": "boolean",
            "description": "If `true` the plugin is enabled. Defaults to `true`\n"
          },
          "envs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
          },
          "forceDestroy": {
            "type": "boolean",
            "description": "If true, then the plugin is destroyed forcibly\n"
          },
          "forceDisable": {
            "type": "boolean",
            "description": "If true, then the plugin is disabled forcibly\n"
          },
          "grantAllPermissions": {
            "type": "boolean",
            "description": "If true, grant all permissions necessary to run the plugin\n"
          },
          "grantPermissions": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/PluginGrantPermission:PluginGrantPermission"
            },
            "description": "Grant specific permissions only\n"
          },
          "name": {
            "type": "string",
            "description": "Docker Plugin name\n"
          },
          "pluginReference": {
            "type": "string",
            "description": "Docker Plugin Reference\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/registryImage:RegistryImage": {
      "description": "<!-- Bug: Type and Name are switched -->\nManages the lifecycle of docker image/tag in a registry.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\nimport * as process from \"process\";\n\nconst helloworld = new docker.RegistryImage(\"helloworld\", {\n    build: {\n        context: `${process.cwd()}/absolutePathToContextFolder`,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nhelloworld = docker.RegistryImage(\"helloworld\", build=docker.RegistryImageBuildArgs(\n    context=f\"{path['cwd']}/absolutePathToContextFolder\",\n))\n```\n```csharp\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var helloworld = new Docker.RegistryImage(\"helloworld\", new Docker.RegistryImageArgs\n        {\n            Build = new Docker.Inputs.RegistryImageBuildArgs\n            {\n                Context = $\"{path.Cwd}/absolutePathToContextFolder\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewRegistryImage(ctx, \"helloworld\", &docker.RegistryImageArgs{\n\t\t\tBuild: &docker.RegistryImageBuildArgs{\n\t\t\t\tContext: pulumi.String(fmt.Sprintf(\"%v%v\", path.Cwd, \"/absolutePathToContextFolder\")),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n<!-- schema generated by tfplugindocs -->\n{{% /example %}}\n{{% /examples %}}\n## Schema\n\n### Required\n\n- **name** (String) The name of the Docker image.\n\n### Optional\n\n- **build** (Block List, Max: 1) Definition for building the image (see below for nested schema)\n- **id** (String) The ID of this resource.\n- **insecure_skip_verify** (Boolean) If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n- **keep_remotely** (Boolean) If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker registry on destroy operation. Defaults to `false`\n\n### Read-Only\n\n- **sha256_digest** (String) The sha256 digest of the image.\n\n<a id=\"nestedblock--build\"></a>\n### Nested Schema for `build`\n\nRequired:\n\n- **context** (String) The absolute path to the context folder. You can use the helper function '${path.cwd}/context-dir'.\n\nOptional:\n\n- **auth_config** (Block List) The configuration for the authentication (see below for nested schema)\n- **build_args** (Map of String) Pairs for build-time variables in the form TODO\n- **build_id** (String) BuildID is an optional identifier that can be passed together with the build request. The\n- **cache_from** (List of String) Images to consider as cache sources\n- **cgroup_parent** (String) Optional parent cgroup for the container\n- **cpu_period** (Number) The length of a CPU period in microseconds\n- **cpu_quota** (Number) Microseconds of CPU time that the container can get in a CPU period\n- **cpu_set_cpus** (String) CPUs in which to allow execution (e.g., `0-3`, `0`, `1`)\n- **cpu_set_mems** (String) MEMs in which to allow execution (`0-3`, `0`, `1`)\n- **cpu_shares** (Number) CPU shares (relative weight)\n- **dockerfile** (String) Dockerfile file. Defaults to `Dockerfile`\n- **extra_hosts** (List of String) A list of hostnames/IP mappings to add to the container’s /etc/hosts file. Specified in the form [\"hostname:IP\"]\n- **force_remove** (Boolean) Always remove intermediate containers\n- **isolation** (String) Isolation represents the isolation technology of a container. The supported values are\n- **labels** (Map of String) User-defined key/value metadata\n- **memory** (Number) Set memory limit for build\n- **memory_swap** (Number) Total memory (memory + swap), -1 to enable unlimited swap\n- **network_mode** (String) Set the networking mode for the RUN instructions during build\n- **no_cache** (Boolean) Do not use the cache when building the image\n- **platform** (String) Set platform if server is multi-platform capable\n- **pull_parent** (Boolean) Attempt to pull the image even if an older image exists locally\n- **remote_context** (String) A Git repository URI or HTTP/HTTPS context URI\n- **remove** (Boolean) Remove intermediate containers after a successful build (default behavior)\n- **security_opt** (List of String) The security options\n- **session_id** (String) Set an ID for the build session\n- **shm_size** (Number) Size of /dev/shm in bytes. The size must be greater than 0\n- **squash** (Boolean) If true the new layers are squashed into a new image with a single new layer\n- **suppress_output** (Boolean) Suppress the build output and print image ID on success\n- **target** (String) Set the target build stage to build\n- **ulimit** (Block List) Configuration for ulimits (see below for nested schema)\n- **version** (String) Version of the unerlying builder to use\n\n<a id=\"nestedblock--build--auth_config\"></a>\n### Nested Schema for `build.auth_config`\n\nRequired:\n\n- **host_name** (String) hostname of the registry\n\nOptional:\n\n- **auth** (String) the auth token\n- **email** (String) the user emal\n- **identity_token** (String) the identity token\n- **password** (String) the registry password\n- **registry_token** (String) the registry token\n- **server_address** (String) the server address\n- **user_name** (String) the registry user name\n\n\n<a id=\"nestedblock--build--ulimit\"></a>\n### Nested Schema for `build.ulimit`\n\nRequired:\n\n- **hard** (Number) soft limit\n- **name** (String) type of ulimit, e.g. `nofile`\n- **soft** (Number) hard limit\n",
      "properties": {
        "build": {
          "$ref": "#/types/docker:index/RegistryImageBuild:RegistryImageBuild",
          "description": "Definition for building the image\n"
        },
        "insecureSkipVerify": {
          "type": "boolean",
          "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
        },
        "keepRemotely": {
          "type": "boolean",
          "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from\nthe docker registry on destroy operation. Defaults to `false`\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker image.\n"
        },
        "sha256Digest": {
          "type": "string",
          "description": "The sha256 digest of the image.\n"
        }
      },
      "required": [
        "name",
        "sha256Digest"
      ],
      "inputProperties": {
        "build": {
          "$ref": "#/types/docker:index/RegistryImageBuild:RegistryImageBuild",
          "description": "Definition for building the image\n"
        },
        "insecureSkipVerify": {
          "type": "boolean",
          "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
        },
        "keepRemotely": {
          "type": "boolean",
          "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from\nthe docker registry on destroy operation. Defaults to `false`\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker image.\n"
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering RegistryImage resources.\n",
        "properties": {
          "build": {
            "$ref": "#/types/docker:index/RegistryImageBuild:RegistryImageBuild",
            "description": "Definition for building the image\n"
          },
          "insecureSkipVerify": {
            "type": "boolean",
            "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
          },
          "keepRemotely": {
            "type": "boolean",
            "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from\nthe docker registry on destroy operation. Defaults to `false`\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker image.\n"
          },
          "sha256Digest": {
            "type": "string",
            "description": "The sha256 digest of the image.\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/remoteImage:RemoteImage": {
      "description": "<!-- Bug: Type and Name are switched -->\nPulls a Docker image to a given Docker host from a Docker Registry.\n This resource will *not* pull new layers of the image automatically unless used in conjunction with docker.RegistryImage data source to update the `pull_triggers` field.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic\n\nFinds and downloads the latest `ubuntu:precise` image but does not check\nfor further updates of the image\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ubuntu = new docker.RemoteImage(\"ubuntu\", {\n    name: \"ubuntu:precise\",\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nubuntu = docker.RemoteImage(\"ubuntu\", name=\"ubuntu:precise\")\n```\n```csharp\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ubuntu = new Docker.RemoteImage(\"ubuntu\", new Docker.RemoteImageArgs\n        {\n            Name = \"ubuntu:precise\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewRemoteImage(ctx, \"ubuntu\", &docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(\"ubuntu:precise\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Dynamic updates\n\nTo be able to update an image dynamically when the `sha256` sum changes,\nyou need to use it in combination with `docker.RegistryImage` as follows:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ubuntuRegistryImage = docker.getRegistryImage({\n    name: \"ubuntu:precise\",\n});\nconst ubuntuRemoteImage = new docker.RemoteImage(\"ubuntuRemoteImage\", {\n    name: ubuntuRegistryImage.then(ubuntuRegistryImage => ubuntuRegistryImage.name),\n    pullTriggers: [ubuntuRegistryImage.then(ubuntuRegistryImage => ubuntuRegistryImage.sha256Digest)],\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nubuntu_registry_image = docker.get_registry_image(name=\"ubuntu:precise\")\nubuntu_remote_image = docker.RemoteImage(\"ubuntuRemoteImage\",\n    name=ubuntu_registry_image.name,\n    pull_triggers=[ubuntu_registry_image.sha256_digest])\n```\n```csharp\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ubuntuRegistryImage = Output.Create(Docker.GetRegistryImage.InvokeAsync(new Docker.GetRegistryImageArgs\n        {\n            Name = \"ubuntu:precise\",\n        }));\n        var ubuntuRemoteImage = new Docker.RemoteImage(\"ubuntuRemoteImage\", new Docker.RemoteImageArgs\n        {\n            Name = ubuntuRegistryImage.Apply(ubuntuRegistryImage => ubuntuRegistryImage.Name),\n            PullTriggers = \n            {\n                ubuntuRegistryImage.Apply(ubuntuRegistryImage => ubuntuRegistryImage.Sha256Digest),\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tubuntuRegistryImage, err := docker.LookupRegistryImage(ctx, &docker.LookupRegistryImageArgs{\n\t\t\tName: \"ubuntu:precise\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.NewRemoteImage(ctx, \"ubuntuRemoteImage\", &docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(ubuntuRegistryImage.Name),\n\t\t\tPullTriggers: pulumi.StringArray{\n\t\t\t\tpulumi.String(ubuntuRegistryImage.Sha256Digest),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Build\n\nYou can also use the resource to build an image.\nIn this case the image \"zoo\" and \"zoo:develop\" are built.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst zoo = new docker.RemoteImage(\"zoo\", {\n    name: \"zoo\",\n    build: {\n        path: \".\",\n        tags: [\"zoo:develop\"],\n        buildArg: {\n            foo: \"zoo\",\n        },\n        label: {\n            author: \"zoo\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nzoo = docker.RemoteImage(\"zoo\",\n    name=\"zoo\",\n    build=docker.RemoteImageBuildArgs(\n        path=\".\",\n        tags=[\"zoo:develop\"],\n        build_arg={\n            \"foo\": \"zoo\",\n        },\n        label={\n            \"author\": \"zoo\",\n        },\n    ))\n```\n```csharp\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var zoo = new Docker.RemoteImage(\"zoo\", new Docker.RemoteImageArgs\n        {\n            Name = \"zoo\",\n            Build = new Docker.Inputs.RemoteImageBuildArgs\n            {\n                Path = \".\",\n                Tags = \n                {\n                    \"zoo:develop\",\n                },\n                BuildArg = \n                {\n                    { \"foo\", \"zoo\" },\n                },\n                Label = \n                {\n                    { \"author\", \"zoo\" },\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewRemoteImage(ctx, \"zoo\", &docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(\"zoo\"),\n\t\t\tBuild: &docker.RemoteImageBuildArgs{\n\t\t\t\tPath: pulumi.String(\".\"),\n\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"zoo:develop\"),\n\t\t\t\t},\n\t\t\t\tBuildArg: pulumi.StringMap{\n\t\t\t\t\t\"foo\": pulumi.String(\"zoo\"),\n\t\t\t\t},\n\t\t\t\tLabel: pulumi.StringMap{\n\t\t\t\t\t\"author\": pulumi.String(\"zoo\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n<!-- schema generated by tfplugindocs -->\n{{% /example %}}\n{{% /examples %}}\n## Schema\n\n### Required\n\n- **name** (String) The name of the Docker image, including any tags or SHA256 repo digests.\n\n### Optional\n\n- **build** (Block Set, Max: 1) Configuration to build an image. Please see [docker build command reference](https://docs.docker.com/engine/reference/commandline/build/#options) too. (see below for nested schema)\n- **force_remove** (Boolean) If true, then the image is removed forcibly when the resource is destroyed.\n- **id** (String) The ID of this resource.\n- **keep_locally** (Boolean) If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker local storage on destroy operation.\n- **pull_trigger** (String, Deprecated) A value which cause an image pull when changed\n- **pull_triggers** (Set of String) List of values which cause an image pull when changed. This is used to store the image digest from the registry when using the docker_registry_image.\n\n### Read-Only\n\n- **latest** (String, Deprecated) The ID of the image in the form of `sha256:<hash>` image digest. Do not confuse it with the default `latest` tag.\n- **output** (String, Deprecated)\n- **repo_digest** (String) The image sha256 digest in the form of `repo[:tag]@sha256:<hash>`.\n\n<a id=\"nestedblock--build\"></a>\n### Nested Schema for `build`\n\nRequired:\n\n- **path** (String) Context path\n\nOptional:\n\n- **build_arg** (Map of String) Set build-time variables\n- **dockerfile** (String) Name of the Dockerfile. Defaults to `Dockerfile`.\n- **force_remove** (Boolean) Always remove intermediate containers\n- **label** (Map of String) Set metadata for an image\n- **no_cache** (Boolean) Do not use cache when building the image\n- **remove** (Boolean) Remove intermediate containers after a successful build. Defaults to  `true`.\n- **tag** (List of String) Name and optionally a tag in the 'name:tag' format\n- **target** (String) Set the target build stage to build\n",
      "properties": {
        "build": {
          "$ref": "#/types/docker:index/RemoteImageBuild:RemoteImageBuild",
          "description": "Configuration to build an image. Please see [docker build command\nreference](https://docs.docker.com/engine/reference/commandline/build/#options) too.\n"
        },
        "forceRemove": {
          "type": "boolean",
          "description": "If true, then the image is removed forcibly when the resource is destroyed.\n"
        },
        "keepLocally": {
          "type": "boolean",
          "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from\nthe docker local storage on destroy operation.\n"
        },
        "latest": {
          "type": "string",
          "description": "The ID of the image in the form of `sha256:<hash>` image digest. Do not confuse it with the default `latest` tag.\n",
          "deprecationMessage": "Use repo_digest instead"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker image, including any tags or SHA256 repo digests.\n"
        },
        "output": {
          "type": "string",
          "deprecationMessage": "Is unused and will be removed."
        },
        "pullTrigger": {
          "type": "string",
          "description": "A value which cause an image pull when changed\n",
          "deprecationMessage": "Use field pull_triggers instead"
        },
        "pullTriggers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of values which cause an image pull when changed. This is used to store the image digest from the registry when\nusing the [docker_registry_image](../data-sources/registry_image.md).\n"
        },
        "repoDigest": {
          "type": "string",
          "description": "The image sha256 digest in the form of `repo[:tag]@sha256:<hash>`.\n"
        }
      },
      "required": [
        "latest",
        "name",
        "output",
        "repoDigest"
      ],
      "inputProperties": {
        "build": {
          "$ref": "#/types/docker:index/RemoteImageBuild:RemoteImageBuild",
          "description": "Configuration to build an image. Please see [docker build command\nreference](https://docs.docker.com/engine/reference/commandline/build/#options) too.\n"
        },
        "forceRemove": {
          "type": "boolean",
          "description": "If true, then the image is removed forcibly when the resource is destroyed.\n"
        },
        "keepLocally": {
          "type": "boolean",
          "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from\nthe docker local storage on destroy operation.\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker image, including any tags or SHA256 repo digests.\n"
        },
        "pullTrigger": {
          "type": "string",
          "description": "A value which cause an image pull when changed\n",
          "deprecationMessage": "Use field pull_triggers instead"
        },
        "pullTriggers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of values which cause an image pull when changed. This is used to store the image digest from the registry when\nusing the [docker_registry_image](../data-sources/registry_image.md).\n"
        }
      },
      "requiredInputs": [
        "name"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering RemoteImage resources.\n",
        "properties": {
          "build": {
            "$ref": "#/types/docker:index/RemoteImageBuild:RemoteImageBuild",
            "description": "Configuration to build an image. Please see [docker build command\nreference](https://docs.docker.com/engine/reference/commandline/build/#options) too.\n"
          },
          "forceRemove": {
            "type": "boolean",
            "description": "If true, then the image is removed forcibly when the resource is destroyed.\n"
          },
          "keepLocally": {
            "type": "boolean",
            "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from\nthe docker local storage on destroy operation.\n"
          },
          "latest": {
            "type": "string",
            "description": "The ID of the image in the form of `sha256:<hash>` image digest. Do not confuse it with the default `latest` tag.\n",
            "deprecationMessage": "Use repo_digest instead"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker image, including any tags or SHA256 repo digests.\n"
          },
          "output": {
            "type": "string",
            "deprecationMessage": "Is unused and will be removed."
          },
          "pullTrigger": {
            "type": "string",
            "description": "A value which cause an image pull when changed\n",
            "deprecationMessage": "Use field pull_triggers instead"
          },
          "pullTriggers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of values which cause an image pull when changed. This is used to store the image digest from the registry when\nusing the [docker_registry_image](../data-sources/registry_image.md).\n"
          },
          "repoDigest": {
            "type": "string",
            "description": "The image sha256 digest in the form of `repo[:tag]@sha256:<hash>`.\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/secret:Secret": {
      "description": "\n\n\n## Import\n\nImport is supported using the following syntax#!/bin/bash # Docker secret cannot be imported as the secret data, once set, is never exposed again. ",
      "properties": {
        "data": {
          "type": "string",
          "description": "Base64-url-safe-encoded secret data\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/SecretLabel:SecretLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "name": {
          "type": "string",
          "description": "User-defined name of the secret\n"
        }
      },
      "required": [
        "data",
        "name"
      ],
      "inputProperties": {
        "data": {
          "type": "string",
          "description": "Base64-url-safe-encoded secret data\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/SecretLabel:SecretLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "name": {
          "type": "string",
          "description": "User-defined name of the secret\n"
        }
      },
      "requiredInputs": [
        "data"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Secret resources.\n",
        "properties": {
          "data": {
            "type": "string",
            "description": "Base64-url-safe-encoded secret data\n"
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/SecretLabel:SecretLabel"
            },
            "description": "User-defined key/value metadata\n"
          },
          "name": {
            "type": "string",
            "description": "User-defined name of the secret\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/service:Service": {
      "description": "\n\n\n## Import\n\n### Example Assuming you created a `service` as follows #!/bin/bash docker service create --name foo -p 8080:80 nginx # prints th ID 4pcphbxkfn2rffhbhe6czytgi you provide the definition for the resource as follows terraform resource \"docker_service\" \"foo\" {\n\n name = \"foo\"\n\n task_spec {\n\n\n\n container_spec {\n\n\n\n\n\n image = \"nginx\"\n\n\n\n }\n\n }\n\n endpoint_spec {\n\n\n\n ports {\n\n\n\n\n\n target_port\n\n\n\n= \"80\"\n\n\n\n\n\n published_port = \"8080\"\n\n\n\n }\n\n } } then the import command is as follows #!/bin/bash\n\n```sh\n $ pulumi import docker:index/service:Service foo 4pcphbxkfn2rffhbhe6czytgi\n```\n\n ",
      "properties": {
        "auth": {
          "$ref": "#/types/docker:index/ServiceAuth:ServiceAuth",
          "description": "Configuration for the authentication for pulling the images of the service\n"
        },
        "convergeConfig": {
          "$ref": "#/types/docker:index/ServiceConvergeConfig:ServiceConvergeConfig",
          "description": "A configuration to ensure that a service converges aka reaches the desired that of all task up and running\n"
        },
        "endpointSpec": {
          "$ref": "#/types/docker:index/ServiceEndpointSpec:ServiceEndpointSpec",
          "description": "Properties that can be configured to access and load balance a service\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ServiceLabel:ServiceLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "mode": {
          "$ref": "#/types/docker:index/ServiceMode:ServiceMode",
          "description": "Scheduling mode for the service\n"
        },
        "name": {
          "type": "string",
          "description": "Name of the service\n"
        },
        "rollbackConfig": {
          "$ref": "#/types/docker:index/ServiceRollbackConfig:ServiceRollbackConfig",
          "description": "Specification for the rollback strategy of the service\n"
        },
        "taskSpec": {
          "$ref": "#/types/docker:index/ServiceTaskSpec:ServiceTaskSpec",
          "description": "User modifiable task configuration\n"
        },
        "updateConfig": {
          "$ref": "#/types/docker:index/ServiceUpdateConfig:ServiceUpdateConfig",
          "description": "Specification for the update strategy of the service\n"
        }
      },
      "required": [
        "endpointSpec",
        "labels",
        "mode",
        "name",
        "taskSpec"
      ],
      "inputProperties": {
        "auth": {
          "$ref": "#/types/docker:index/ServiceAuth:ServiceAuth",
          "description": "Configuration for the authentication for pulling the images of the service\n"
        },
        "convergeConfig": {
          "$ref": "#/types/docker:index/ServiceConvergeConfig:ServiceConvergeConfig",
          "description": "A configuration to ensure that a service converges aka reaches the desired that of all task up and running\n"
        },
        "endpointSpec": {
          "$ref": "#/types/docker:index/ServiceEndpointSpec:ServiceEndpointSpec",
          "description": "Properties that can be configured to access and load balance a service\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/ServiceLabel:ServiceLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "mode": {
          "$ref": "#/types/docker:index/ServiceMode:ServiceMode",
          "description": "Scheduling mode for the service\n"
        },
        "name": {
          "type": "string",
          "description": "Name of the service\n"
        },
        "rollbackConfig": {
          "$ref": "#/types/docker:index/ServiceRollbackConfig:ServiceRollbackConfig",
          "description": "Specification for the rollback strategy of the service\n"
        },
        "taskSpec": {
          "$ref": "#/types/docker:index/ServiceTaskSpec:ServiceTaskSpec",
          "description": "User modifiable task configuration\n"
        },
        "updateConfig": {
          "$ref": "#/types/docker:index/ServiceUpdateConfig:ServiceUpdateConfig",
          "description": "Specification for the update strategy of the service\n"
        }
      },
      "requiredInputs": [
        "taskSpec"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Service resources.\n",
        "properties": {
          "auth": {
            "$ref": "#/types/docker:index/ServiceAuth:ServiceAuth",
            "description": "Configuration for the authentication for pulling the images of the service\n"
          },
          "convergeConfig": {
            "$ref": "#/types/docker:index/ServiceConvergeConfig:ServiceConvergeConfig",
            "description": "A configuration to ensure that a service converges aka reaches the desired that of all task up and running\n"
          },
          "endpointSpec": {
            "$ref": "#/types/docker:index/ServiceEndpointSpec:ServiceEndpointSpec",
            "description": "Properties that can be configured to access and load balance a service\n"
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/ServiceLabel:ServiceLabel"
            },
            "description": "User-defined key/value metadata\n"
          },
          "mode": {
            "$ref": "#/types/docker:index/ServiceMode:ServiceMode",
            "description": "Scheduling mode for the service\n"
          },
          "name": {
            "type": "string",
            "description": "Name of the service\n"
          },
          "rollbackConfig": {
            "$ref": "#/types/docker:index/ServiceRollbackConfig:ServiceRollbackConfig",
            "description": "Specification for the rollback strategy of the service\n"
          },
          "taskSpec": {
            "$ref": "#/types/docker:index/ServiceTaskSpec:ServiceTaskSpec",
            "description": "User modifiable task configuration\n"
          },
          "updateConfig": {
            "$ref": "#/types/docker:index/ServiceUpdateConfig:ServiceUpdateConfig",
            "description": "Specification for the update strategy of the service\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/serviceConfig:ServiceConfig": {
      "description": "\n\n\n## Import\n\n### Example Assuming you created a `config` as follows #!/bin/bash printf '{\"a\":\"b\"}' | docker config create foo - # prints the id\n\n08c26c477474478d971139f750984775a7f019dbe8a2e7f09d66a187c009e66d you provide the definition for the resource as follows terraform resource \"docker_config\" \"foo\" {\n\n name = \"foo\"\n\n data = base64encode(\"{\\\"a\\\"\\\"b\\\"}\") } then the import command is as follows #!/bin/bash\n\n```sh\n $ pulumi import docker:index/serviceConfig:ServiceConfig foo 08c26c477474478d971139f750984775a7f019dbe8a2e7f09d66a187c009e66d\n```\n\n ",
      "properties": {
        "data": {
          "type": "string",
          "description": "Base64-url-safe-encoded config data\n"
        },
        "name": {
          "type": "string",
          "description": "User-defined name of the config\n"
        }
      },
      "required": [
        "data",
        "name"
      ],
      "inputProperties": {
        "data": {
          "type": "string",
          "description": "Base64-url-safe-encoded config data\n"
        },
        "name": {
          "type": "string",
          "description": "User-defined name of the config\n"
        }
      },
      "requiredInputs": [
        "data"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering ServiceConfig resources.\n",
        "properties": {
          "data": {
            "type": "string",
            "description": "Base64-url-safe-encoded config data\n"
          },
          "name": {
            "type": "string",
            "description": "User-defined name of the config\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/volume:Volume": {
      "description": "<!-- Bug: Type and Name are switched -->\nCreates and destroys a volume in Docker. This can be used alongside docker.Container to prepare volumes that can be shared across containers.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst sharedVolume = new docker.Volume(\"shared_volume\", {});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nshared_volume = docker.Volume(\"sharedVolume\")\n```\n```csharp\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var sharedVolume = new Docker.Volume(\"sharedVolume\", new Docker.VolumeArgs\n        {\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewVolume(ctx, \"sharedVolume\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n<!-- schema generated by tfplugindocs -->\n{{% /example %}}\n{{% /examples %}}\n## Schema\n\n### Optional\n\n- **driver** (String) Driver type for the volume. Defaults to `local`.\n- **driver_opts** (Map of String) Options specific to the driver.\n- **id** (String) The ID of this resource.\n- **labels** (Block Set) User-defined key/value metadata (see below for nested schema)\n- **name** (String) The name of the Docker volume (will be generated if not provided).\n\n### Read-Only\n\n- **mountpoint** (String) The mountpoint of the volume.\n\n<a id=\"nestedblock--labels\"></a>\n### Nested Schema for `labels`\n\nRequired:\n\n- **label** (String) Name of the label\n- **value** (String) Value of the label\n\n\n## Import\n\n### Example Assuming you created a `volume` as follows #!/bin/bash docker volume create # prints the long ID 524b0457aa2a87dd2b75c74c3e4e53f406974249e63ab3ed9bf21e5644f9dc7d you provide the definition for the resource as follows terraform resource \"docker_volume\" \"foo\" {\n\n name = \"524b0457aa2a87dd2b75c74c3e4e53f406974249e63ab3ed9bf21e5644f9dc7d\" } then the import command is as follows #!/bin/bash\n\n```sh\n $ pulumi import docker:index/volume:Volume foo 524b0457aa2a87dd2b75c74c3e4e53f406974249e63ab3ed9bf21e5644f9dc7d\n```\n\n ",
      "properties": {
        "driver": {
          "type": "string",
          "description": "Driver type for the volume. Defaults to `local`.\n"
        },
        "driverOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Options specific to the driver.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/VolumeLabel:VolumeLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "mountpoint": {
          "type": "string",
          "description": "The mountpoint of the volume.\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker volume (will be generated if not provided).\n"
        }
      },
      "required": [
        "driver",
        "mountpoint",
        "name"
      ],
      "inputProperties": {
        "driver": {
          "type": "string",
          "description": "Driver type for the volume. Defaults to `local`.\n"
        },
        "driverOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Options specific to the driver.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index/VolumeLabel:VolumeLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker volume (will be generated if not provided).\n"
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Volume resources.\n",
        "properties": {
          "driver": {
            "type": "string",
            "description": "Driver type for the volume. Defaults to `local`.\n"
          },
          "driverOpts": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "Options specific to the driver.\n"
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/VolumeLabel:VolumeLabel"
            },
            "description": "User-defined key/value metadata\n"
          },
          "mountpoint": {
            "type": "string",
            "description": "The mountpoint of the volume.\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker volume (will be generated if not provided).\n"
          }
        },
        "type": "object"
      }
    }
  },
  "functions": {
    "docker:index/getNetwork:getNetwork": {
      "description": "`docker.Network` provides details about a specific Docker Network.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst main = pulumi.output(docker.getNetwork({\n    name: \"main\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nmain = docker.get_network(name=\"main\")\n```\n```csharp\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var main = Output.Create(Docker.GetNetwork.InvokeAsync(new Docker.GetNetworkArgs\n        {\n            Name = \"main\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.LookupNetwork(ctx, &docker.LookupNetworkArgs{\n\t\t\tName: \"main\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n<!-- schema generated by tfplugindocs -->\n{{% /example %}}\n{{% /examples %}}\n## Schema\n\n### Required\n\n- **name** (String) The name of the Docker network.\n\n### Read-Only\n\n- **driver** (String) The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network docs](https://docs.docker.com/network/#network-drivers) for more details.\n- **id** (String) The ID of this resource.\n- **internal** (Boolean) If `true`, the network is internal.\n- **ipam_config** (Set of Object) The IPAM configuration options (see below for nested schema)\n- **options** (Map of String) Only available with bridge networks. See [bridge options docs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n- **scope** (String) Scope of the network. One of `swarm`, `global`, or `local`.\n\n<a id=\"nestedatt--ipam_config\"></a>\n### Nested Schema for `ipam_config`\n\nRead-Only:\n\n- **aux_address** (Map of String)\n- **gateway** (String)\n- **ip_range** (String)\n- **subnet** (String)\n",
      "inputs": {
        "description": "A collection of arguments for invoking getNetwork.\n",
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "name"
        ]
      },
      "outputs": {
        "description": "A collection of values returned by getNetwork.\n",
        "properties": {
          "driver": {
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "internal": {
            "type": "boolean"
          },
          "ipamConfigs": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index/getNetworkIpamConfig:getNetworkIpamConfig"
            }
          },
          "name": {
            "type": "string"
          },
          "options": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            }
          },
          "scope": {
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "driver",
          "id",
          "internal",
          "ipamConfigs",
          "name",
          "options",
          "scope"
        ]
      }
    },
    "docker:index/getPlugin:getPlugin": {
      "description": "Reads the local Docker plugin. The plugin must be installed locally.\n\n{{% examples %}}\n## Example Usage\n\n### With alias\ndata \"docker.Plugin\" \"by_alias\" {\n  alias = \"sample-volume-plugin:latest\"\n}\n{{% /examples %}}\n## Schema\n\n### Optional\n\n- **alias** (String) The alias of the Docker plugin. If the tag is omitted, `:latest` is complemented to the attribute value.\n- **id** (String) The ID of the plugin, which has precedence over the `alias` of both are given\n\n### Read-Only\n\n- **enabled** (Boolean) If `true` the plugin is enabled\n- **env** (Set of String) The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n- **grant_all_permissions** (Boolean) If true, grant all permissions necessary to run the plugin\n- **name** (String) The plugin name. If the tag is omitted, `:latest` is complemented to the attribute value.\n- **plugin_reference** (String) The Docker Plugin Reference\n",
      "inputs": {
        "description": "A collection of arguments for invoking getPlugin.\n",
        "properties": {
          "alias": {
            "type": "string"
          },
          "id": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "outputs": {
        "description": "A collection of values returned by getPlugin.\n",
        "properties": {
          "alias": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "envs": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "grantAllPermissions": {
            "type": "boolean"
          },
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "pluginReference": {
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "enabled",
          "envs",
          "grantAllPermissions",
          "name",
          "pluginReference"
        ]
      }
    },
    "docker:index/getRegistryImage:getRegistryImage": {
      "description": "Reads the image metadata from a Docker Registry. Used in conjunction with the docker.RemoteImage resource to keep an image up to date on the latest available version of the tag.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ubuntuRegistryImage = docker.getRegistryImage({\n    name: \"ubuntu:precise\",\n});\nconst ubuntuRemoteImage = new docker.RemoteImage(\"ubuntuRemoteImage\", {\n    name: ubuntuRegistryImage.then(ubuntuRegistryImage => ubuntuRegistryImage.name),\n    pullTriggers: [ubuntuRegistryImage.then(ubuntuRegistryImage => ubuntuRegistryImage.sha256Digest)],\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nubuntu_registry_image = docker.get_registry_image(name=\"ubuntu:precise\")\nubuntu_remote_image = docker.RemoteImage(\"ubuntuRemoteImage\",\n    name=ubuntu_registry_image.name,\n    pull_triggers=[ubuntu_registry_image.sha256_digest])\n```\n```csharp\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ubuntuRegistryImage = Output.Create(Docker.GetRegistryImage.InvokeAsync(new Docker.GetRegistryImageArgs\n        {\n            Name = \"ubuntu:precise\",\n        }));\n        var ubuntuRemoteImage = new Docker.RemoteImage(\"ubuntuRemoteImage\", new Docker.RemoteImageArgs\n        {\n            Name = ubuntuRegistryImage.Apply(ubuntuRegistryImage => ubuntuRegistryImage.Name),\n            PullTriggers = \n            {\n                ubuntuRegistryImage.Apply(ubuntuRegistryImage => ubuntuRegistryImage.Sha256Digest),\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tubuntuRegistryImage, err := docker.LookupRegistryImage(ctx, &docker.LookupRegistryImageArgs{\n\t\t\tName: \"ubuntu:precise\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.NewRemoteImage(ctx, \"ubuntuRemoteImage\", &docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(ubuntuRegistryImage.Name),\n\t\t\tPullTriggers: pulumi.StringArray{\n\t\t\t\tpulumi.String(ubuntuRegistryImage.Sha256Digest),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n<!-- schema generated by tfplugindocs -->\n{{% /example %}}\n{{% /examples %}}\n## Schema\n\n### Required\n\n- **name** (String) The name of the Docker image, including any tags. e.g. `alpine:latest`\n\n### Optional\n\n- **id** (String) The ID of this resource.\n- **insecure_skip_verify** (Boolean) If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n\n### Read-Only\n\n- **sha256_digest** (String) The content digest of the image, as stored in the registry.\n",
      "inputs": {
        "description": "A collection of arguments for invoking getRegistryImage.\n",
        "properties": {
          "insecureSkipVerify": {
            "type": "boolean"
          },
          "name": {
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "name"
        ]
      },
      "outputs": {
        "description": "A collection of values returned by getRegistryImage.\n",
        "properties": {
          "id": {
            "type": "string",
            "description": "The provider-assigned unique ID for this managed resource.\n"
          },
          "insecureSkipVerify": {
            "type": "boolean"
          },
          "name": {
            "type": "string"
          },
          "sha256Digest": {
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "name",
          "sha256Digest",
          "id"
        ]
      }
    },
    "docker:index/getRemoteImage:getRemoteImage": {
      "description": "`docker.RemoteImage` provides details about a specific Docker Image which need to be presend on the Docker Host\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\n// uses the 'latest' tag\nconst latest = pulumi.output(docker.getRemoteImage({\n    name: \"nginx\",\n}, { async: true }));\n// uses a specific tag\nconst specific = pulumi.output(docker.getRemoteImage({\n    name: \"nginx:1.17.6\",\n}, { async: true }));\n// use the image digest\nconst digest = pulumi.output(docker.getRemoteImage({\n    name: \"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n}, { async: true }));\n// uses the tag and the image digest\nconst tagAndDigest = pulumi.output(docker.getRemoteImage({\n    name: \"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nlatest = docker.get_remote_image(name=\"nginx\")\nspecific = docker.get_remote_image(name=\"nginx:1.17.6\")\ndigest = docker.get_remote_image(name=\"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\")\ntag_and_digest = docker.get_remote_image(name=\"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\")\n```\n```csharp\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var latest = Output.Create(Docker.GetRemoteImage.InvokeAsync(new Docker.GetRemoteImageArgs\n        {\n            Name = \"nginx\",\n        }));\n        var specific = Output.Create(Docker.GetRemoteImage.InvokeAsync(new Docker.GetRemoteImageArgs\n        {\n            Name = \"nginx:1.17.6\",\n        }));\n        var digest = Output.Create(Docker.GetRemoteImage.InvokeAsync(new Docker.GetRemoteImageArgs\n        {\n            Name = \"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n        }));\n        var tagAndDigest = Output.Create(Docker.GetRemoteImage.InvokeAsync(new Docker.GetRemoteImageArgs\n        {\n            Name = \"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.LookupRemoteImage(ctx, &docker.LookupRemoteImageArgs{\n\t\t\tName: \"nginx\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.LookupRemoteImage(ctx, &docker.LookupRemoteImageArgs{\n\t\t\tName: \"nginx:1.17.6\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.LookupRemoteImage(ctx, &docker.LookupRemoteImageArgs{\n\t\t\tName: \"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.LookupRemoteImage(ctx, &docker.LookupRemoteImageArgs{\n\t\t\tName: \"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n<!-- schema generated by tfplugindocs -->\n{{% /example %}}\n{{% /examples %}}\n## Schema\n\n### Required\n\n- **name** (String) The name of the Docker image, including any tags or SHA256 repo digests.\n\n### Optional\n\n- **id** (String) The ID of this resource.\n\n### Read-Only\n\n- **repo_digest** (String) The image sha256 digest in the form of `repo[:tag]@sha256:<hash>`. It may be empty in the edge case where the local image was pulled from a repo, tagged locally, and then referred to in the data source by that local name/tag.\n",
      "inputs": {
        "description": "A collection of arguments for invoking getRemoteImage.\n",
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "name"
        ]
      },
      "outputs": {
        "description": "A collection of values returned by getRemoteImage.\n",
        "properties": {
          "id": {
            "type": "string",
            "description": "The provider-assigned unique ID for this managed resource.\n"
          },
          "name": {
            "type": "string"
          },
          "repoDigest": {
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "name",
          "repoDigest",
          "id"
        ]
      }
    }
  },
  "language": {
    "csharp": {
      "compatibility": "tfbridge20",
      "namespaces": {
        "docker": "Docker"
      },
      "packageReferences": {
        "Pulumi": "3.*",
        "Semver": "2.0.6"
      }
    },
    "go": {
      "generateResourceContainerTypes": true,
      "importBasePath": "github.com/pulumi/pulumi-docker/sdk/v3/go/docker"
    },
    "nodejs": {
      "compatibility": "tfbridge20",
      "dependencies": {
        "@pulumi/pulumi": "^3.0.0",
        "semver": "^5.4.0"
      },
      "devDependencies": {
        "@types/node": "^10.0.0",
        "@types/semver": "^5.4.0"
      },
      "disableUnionOutputTypes": true,
      "packageDescription": "A Pulumi package for interacting with Docker in Pulumi programs",
      "packageName": "",
      "readme": "> This provider is a derived work of the [Terraform Provider](https://github.com/terraform-providers/terraform-provider-docker)\n> distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n> first check the [`pulumi/pulumi-docker` repo](https://github.com/pulumi/pulumi-docker/issues); however, if that doesn't turn up anything,\n> please consult the source [`terraform-providers/terraform-provider-docker` repo](https://github.com/terraform-providers/terraform-provider-docker/issues).",
      "typescriptVersion": ""
    },
    "python": {
      "compatibility": "tfbridge20",
      "readme": "> This provider is a derived work of the [Terraform Provider](https://github.com/terraform-providers/terraform-provider-docker)\n> distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n> first check the [`pulumi/pulumi-docker` repo](https://github.com/pulumi/pulumi-docker/issues); however, if that doesn't turn up anything,\n> please consult the source [`terraform-providers/terraform-provider-docker` repo](https://github.com/terraform-providers/terraform-provider-docker/issues).",
      "requires": {
        "pulumi": ">=3.0.0,<4.0.0"
      }
    }
  },
  "version": "3.1.0"
}
