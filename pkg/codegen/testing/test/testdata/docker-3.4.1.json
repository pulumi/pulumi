{
  "name": "docker",
  "version": "3.4.1",
  "description": "A Pulumi package for interacting with Docker in Pulumi programs",
  "keywords": [
    "pulumi",
    "docker"
  ],
  "homepage": "https://pulumi.io",
  "license": "Apache-2.0",
  "attribution": "This Pulumi package is based on the [`docker` Terraform Provider](https://github.com/terraform-providers/terraform-provider-docker).",
  "repository": "https://github.com/pulumi/pulumi-docker",
  "meta": {
    "moduleFormat": "(.*)(?:/[^/]*)"
  },
  "config": {
    "variables": {
      "caMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker host CA certificate\n"
      },
      "certMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker client certificate\n"
      },
      "certPath": {
        "type": "string",
        "description": "Path to directory with Docker TLS config\n"
      },
      "host": {
        "type": "string",
        "description": "The Docker daemon address\n",
        "default": "unix:///var/run/docker.sock",
        "defaultInfo": {
          "environment": [
            "DOCKER_HOST"
          ]
        }
      },
      "keyMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker client private key\n"
      },
      "registryAuth": {
        "type": "array",
        "items": {
          "$ref": "#/types/docker:config%2FregistryAuth:registryAuth"
        }
      },
      "sshOpts": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional SSH option flags to be appended when using `ssh://` protocol\n"
      }
    },
    "defaults": [
      "host"
    ]
  },
  "types": {
    "docker:config/registryAuth:registryAuth": {
      "properties": {
        "address": {
          "type": "string"
        },
        "configFile": {
          "type": "string"
        },
        "configFileContent": {
          "type": "string"
        },
        "password": {
          "type": "string"
        },
        "username": {
          "type": "string"
        }
      },
      "type": "object",
      "required": [
        "address"
      ],
      "language": {
        "nodejs": {
          "requiredInputs": []
        }
      }
    },
    "docker:index/ContainerCapabilities:ContainerCapabilities": {
      "properties": {
        "adds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of linux capabilities to add.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "drops": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of linux capabilities to drop.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ContainerDevice:ContainerDevice": {
      "properties": {
        "containerPath": {
          "type": "string",
          "description": "The path in the container where the device will be bound.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "hostPath": {
          "type": "string",
          "description": "The path on the host where the device is located.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "permissions": {
          "type": "string",
          "description": "The cgroup permissions given to the container to access the device. Defaults to `rwm`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "hostPath"
      ]
    },
    "docker:index/ContainerHealthcheck:ContainerHealthcheck": {
      "properties": {
        "interval": {
          "type": "string",
          "description": "Time between running the check (ms|s|m|h). Defaults to `0s`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "retries": {
          "type": "integer",
          "description": "Consecutive failures needed to report unhealthy. Defaults to `0`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "startPeriod": {
          "type": "string",
          "description": "Start period for the container to initialize before counting retries towards unstable (ms|s|m|h). Defaults to `0s`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tests": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Command to run to check health. For example, to run `curl -f localhost/health` set the command to be `[\"CMD\", \"curl\", \"-f\", \"localhost/health\"]`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "timeout": {
          "type": "string",
          "description": "Maximum time to allow one check to run (ms|s|m|h). Defaults to `0s`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "tests"
      ]
    },
    "docker:index/ContainerHost:ContainerHost": {
      "properties": {
        "host": {
          "type": "string",
          "description": "Hostname to add\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ip": {
          "type": "string",
          "description": "IP address this hostname should resolve to.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "host",
        "ip"
      ]
    },
    "docker:index/ContainerLabel:ContainerLabel": {
      "properties": {
        "label": {
          "type": "string",
          "description": "Name of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "description": "Value of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ContainerMount:ContainerMount": {
      "properties": {
        "bindOptions": {
          "$ref": "#/types/docker:index%2FContainerMountBindOptions:ContainerMountBindOptions",
          "description": "Optional configuration for the bind type.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "readOnly": {
          "type": "boolean",
          "description": "Whether the mount should be read-only.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "source": {
          "type": "string",
          "description": "Mount source (e.g. a volume name, a host path).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "target": {
          "type": "string",
          "description": "Container path\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tmpfsOptions": {
          "$ref": "#/types/docker:index%2FContainerMountTmpfsOptions:ContainerMountTmpfsOptions",
          "description": "Optional configuration for the tmpfs type.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "type": {
          "type": "string",
          "description": "The mount type\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "volumeOptions": {
          "$ref": "#/types/docker:index%2FContainerMountVolumeOptions:ContainerMountVolumeOptions",
          "description": "Optional configuration for the volume type.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "target",
        "type"
      ]
    },
    "docker:index/ContainerMountBindOptions:ContainerMountBindOptions": {
      "properties": {
        "propagation": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ContainerMountTmpfsOptions:ContainerMountTmpfsOptions": {
      "properties": {
        "mode": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "sizeBytes": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ContainerMountVolumeOptions:ContainerMountVolumeOptions": {
      "properties": {
        "driverName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "driverOptions": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerMountVolumeOptionsLabel:ContainerMountVolumeOptionsLabel"
          },
          "description": "User-defined key/value metadata\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "noCopy": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ContainerMountVolumeOptionsLabel:ContainerMountVolumeOptionsLabel": {
      "properties": {
        "label": {
          "type": "string",
          "description": "Name of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "description": "Value of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ContainerNetworkData:ContainerNetworkData": {
      "properties": {
        "gateway": {
          "type": "string",
          "description": "The network gateway of the container.\n",
          "deprecationMessage": "Use `network_data` instead. The network gateway of the container as read from its NetworkSettings.",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "globalIpv6Address": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "globalIpv6PrefixLength": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipAddress": {
          "type": "string",
          "description": "The IP address of the container.\n",
          "deprecationMessage": "Use `network_data` instead. The IP address of the container's first network it.",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipPrefixLength": {
          "type": "integer",
          "description": "The IP prefix length of the container.\n",
          "deprecationMessage": "Use `network_data` instead. The IP prefix length of the container as read from its NetworkSettings.",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6Gateway": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "gateway",
            "globalIpv6Address",
            "globalIpv6PrefixLength",
            "ipAddress",
            "ipPrefixLength",
            "ipv6Gateway",
            "networkName"
          ]
        }
      }
    },
    "docker:index/ContainerNetworksAdvanced:ContainerNetworksAdvanced": {
      "properties": {
        "aliases": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The network aliases of the container in the specific network.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv4Address": {
          "type": "string",
          "description": "The IPV4 address of the container in the specific network.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6Address": {
          "type": "string",
          "description": "The IPV6 address of the container in the specific network.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "description": "The name or id of the network to use. You can use `name` or `id` attribute from a `docker.Network` resource.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "name"
      ]
    },
    "docker:index/ContainerPort:ContainerPort": {
      "properties": {
        "external": {
          "type": "integer",
          "description": "Port exposed out of the container. If not given a free random port `\u003e= 32768` will be used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "internal": {
          "type": "integer",
          "description": "Port within the container.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ip": {
          "type": "string",
          "description": "IP address/mask that can access this port. Defaults to `0.0.0.0`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "protocol": {
          "type": "string",
          "description": "Protocol that can be used over this port. Defaults to `tcp`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "internal"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "external",
            "internal"
          ]
        }
      }
    },
    "docker:index/ContainerUlimit:ContainerUlimit": {
      "properties": {
        "hard": {
          "type": "integer",
          "description": "The hard limit\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "description": "The name of the ulimit\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "soft": {
          "type": "integer",
          "description": "The soft limit\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "hard",
        "name",
        "soft"
      ]
    },
    "docker:index/ContainerUpload:ContainerUpload": {
      "properties": {
        "content": {
          "type": "string",
          "description": "Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text. Conflicts with `content_base64` \u0026 `source`\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "contentBase64": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "executable": {
          "type": "boolean",
          "description": "If `true`, the file will be uploaded with user executable permission. Defaults to `false`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "file": {
          "type": "string",
          "description": "Path to the file in the container where is upload goes to\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "source": {
          "type": "string",
          "description": "A filename that references a file which will be uploaded as the object content. This allows for large file uploads that do not get stored in state. Conflicts with `content` \u0026 `content_base64`\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "sourceHash": {
          "type": "string",
          "description": "If using `source`, this will force an update if the file content has updated but the filename has not.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "file"
      ]
    },
    "docker:index/ContainerVolume:ContainerVolume": {
      "properties": {
        "containerPath": {
          "type": "string",
          "description": "The path in the container where the volume will be mounted.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fromContainer": {
          "type": "string",
          "description": "The container where the volume is coming from.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "hostPath": {
          "type": "string",
          "description": "The path on the host where the volume is coming from.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "readOnly": {
          "type": "boolean",
          "description": "If `true`, this volume will be readonly. Defaults to `false`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "volumeName": {
          "type": "string",
          "description": "The name of the docker volume which should be mounted.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/NetworkIpamConfig:NetworkIpamConfig": {
      "properties": {
        "auxAddress": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Auxiliary IPv4 or IPv6 addresses used by Network driver\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "gateway": {
          "type": "string",
          "description": "The IP address of the gateway\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipRange": {
          "type": "string",
          "description": "The ip range in CIDR form\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnet": {
          "type": "string",
          "description": "The subnet in CIDR form\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/NetworkLabel:NetworkLabel": {
      "properties": {
        "label": {
          "type": "string",
          "description": "Name of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "description": "Value of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/PluginGrantPermission:PluginGrantPermission": {
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the permission\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The value of the permission\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "name",
        "values"
      ]
    },
    "docker:index/ProviderRegistryAuth:ProviderRegistryAuth": {
      "properties": {
        "address": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "configFile": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "configFileContent": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "password": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "username": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "address"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": []
        }
      }
    },
    "docker:index/RegistryImageBuild:RegistryImageBuild": {
      "properties": {
        "authConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FRegistryImageBuildAuthConfig:RegistryImageBuildAuthConfig"
          },
          "description": "The configuration for the authentication\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "buildArgs": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Pairs for build-time variables in the form TODO\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "buildId": {
          "type": "string",
          "description": "BuildID is an optional identifier that can be passed together with the build request. The same identifier can be used to gracefully cancel the build with the cancel request.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cacheFroms": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Images to consider as cache sources\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cgroupParent": {
          "type": "string",
          "description": "Optional parent cgroup for the container\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "context": {
          "type": "string",
          "description": "The absolute path to the context folder. You can use the helper function '${path.cwd}/context-dir'.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cpuPeriod": {
          "type": "integer",
          "description": "The length of a CPU period in microseconds\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cpuQuota": {
          "type": "integer",
          "description": "Microseconds of CPU time that the container can get in a CPU period\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cpuSetCpus": {
          "type": "string",
          "description": "CPUs in which to allow execution (e.g., `0-3`, `0`, `1`)\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cpuSetMems": {
          "type": "string",
          "description": "MEMs in which to allow execution (`0-3`, `0`, `1`)\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cpuShares": {
          "type": "integer",
          "description": "CPU shares (relative weight)\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "dockerfile": {
          "type": "string",
          "description": "Dockerfile file. Defaults to `Dockerfile`\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "extraHosts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of hostnames/IP mappings to add to the containerâ€™s /etc/hosts file. Specified in the form [\"hostname:IP\"]\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "forceRemove": {
          "type": "boolean",
          "description": "Always remove intermediate containers\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "isolation": {
          "type": "string",
          "description": "Isolation represents the isolation technology of a container. The supported values are\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "User-defined key/value metadata\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "memory": {
          "type": "integer",
          "description": "Set memory limit for build\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "memorySwap": {
          "type": "integer",
          "description": "Total memory (memory + swap), -1 to enable unlimited swap\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkMode": {
          "type": "string",
          "description": "Set the networking mode for the RUN instructions during build\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "noCache": {
          "type": "boolean",
          "description": "Do not use the cache when building the image\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "platform": {
          "type": "string",
          "description": "Set platform if server is multi-platform capable\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "pullParent": {
          "type": "boolean",
          "description": "Attempt to pull the image even if an older image exists locally\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "remoteContext": {
          "type": "string",
          "description": "A Git repository URI or HTTP/HTTPS context URI\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "remove": {
          "type": "boolean",
          "description": "Remove intermediate containers after a successful build (default behavior)\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "securityOpts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The security options\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "sessionId": {
          "type": "string",
          "description": "Set an ID for the build session\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "shmSize": {
          "type": "integer",
          "description": "Size of /dev/shm in bytes. The size must be greater than 0\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "squash": {
          "type": "boolean",
          "description": "If true the new layers are squashed into a new image with a single new layer\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "suppressOutput": {
          "type": "boolean",
          "description": "Suppress the build output and print image ID on success\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "target": {
          "type": "string",
          "description": "Set the target build stage to build\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ulimits": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FRegistryImageBuildUlimit:RegistryImageBuildUlimit"
          },
          "description": "Configuration for ulimits\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "version": {
          "type": "string",
          "description": "Version of the underlying builder to use\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "context"
      ]
    },
    "docker:index/RegistryImageBuildAuthConfig:RegistryImageBuildAuthConfig": {
      "properties": {
        "auth": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "email": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "hostName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "identityToken": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "password": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "registryToken": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "serverAddress": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "userName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "hostName"
      ]
    },
    "docker:index/RegistryImageBuildUlimit:RegistryImageBuildUlimit": {
      "properties": {
        "hard": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker image.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "soft": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "hard",
        "name",
        "soft"
      ]
    },
    "docker:index/RemoteImageBuild:RemoteImageBuild": {
      "properties": {
        "buildArg": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Set build-time variables\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "dockerfile": {
          "type": "string",
          "description": "Name of the Dockerfile. Defaults to `Dockerfile`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "forceRemove": {
          "type": "boolean",
          "description": "Always remove intermediate containers\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "label": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Set metadata for an image\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "noCache": {
          "type": "boolean",
          "description": "Do not use cache when building the image\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "path": {
          "type": "string",
          "description": "Context path\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "remove": {
          "type": "boolean",
          "description": "Remove intermediate containers after a successful build. Defaults to  `true`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Name and optionally a tag in the 'name:tag' format\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "target": {
          "type": "string",
          "description": "Set the target build stage to build\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "path"
      ]
    },
    "docker:index/SecretLabel:SecretLabel": {
      "properties": {
        "label": {
          "type": "string",
          "description": "Name of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "description": "Value of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ServiceAuth:ServiceAuth": {
      "properties": {
        "password": {
          "type": "string",
          "description": "The password\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "serverAddress": {
          "type": "string",
          "description": "The address of the server for the authentication\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "username": {
          "type": "string",
          "description": "The username\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "serverAddress"
      ]
    },
    "docker:index/ServiceConvergeConfig:ServiceConvergeConfig": {
      "properties": {
        "delay": {
          "type": "string",
          "description": "The interval to check if the desired state is reached `(ms|s)`. Defaults to `7s`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "timeout": {
          "type": "string",
          "description": "The timeout of the service to reach the desired state `(s|m)`. Defaults to `3m`\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceEndpointSpec:ServiceEndpointSpec": {
      "properties": {
        "mode": {
          "type": "string",
          "description": "The mode of resolution to use for internal load balancing between tasks\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ports": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FServiceEndpointSpecPort:ServiceEndpointSpecPort"
          },
          "description": "List of exposed ports that this service is accessible on from the outside. Ports can only be provided if 'vip' resolution mode is used\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "mode"
          ]
        }
      }
    },
    "docker:index/ServiceEndpointSpecPort:ServiceEndpointSpecPort": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the service\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "protocol": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publishMode": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publishedPort": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "targetPort": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "targetPort"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "publishedPort",
            "targetPort"
          ]
        }
      }
    },
    "docker:index/ServiceLabel:ServiceLabel": {
      "properties": {
        "label": {
          "type": "string",
          "description": "Name of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "description": "Value of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ServiceMode:ServiceMode": {
      "properties": {
        "global": {
          "type": "boolean",
          "description": "The global service mode. Defaults to `false`\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "replicated": {
          "$ref": "#/types/docker:index%2FServiceModeReplicated:ServiceModeReplicated",
          "description": "The replicated service mode\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "replicated"
          ]
        }
      }
    },
    "docker:index/ServiceModeReplicated:ServiceModeReplicated": {
      "properties": {
        "replicas": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceRollbackConfig:ServiceRollbackConfig": {
      "properties": {
        "delay": {
          "type": "string",
          "description": "Delay between task rollbacks (ns|us|ms|s|m|h). Defaults to `0s`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "failureAction": {
          "type": "string",
          "description": "Action on rollback failure: pause | continue. Defaults to `pause`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxFailureRatio": {
          "type": "string",
          "description": "Failure rate to tolerate during a rollback. Defaults to `0.0`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "monitor": {
          "type": "string",
          "description": "Duration after each task rollback to monitor for failure (ns|us|ms|s|m|h). Defaults to `5s`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "order": {
          "type": "string",
          "description": "Rollback order: either 'stop-first' or 'start-first'. Defaults to `stop-first`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "parallelism": {
          "type": "integer",
          "description": "Maximum number of tasks to be rollbacked in one iteration. Defaults to `1`\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpec:ServiceTaskSpec": {
      "properties": {
        "containerSpec": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpec:ServiceTaskSpecContainerSpec",
          "description": "The spec for each container\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "forceUpdate": {
          "type": "integer",
          "description": "A counter that triggers an update even if no relevant parameters have been changed. See the [spec](https://github.com/docker/swarmkit/blob/master/api/specs.proto#L126).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "logDriver": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecLogDriver:ServiceTaskSpecLogDriver",
          "description": "Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networks": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Ids of the networks in which the  container will be put in\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "placement": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecPlacement:ServiceTaskSpecPlacement",
          "description": "The placement preferences\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "resources": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecResources:ServiceTaskSpecResources",
          "description": "Resource requirements which apply to each individual container created as part of the service\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "restartPolicy": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecRestartPolicy:ServiceTaskSpecRestartPolicy",
          "description": "Specification for the restart policy which applies to containers created as part of this service.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "runtime": {
          "type": "string",
          "description": "Runtime is the type of runtime specified for the task executor. See the [types](https://github.com/moby/moby/blob/master/api/types/swarm/runtime.go).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "containerSpec"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "containerSpec",
            "forceUpdate",
            "placement",
            "resources",
            "restartPolicy",
            "runtime"
          ]
        }
      }
    },
    "docker:index/ServiceTaskSpecContainerSpec:ServiceTaskSpecContainerSpec": {
      "properties": {
        "args": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "commands": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "configs": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecConfig:ServiceTaskSpecContainerSpecConfig"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "dir": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "dnsConfig": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecDnsConfig:ServiceTaskSpecContainerSpecDnsConfig",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "env": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "healthcheck": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecHealthcheck:ServiceTaskSpecContainerSpecHealthcheck",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "hostname": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecHost:ServiceTaskSpecContainerSpecHost"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "image": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "isolation": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecLabel:ServiceTaskSpecContainerSpecLabel"
          },
          "description": "User-defined key/value metadata\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "mounts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecMount:ServiceTaskSpecContainerSpecMount"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "privileges": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecPrivileges:ServiceTaskSpecContainerSpecPrivileges",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "readOnly": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "secrets": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecSecret:ServiceTaskSpecContainerSpecSecret"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "stopGracePeriod": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "stopSignal": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "user": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "image"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "dnsConfig",
            "healthcheck",
            "image",
            "stopGracePeriod"
          ]
        }
      }
    },
    "docker:index/ServiceTaskSpecContainerSpecConfig:ServiceTaskSpecContainerSpecConfig": {
      "properties": {
        "configId": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "configName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileGid": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileMode": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileUid": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "configId",
        "fileName"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecDnsConfig:ServiceTaskSpecContainerSpecDnsConfig": {
      "properties": {
        "nameservers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "options": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "searches": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "nameservers"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecHealthcheck:ServiceTaskSpecContainerSpecHealthcheck": {
      "properties": {
        "interval": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "retries": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "startPeriod": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tests": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "timeout": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "tests"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecHost:ServiceTaskSpecContainerSpecHost": {
      "properties": {
        "host": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ip": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "host",
        "ip"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecLabel:ServiceTaskSpecContainerSpecLabel": {
      "properties": {
        "label": {
          "type": "string",
          "description": "Name of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "description": "Value of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecMount:ServiceTaskSpecContainerSpecMount": {
      "properties": {
        "bindOptions": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecMountBindOptions:ServiceTaskSpecContainerSpecMountBindOptions",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "readOnly": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "source": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "target": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tmpfsOptions": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecMountTmpfsOptions:ServiceTaskSpecContainerSpecMountTmpfsOptions",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "volumeOptions": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecMountVolumeOptions:ServiceTaskSpecContainerSpecMountVolumeOptions",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "target",
        "type"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecMountBindOptions:ServiceTaskSpecContainerSpecMountBindOptions": {
      "properties": {
        "propagation": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecMountTmpfsOptions:ServiceTaskSpecContainerSpecMountTmpfsOptions": {
      "properties": {
        "mode": {
          "type": "integer",
          "description": "Scheduling mode for the service\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "sizeBytes": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecMountVolumeOptions:ServiceTaskSpecContainerSpecMountVolumeOptions": {
      "properties": {
        "driverName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "driverOptions": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecMountVolumeOptionsLabel:ServiceTaskSpecContainerSpecMountVolumeOptionsLabel"
          },
          "description": "User-defined key/value metadata\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "noCopy": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecMountVolumeOptionsLabel:ServiceTaskSpecContainerSpecMountVolumeOptionsLabel": {
      "properties": {
        "label": {
          "type": "string",
          "description": "Name of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "description": "Value of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/ServiceTaskSpecContainerSpecPrivileges:ServiceTaskSpecContainerSpecPrivileges": {
      "properties": {
        "credentialSpec": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecPrivilegesCredentialSpec:ServiceTaskSpecContainerSpecPrivilegesCredentialSpec",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "seLinuxContext": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecContainerSpecPrivilegesSeLinuxContext:ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecPrivilegesCredentialSpec:ServiceTaskSpecContainerSpecPrivilegesCredentialSpec": {
      "properties": {
        "file": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "registry": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext:ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext": {
      "properties": {
        "disable": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "level": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "role": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "user": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecContainerSpecSecret:ServiceTaskSpecContainerSpecSecret": {
      "properties": {
        "fileGid": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileMode": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "fileUid": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "secretId": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "secretName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "fileName",
        "secretId"
      ]
    },
    "docker:index/ServiceTaskSpecLogDriver:ServiceTaskSpecLogDriver": {
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the service\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "options": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "name"
      ]
    },
    "docker:index/ServiceTaskSpecPlacement:ServiceTaskSpecPlacement": {
      "properties": {
        "constraints": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxReplicas": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "platforms": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FServiceTaskSpecPlacementPlatform:ServiceTaskSpecPlacementPlatform"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "prefs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecPlacementPlatform:ServiceTaskSpecPlacementPlatform": {
      "properties": {
        "architecture": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "os": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "architecture",
        "os"
      ]
    },
    "docker:index/ServiceTaskSpecResources:ServiceTaskSpecResources": {
      "properties": {
        "limits": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecResourcesLimits:ServiceTaskSpecResourcesLimits",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "reservation": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecResourcesReservation:ServiceTaskSpecResourcesReservation",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecResourcesLimits:ServiceTaskSpecResourcesLimits": {
      "properties": {
        "memoryBytes": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nanoCpus": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecResourcesReservation:ServiceTaskSpecResourcesReservation": {
      "properties": {
        "genericResources": {
          "$ref": "#/types/docker:index%2FServiceTaskSpecResourcesReservationGenericResources:ServiceTaskSpecResourcesReservationGenericResources",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "memoryBytes": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nanoCpus": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecResourcesReservationGenericResources:ServiceTaskSpecResourcesReservationGenericResources": {
      "properties": {
        "discreteResourcesSpecs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "namedResourcesSpecs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceTaskSpecRestartPolicy:ServiceTaskSpecRestartPolicy": {
      "properties": {
        "condition": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "delay": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxAttempts": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "window": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/ServiceUpdateConfig:ServiceUpdateConfig": {
      "properties": {
        "delay": {
          "type": "string",
          "description": "Delay between task updates `(ns|us|ms|s|m|h)`. Defaults to `0s`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "failureAction": {
          "type": "string",
          "description": "Action on update failure: `pause`, `continue` or `rollback`. Defaults to `pause`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxFailureRatio": {
          "type": "string",
          "description": "Failure rate to tolerate during an update. Defaults to `0.0`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "monitor": {
          "type": "string",
          "description": "Duration after each task update to monitor for failure (ns|us|ms|s|m|h). Defaults to `5s`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "order": {
          "type": "string",
          "description": "Update order: either 'stop-first' or 'start-first'. Defaults to `stop-first`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "parallelism": {
          "type": "integer",
          "description": "Maximum number of tasks to be updated in one iteration. Defaults to `1`\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "docker:index/VolumeLabel:VolumeLabel": {
      "properties": {
        "label": {
          "type": "string",
          "description": "Name of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "value": {
          "type": "string",
          "description": "Value of the label\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "label",
        "value"
      ]
    },
    "docker:index/getNetworkIpamConfig:getNetworkIpamConfig": {
      "properties": {
        "auxAddress": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "gateway": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipRange": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnet": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    }
  },
  "provider": {
    "description": "The provider type for the docker package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
    "properties": {
      "caMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker host CA certificate\n"
      },
      "certMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker client certificate\n"
      },
      "certPath": {
        "type": "string",
        "description": "Path to directory with Docker TLS config\n"
      },
      "host": {
        "type": "string",
        "description": "The Docker daemon address\n"
      },
      "keyMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker client private key\n"
      }
    },
    "type": "object",
    "inputProperties": {
      "caMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker host CA certificate\n"
      },
      "certMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker client certificate\n"
      },
      "certPath": {
        "type": "string",
        "description": "Path to directory with Docker TLS config\n"
      },
      "host": {
        "type": "string",
        "description": "The Docker daemon address\n",
        "default": "unix:///var/run/docker.sock",
        "defaultInfo": {
          "environment": [
            "DOCKER_HOST"
          ]
        }
      },
      "keyMaterial": {
        "type": "string",
        "description": "PEM-encoded content of Docker client private key\n"
      },
      "registryAuth": {
        "type": "array",
        "items": {
          "$ref": "#/types/docker:index%2FProviderRegistryAuth:ProviderRegistryAuth"
        }
      },
      "sshOpts": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Additional SSH option flags to be appended when using `ssh://` protocol\n"
      }
    }
  },
  "resources": {
    "docker:index/container:Container": {
      "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nManages the lifecycle of a Docker container.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\n// Find the latest Ubuntu precise image.\nconst ubuntuRemoteImage = new docker.RemoteImage(\"ubuntuRemoteImage\", {name: \"ubuntu:precise\"});\n// Start a container\nconst ubuntuContainer = new docker.Container(\"ubuntuContainer\", {image: ubuntuRemoteImage.latest});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\n# Find the latest Ubuntu precise image.\nubuntu_remote_image = docker.RemoteImage(\"ubuntuRemoteImage\", name=\"ubuntu:precise\")\n# Start a container\nubuntu_container = docker.Container(\"ubuntuContainer\", image=ubuntu_remote_image.latest)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Find the latest Ubuntu precise image.\n    var ubuntuRemoteImage = new Docker.RemoteImage(\"ubuntuRemoteImage\", new()\n    {\n        Name = \"ubuntu:precise\",\n    });\n\n    // Start a container\n    var ubuntuContainer = new Docker.Container(\"ubuntuContainer\", new()\n    {\n        Image = ubuntuRemoteImage.Latest,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tubuntuRemoteImage, err := docker.NewRemoteImage(ctx, \"ubuntuRemoteImage\", \u0026docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(\"ubuntu:precise\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.NewContainer(ctx, \"ubuntuContainer\", \u0026docker.ContainerArgs{\n\t\t\tImage: ubuntuRemoteImage.Latest,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.RemoteImage;\nimport com.pulumi.docker.RemoteImageArgs;\nimport com.pulumi.docker.Container;\nimport com.pulumi.docker.ContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ubuntuRemoteImage = new RemoteImage(\"ubuntuRemoteImage\", RemoteImageArgs.builder()        \n            .name(\"ubuntu:precise\")\n            .build());\n\n        var ubuntuContainer = new Container(\"ubuntuContainer\", ContainerArgs.builder()        \n            .image(ubuntuRemoteImage.latest())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Start a container\n  ubuntuContainer:\n    type: docker:Container\n    properties:\n      image: ${ubuntuRemoteImage.latest}\n  # Find the latest Ubuntu precise image.\n  ubuntuRemoteImage:\n    type: docker:RemoteImage\n    properties:\n      name: ubuntu:precise\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n### Example Assuming you created a `container` as follows #!/bin/bash docker run --name foo -p8080:80 -d nginx\n\n# prints the container ID\n\n9a550c0f0163d39d77222d3efd58701b625d47676c25c686c95b5b92d1cba6fd you provide the definition for the resource as follows terraform resource \"docker_container\" \"foo\" {\n\n name\n\n= \"foo\"\n\n image = \"nginx\"\n\n ports {\n\n\n\n internal = \"80\"\n\n\n\n external = \"8080\"\n\n } } then the import command is as follows #!/bin/bash\n\n```sh\n $ pulumi import docker:index/container:Container foo 9a550c0f0163d39d77222d3efd58701b625d47676c25c686c95b5b92d1cba6fd\n```\n\n ",
      "properties": {
        "attach": {
          "type": "boolean",
          "description": "If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.\n"
        },
        "bridge": {
          "type": "string",
          "description": "The network bridge of the container as read from its NetworkSettings.\n"
        },
        "capabilities": {
          "$ref": "#/types/docker:index%2FContainerCapabilities:ContainerCapabilities",
          "description": "Add or drop certrain linux capabilities.\n"
        },
        "command": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[\"/usr/bin/myprogram\",\"-\",\"baz.con\"]`.\n"
        },
        "containerLogs": {
          "type": "string",
          "description": "The logs of the container if its execution is done (`attach` must be disabled).\n"
        },
        "cpuSet": {
          "type": "string",
          "description": "A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.\n"
        },
        "cpuShares": {
          "type": "integer",
          "description": "CPU shares (relative weight) for the container.\n"
        },
        "destroyGraceSeconds": {
          "type": "integer",
          "description": "If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.\n"
        },
        "devices": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerDevice:ContainerDevice"
          },
          "description": "Bind devices to the container.\n"
        },
        "dns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS servers to use.\n"
        },
        "dnsOpts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.\n"
        },
        "dnsSearches": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS search domains that are used when bare unqualified hostnames are used inside of the container.\n"
        },
        "domainname": {
          "type": "string",
          "description": "Domain name of the container.\n"
        },
        "entrypoints": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `\"/usr/bin/myprogra\"]`.\n"
        },
        "envs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
        },
        "exitCode": {
          "type": "integer",
          "description": "The exit code of the container if its execution is done (`must_run` must be disabled).\n"
        },
        "gateway": {
          "type": "string",
          "description": "The network gateway of the container.\n",
          "deprecationMessage": "Use `network_data` instead. The network gateway of the container as read from its NetworkSettings."
        },
        "gpus": {
          "type": "string",
          "description": "GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.\n"
        },
        "groupAdds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Additional groups for the container user\n"
        },
        "healthcheck": {
          "$ref": "#/types/docker:index%2FContainerHealthcheck:ContainerHealthcheck",
          "description": "A test to perform to check that the container is healthy\n"
        },
        "hostname": {
          "type": "string",
          "description": "Hostname of the container.\n"
        },
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerHost:ContainerHost"
          },
          "description": "Additional hosts to add to the container.\n"
        },
        "image": {
          "type": "string",
          "description": "The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.\n"
        },
        "init": {
          "type": "boolean",
          "description": "Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.\n"
        },
        "ipAddress": {
          "type": "string",
          "description": "The IP address of the container.\n",
          "deprecationMessage": "Use `network_data` instead. The IP address of the container's first network it."
        },
        "ipPrefixLength": {
          "type": "integer",
          "description": "The IP prefix length of the container.\n",
          "deprecationMessage": "Use `network_data` instead. The IP prefix length of the container as read from its NetworkSettings."
        },
        "ipcMode": {
          "type": "string",
          "description": "IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:\u003cname|id\u003e` or `host`.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerLabel:ContainerLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "links": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Set of links for link based connectivity between containers that are running on the same host.\n",
          "deprecationMessage": "The --link flag is a legacy feature of Docker. It may eventually be removed."
        },
        "logDriver": {
          "type": "string",
          "description": "The logging driver to use for the container.\n"
        },
        "logOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Key/value pairs to use as options for the logging driver.\n"
        },
        "logs": {
          "type": "boolean",
          "description": "Save the container logs (`attach` must be enabled). Defaults to `false`.\n"
        },
        "maxRetryCount": {
          "type": "integer",
          "description": "The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.\n"
        },
        "memory": {
          "type": "integer",
          "description": "The memory limit for the container in MBs.\n"
        },
        "memorySwap": {
          "type": "integer",
          "description": "The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform\napply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.\n"
        },
        "mounts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerMount:ContainerMount"
          },
          "description": "Specification for mounts to be added to containers created as part of the service.\n"
        },
        "mustRun": {
          "type": "boolean",
          "description": "If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform\nassumes it is successful. Defaults to `true`.\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the container.\n"
        },
        "networkAliases": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Set an alias for the container in all specified networks\n",
          "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
        },
        "networkDatas": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerNetworkData:ContainerNetworkData"
          },
          "description": "The data of the networks the container is connected to.\n"
        },
        "networkMode": {
          "type": "string",
          "description": "Network mode of the container.\n"
        },
        "networks": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "ID of the networks in which the container is.\n",
          "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
        },
        "networksAdvanced": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerNetworksAdvanced:ContainerNetworksAdvanced"
          },
          "description": "The networks the container is attached to\n"
        },
        "pidMode": {
          "type": "string",
          "description": "he PID (Process) Namespace mode for the container. Either `container:\u003cname|id\u003e` or `host`.\n"
        },
        "ports": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerPort:ContainerPort"
          },
          "description": "Publish a container's port(s) to the host.\n"
        },
        "privileged": {
          "type": "boolean",
          "description": "If `true`, the container runs in privileged mode.\n"
        },
        "publishAllPorts": {
          "type": "boolean",
          "description": "Publish all ports of the container.\n"
        },
        "readOnly": {
          "type": "boolean",
          "description": "If `true`, the container will be started as readonly. Defaults to `false`.\n"
        },
        "removeVolumes": {
          "type": "boolean",
          "description": "If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.\n"
        },
        "restart": {
          "type": "string",
          "description": "The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.\n"
        },
        "rm": {
          "type": "boolean",
          "description": "If `true`, then the container will be automatically removed when it exits. Defaults to `false`.\n"
        },
        "runtime": {
          "type": "string",
          "description": "Runtime to use for the container.\n"
        },
        "securityOpts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.\n"
        },
        "shmSize": {
          "type": "integer",
          "description": "Size of `/dev/shm` in MBs.\n"
        },
        "start": {
          "type": "boolean",
          "description": "If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.\n"
        },
        "stdinOpen": {
          "type": "boolean",
          "description": "If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.\n"
        },
        "stopSignal": {
          "type": "string",
          "description": "Signal to stop a container (default `SIGTERM`).\n"
        },
        "stopTimeout": {
          "type": "integer",
          "description": "Timeout (in seconds) to stop a container.\n"
        },
        "storageOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Key/value pairs for the storage driver options, e.g. `size`: `120G`\n"
        },
        "sysctls": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of kernel parameters (sysctls) to set in the container.\n"
        },
        "tmpfs": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.\n"
        },
        "tty": {
          "type": "boolean",
          "description": "If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.\n"
        },
        "ulimits": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerUlimit:ContainerUlimit"
          },
          "description": "Ulimit options to add.\n"
        },
        "uploads": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerUpload:ContainerUpload"
          },
          "description": "Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.\n"
        },
        "user": {
          "type": "string",
          "description": "User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.\n"
        },
        "usernsMode": {
          "type": "string",
          "description": "Sets the usernamespace mode for the container when usernamespace remapping option is enabled.\n"
        },
        "volumes": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerVolume:ContainerVolume"
          },
          "description": "Spec for mounting volumes in the container.\n"
        },
        "workingDir": {
          "type": "string",
          "description": "The working directory for commands to run in.\n"
        }
      },
      "type": "object",
      "required": [
        "bridge",
        "command",
        "containerLogs",
        "entrypoints",
        "envs",
        "exitCode",
        "gateway",
        "healthcheck",
        "hostname",
        "image",
        "init",
        "ipAddress",
        "ipPrefixLength",
        "ipcMode",
        "labels",
        "logDriver",
        "name",
        "networkDatas",
        "runtime",
        "securityOpts",
        "shmSize",
        "stopSignal",
        "stopTimeout"
      ],
      "inputProperties": {
        "attach": {
          "type": "boolean",
          "description": "If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.\n"
        },
        "capabilities": {
          "$ref": "#/types/docker:index%2FContainerCapabilities:ContainerCapabilities",
          "description": "Add or drop certrain linux capabilities.\n"
        },
        "command": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[\"/usr/bin/myprogram\",\"-\",\"baz.con\"]`.\n"
        },
        "cpuSet": {
          "type": "string",
          "description": "A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.\n"
        },
        "cpuShares": {
          "type": "integer",
          "description": "CPU shares (relative weight) for the container.\n"
        },
        "destroyGraceSeconds": {
          "type": "integer",
          "description": "If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.\n"
        },
        "devices": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerDevice:ContainerDevice"
          },
          "description": "Bind devices to the container.\n"
        },
        "dns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS servers to use.\n"
        },
        "dnsOpts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.\n"
        },
        "dnsSearches": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DNS search domains that are used when bare unqualified hostnames are used inside of the container.\n"
        },
        "domainname": {
          "type": "string",
          "description": "Domain name of the container.\n"
        },
        "entrypoints": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `\"/usr/bin/myprogra\"]`.\n"
        },
        "envs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
        },
        "gpus": {
          "type": "string",
          "description": "GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.\n"
        },
        "groupAdds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Additional groups for the container user\n"
        },
        "healthcheck": {
          "$ref": "#/types/docker:index%2FContainerHealthcheck:ContainerHealthcheck",
          "description": "A test to perform to check that the container is healthy\n"
        },
        "hostname": {
          "type": "string",
          "description": "Hostname of the container.\n"
        },
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerHost:ContainerHost"
          },
          "description": "Additional hosts to add to the container.\n"
        },
        "image": {
          "type": "string",
          "description": "The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.\n"
        },
        "init": {
          "type": "boolean",
          "description": "Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.\n"
        },
        "ipcMode": {
          "type": "string",
          "description": "IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:\u003cname|id\u003e` or `host`.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerLabel:ContainerLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "links": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Set of links for link based connectivity between containers that are running on the same host.\n",
          "deprecationMessage": "The --link flag is a legacy feature of Docker. It may eventually be removed."
        },
        "logDriver": {
          "type": "string",
          "description": "The logging driver to use for the container.\n"
        },
        "logOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Key/value pairs to use as options for the logging driver.\n"
        },
        "logs": {
          "type": "boolean",
          "description": "Save the container logs (`attach` must be enabled). Defaults to `false`.\n"
        },
        "maxRetryCount": {
          "type": "integer",
          "description": "The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.\n"
        },
        "memory": {
          "type": "integer",
          "description": "The memory limit for the container in MBs.\n"
        },
        "memorySwap": {
          "type": "integer",
          "description": "The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform\napply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.\n"
        },
        "mounts": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerMount:ContainerMount"
          },
          "description": "Specification for mounts to be added to containers created as part of the service.\n"
        },
        "mustRun": {
          "type": "boolean",
          "description": "If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform\nassumes it is successful. Defaults to `true`.\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the container.\n"
        },
        "networkAliases": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Set an alias for the container in all specified networks\n",
          "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
        },
        "networkMode": {
          "type": "string",
          "description": "Network mode of the container.\n"
        },
        "networks": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "ID of the networks in which the container is.\n",
          "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
        },
        "networksAdvanced": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerNetworksAdvanced:ContainerNetworksAdvanced"
          },
          "description": "The networks the container is attached to\n"
        },
        "pidMode": {
          "type": "string",
          "description": "he PID (Process) Namespace mode for the container. Either `container:\u003cname|id\u003e` or `host`.\n"
        },
        "ports": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerPort:ContainerPort"
          },
          "description": "Publish a container's port(s) to the host.\n"
        },
        "privileged": {
          "type": "boolean",
          "description": "If `true`, the container runs in privileged mode.\n"
        },
        "publishAllPorts": {
          "type": "boolean",
          "description": "Publish all ports of the container.\n"
        },
        "readOnly": {
          "type": "boolean",
          "description": "If `true`, the container will be started as readonly. Defaults to `false`.\n"
        },
        "removeVolumes": {
          "type": "boolean",
          "description": "If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.\n"
        },
        "restart": {
          "type": "string",
          "description": "The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.\n"
        },
        "rm": {
          "type": "boolean",
          "description": "If `true`, then the container will be automatically removed when it exits. Defaults to `false`.\n"
        },
        "runtime": {
          "type": "string",
          "description": "Runtime to use for the container.\n"
        },
        "securityOpts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.\n"
        },
        "shmSize": {
          "type": "integer",
          "description": "Size of `/dev/shm` in MBs.\n"
        },
        "start": {
          "type": "boolean",
          "description": "If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.\n"
        },
        "stdinOpen": {
          "type": "boolean",
          "description": "If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.\n"
        },
        "stopSignal": {
          "type": "string",
          "description": "Signal to stop a container (default `SIGTERM`).\n"
        },
        "stopTimeout": {
          "type": "integer",
          "description": "Timeout (in seconds) to stop a container.\n"
        },
        "storageOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Key/value pairs for the storage driver options, e.g. `size`: `120G`\n"
        },
        "sysctls": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of kernel parameters (sysctls) to set in the container.\n"
        },
        "tmpfs": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.\n"
        },
        "tty": {
          "type": "boolean",
          "description": "If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.\n"
        },
        "ulimits": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerUlimit:ContainerUlimit"
          },
          "description": "Ulimit options to add.\n"
        },
        "uploads": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerUpload:ContainerUpload"
          },
          "description": "Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.\n"
        },
        "user": {
          "type": "string",
          "description": "User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.\n"
        },
        "usernsMode": {
          "type": "string",
          "description": "Sets the usernamespace mode for the container when usernamespace remapping option is enabled.\n"
        },
        "volumes": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FContainerVolume:ContainerVolume"
          },
          "description": "Spec for mounting volumes in the container.\n"
        },
        "workingDir": {
          "type": "string",
          "description": "The working directory for commands to run in.\n"
        }
      },
      "requiredInputs": [
        "image"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Container resources.\n",
        "properties": {
          "attach": {
            "type": "boolean",
            "description": "If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.\n"
          },
          "bridge": {
            "type": "string",
            "description": "The network bridge of the container as read from its NetworkSettings.\n"
          },
          "capabilities": {
            "$ref": "#/types/docker:index%2FContainerCapabilities:ContainerCapabilities",
            "description": "Add or drop certrain linux capabilities.\n"
          },
          "command": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[\"/usr/bin/myprogram\",\"-\",\"baz.con\"]`.\n"
          },
          "containerLogs": {
            "type": "string",
            "description": "The logs of the container if its execution is done (`attach` must be disabled).\n"
          },
          "cpuSet": {
            "type": "string",
            "description": "A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.\n"
          },
          "cpuShares": {
            "type": "integer",
            "description": "CPU shares (relative weight) for the container.\n"
          },
          "destroyGraceSeconds": {
            "type": "integer",
            "description": "If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.\n"
          },
          "devices": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FContainerDevice:ContainerDevice"
            },
            "description": "Bind devices to the container.\n"
          },
          "dns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DNS servers to use.\n"
          },
          "dnsOpts": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.\n"
          },
          "dnsSearches": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DNS search domains that are used when bare unqualified hostnames are used inside of the container.\n"
          },
          "domainname": {
            "type": "string",
            "description": "Domain name of the container.\n"
          },
          "entrypoints": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `\"/usr/bin/myprogra\"]`.\n"
          },
          "envs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
          },
          "exitCode": {
            "type": "integer",
            "description": "The exit code of the container if its execution is done (`must_run` must be disabled).\n"
          },
          "gateway": {
            "type": "string",
            "description": "The network gateway of the container.\n",
            "deprecationMessage": "Use `network_data` instead. The network gateway of the container as read from its NetworkSettings."
          },
          "gpus": {
            "type": "string",
            "description": "GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.\n"
          },
          "groupAdds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Additional groups for the container user\n"
          },
          "healthcheck": {
            "$ref": "#/types/docker:index%2FContainerHealthcheck:ContainerHealthcheck",
            "description": "A test to perform to check that the container is healthy\n"
          },
          "hostname": {
            "type": "string",
            "description": "Hostname of the container.\n"
          },
          "hosts": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FContainerHost:ContainerHost"
            },
            "description": "Additional hosts to add to the container.\n"
          },
          "image": {
            "type": "string",
            "description": "The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.\n"
          },
          "init": {
            "type": "boolean",
            "description": "Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.\n"
          },
          "ipAddress": {
            "type": "string",
            "description": "The IP address of the container.\n",
            "deprecationMessage": "Use `network_data` instead. The IP address of the container's first network it."
          },
          "ipPrefixLength": {
            "type": "integer",
            "description": "The IP prefix length of the container.\n",
            "deprecationMessage": "Use `network_data` instead. The IP prefix length of the container as read from its NetworkSettings."
          },
          "ipcMode": {
            "type": "string",
            "description": "IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:\u003cname|id\u003e` or `host`.\n"
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FContainerLabel:ContainerLabel"
            },
            "description": "User-defined key/value metadata\n"
          },
          "links": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Set of links for link based connectivity between containers that are running on the same host.\n",
            "deprecationMessage": "The --link flag is a legacy feature of Docker. It may eventually be removed."
          },
          "logDriver": {
            "type": "string",
            "description": "The logging driver to use for the container.\n"
          },
          "logOpts": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "Key/value pairs to use as options for the logging driver.\n"
          },
          "logs": {
            "type": "boolean",
            "description": "Save the container logs (`attach` must be enabled). Defaults to `false`.\n"
          },
          "maxRetryCount": {
            "type": "integer",
            "description": "The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.\n"
          },
          "memory": {
            "type": "integer",
            "description": "The memory limit for the container in MBs.\n"
          },
          "memorySwap": {
            "type": "integer",
            "description": "The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform\napply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.\n"
          },
          "mounts": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FContainerMount:ContainerMount"
            },
            "description": "Specification for mounts to be added to containers created as part of the service.\n"
          },
          "mustRun": {
            "type": "boolean",
            "description": "If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform\nassumes it is successful. Defaults to `true`.\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the container.\n"
          },
          "networkAliases": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Set an alias for the container in all specified networks\n",
            "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
          },
          "networkDatas": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FContainerNetworkData:ContainerNetworkData"
            },
            "description": "The data of the networks the container is connected to.\n"
          },
          "networkMode": {
            "type": "string",
            "description": "Network mode of the container.\n"
          },
          "networks": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "ID of the networks in which the container is.\n",
            "deprecationMessage": "Use networks_advanced instead. Will be removed in v3.0.0"
          },
          "networksAdvanced": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FContainerNetworksAdvanced:ContainerNetworksAdvanced"
            },
            "description": "The networks the container is attached to\n"
          },
          "pidMode": {
            "type": "string",
            "description": "he PID (Process) Namespace mode for the container. Either `container:\u003cname|id\u003e` or `host`.\n"
          },
          "ports": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FContainerPort:ContainerPort"
            },
            "description": "Publish a container's port(s) to the host.\n"
          },
          "privileged": {
            "type": "boolean",
            "description": "If `true`, the container runs in privileged mode.\n"
          },
          "publishAllPorts": {
            "type": "boolean",
            "description": "Publish all ports of the container.\n"
          },
          "readOnly": {
            "type": "boolean",
            "description": "If `true`, the container will be started as readonly. Defaults to `false`.\n"
          },
          "removeVolumes": {
            "type": "boolean",
            "description": "If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.\n"
          },
          "restart": {
            "type": "string",
            "description": "The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.\n"
          },
          "rm": {
            "type": "boolean",
            "description": "If `true`, then the container will be automatically removed when it exits. Defaults to `false`.\n"
          },
          "runtime": {
            "type": "string",
            "description": "Runtime to use for the container.\n"
          },
          "securityOpts": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.\n"
          },
          "shmSize": {
            "type": "integer",
            "description": "Size of `/dev/shm` in MBs.\n"
          },
          "start": {
            "type": "boolean",
            "description": "If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.\n"
          },
          "stdinOpen": {
            "type": "boolean",
            "description": "If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.\n"
          },
          "stopSignal": {
            "type": "string",
            "description": "Signal to stop a container (default `SIGTERM`).\n"
          },
          "stopTimeout": {
            "type": "integer",
            "description": "Timeout (in seconds) to stop a container.\n"
          },
          "storageOpts": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "Key/value pairs for the storage driver options, e.g. `size`: `120G`\n"
          },
          "sysctls": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "A map of kernel parameters (sysctls) to set in the container.\n"
          },
          "tmpfs": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.\n"
          },
          "tty": {
            "type": "boolean",
            "description": "If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.\n"
          },
          "ulimits": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FContainerUlimit:ContainerUlimit"
            },
            "description": "Ulimit options to add.\n"
          },
          "uploads": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FContainerUpload:ContainerUpload"
            },
            "description": "Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.\n"
          },
          "user": {
            "type": "string",
            "description": "User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.\n"
          },
          "usernsMode": {
            "type": "string",
            "description": "Sets the usernamespace mode for the container when usernamespace remapping option is enabled.\n"
          },
          "volumes": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FContainerVolume:ContainerVolume"
            },
            "description": "Spec for mounting volumes in the container.\n"
          },
          "workingDir": {
            "type": "string",
            "description": "The working directory for commands to run in.\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/network:Network": {
      "description": "\u003c!-- Bug: Type and Name are switched --\u003e\n`docker.Network` provides a docker network resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst privateNetwork = new docker.Network(\"private_network\", {});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nprivate_network = docker.Network(\"privateNetwork\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var privateNetwork = new Docker.Network(\"privateNetwork\");\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewNetwork(ctx, \"privateNetwork\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.Network;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var privateNetwork = new Network(\"privateNetwork\");\n\n    }\n}\n```\n```yaml\nresources:\n  privateNetwork:\n    type: docker:Network\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n### Example Assuming you created a `network` as follows #!/bin/bash docker network create foo # prints the long ID 87b57a9b91ecab2db2a6dbf38df74c67d7c7108cbe479d6576574ec2cd8c2d73 you provide the definition for the resource as follows terraform resource \"docker_network\" \"foo\" {\n\n name = \"foo\" } then the import command is as follows #!/bin/bash\n\n```sh\n $ pulumi import docker:index/network:Network foo 87b57a9b91ecab2db2a6dbf38df74c67d7c7108cbe479d6576574ec2cd8c2d73\n```\n\n ",
      "properties": {
        "attachable": {
          "type": "boolean",
          "description": "Enable manual container attachment to the network.\n"
        },
        "checkDuplicate": {
          "type": "boolean",
          "description": "Requests daemon to check for networks with same name.\n"
        },
        "driver": {
          "type": "string",
          "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network docs](https://docs.docker.com/network/#network-drivers) for more details.\n"
        },
        "ingress": {
          "type": "boolean",
          "description": "Create swarm routing-mesh network. Defaults to `false`.\n"
        },
        "internal": {
          "type": "boolean",
          "description": "Whether the network is internal.\n"
        },
        "ipamConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FNetworkIpamConfig:NetworkIpamConfig"
          },
          "description": "The IPAM configuration options\n"
        },
        "ipamDriver": {
          "type": "string",
          "description": "Driver used by the custom IP scheme of the network. Defaults to `default`\n"
        },
        "ipv6": {
          "type": "boolean",
          "description": "Enable IPv6 networking. Defaults to `false`.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FNetworkLabel:NetworkLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker network.\n"
        },
        "options": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Only available with bridge networks. See [bridge options docs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n"
        },
        "scope": {
          "type": "string",
          "description": "Scope of the network. One of `swarm`, `global`, or `local`.\n"
        }
      },
      "type": "object",
      "required": [
        "driver",
        "internal",
        "ipamConfigs",
        "name",
        "options",
        "scope"
      ],
      "inputProperties": {
        "attachable": {
          "type": "boolean",
          "description": "Enable manual container attachment to the network.\n"
        },
        "checkDuplicate": {
          "type": "boolean",
          "description": "Requests daemon to check for networks with same name.\n"
        },
        "driver": {
          "type": "string",
          "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network docs](https://docs.docker.com/network/#network-drivers) for more details.\n"
        },
        "ingress": {
          "type": "boolean",
          "description": "Create swarm routing-mesh network. Defaults to `false`.\n"
        },
        "internal": {
          "type": "boolean",
          "description": "Whether the network is internal.\n"
        },
        "ipamConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FNetworkIpamConfig:NetworkIpamConfig"
          },
          "description": "The IPAM configuration options\n"
        },
        "ipamDriver": {
          "type": "string",
          "description": "Driver used by the custom IP scheme of the network. Defaults to `default`\n"
        },
        "ipv6": {
          "type": "boolean",
          "description": "Enable IPv6 networking. Defaults to `false`.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FNetworkLabel:NetworkLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker network.\n"
        },
        "options": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Only available with bridge networks. See [bridge options docs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n"
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Network resources.\n",
        "properties": {
          "attachable": {
            "type": "boolean",
            "description": "Enable manual container attachment to the network.\n"
          },
          "checkDuplicate": {
            "type": "boolean",
            "description": "Requests daemon to check for networks with same name.\n"
          },
          "driver": {
            "type": "string",
            "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network docs](https://docs.docker.com/network/#network-drivers) for more details.\n"
          },
          "ingress": {
            "type": "boolean",
            "description": "Create swarm routing-mesh network. Defaults to `false`.\n"
          },
          "internal": {
            "type": "boolean",
            "description": "Whether the network is internal.\n"
          },
          "ipamConfigs": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FNetworkIpamConfig:NetworkIpamConfig"
            },
            "description": "The IPAM configuration options\n"
          },
          "ipamDriver": {
            "type": "string",
            "description": "Driver used by the custom IP scheme of the network. Defaults to `default`\n"
          },
          "ipv6": {
            "type": "boolean",
            "description": "Enable IPv6 networking. Defaults to `false`.\n"
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FNetworkLabel:NetworkLabel"
            },
            "description": "User-defined key/value metadata\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker network.\n"
          },
          "options": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "Only available with bridge networks. See [bridge options docs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n"
          },
          "scope": {
            "type": "string",
            "description": "Scope of the network. One of `swarm`, `global`, or `local`.\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/plugin:Plugin": {
      "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nManages the lifecycle of a Docker plugin.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst sample_volume_plugin = new docker.Plugin(\"sample-volume-plugin\", {\n    alias: \"sample-volume-plugin\",\n    enableTimeout: 60,\n    enabled: false,\n    envs: [\"DEBUG=1\"],\n    forceDestroy: true,\n    forceDisable: true,\n    grantAllPermissions: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nsample_volume_plugin = docker.Plugin(\"sample-volume-plugin\",\n    alias=\"sample-volume-plugin\",\n    enable_timeout=60,\n    enabled=False,\n    envs=[\"DEBUG=1\"],\n    force_destroy=True,\n    force_disable=True,\n    grant_all_permissions=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sample_volume_plugin = new Docker.Plugin(\"sample-volume-plugin\", new()\n    {\n        Alias = \"sample-volume-plugin\",\n        EnableTimeout = 60,\n        Enabled = false,\n        Envs = new[]\n        {\n            \"DEBUG=1\",\n        },\n        ForceDestroy = true,\n        ForceDisable = true,\n        GrantAllPermissions = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewPlugin(ctx, \"sample-volume-plugin\", \u0026docker.PluginArgs{\n\t\t\tAlias:         pulumi.String(\"sample-volume-plugin\"),\n\t\t\tEnableTimeout: pulumi.Int(60),\n\t\t\tEnabled:       pulumi.Bool(false),\n\t\t\tEnvs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"DEBUG=1\"),\n\t\t\t},\n\t\t\tForceDestroy:        pulumi.Bool(true),\n\t\t\tForceDisable:        pulumi.Bool(true),\n\t\t\tGrantAllPermissions: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.Plugin;\nimport com.pulumi.docker.PluginArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var sample_volume_plugin = new Plugin(\"sample-volume-plugin\", PluginArgs.builder()        \n            .alias(\"sample-volume-plugin\")\n            .enableTimeout(60)\n            .enabled(false)\n            .envs(\"DEBUG=1\")\n            .forceDestroy(true)\n            .forceDisable(true)\n            .grantAllPermissions(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  sample-volume-plugin:\n    type: docker:Plugin\n    properties:\n      alias: sample-volume-plugin\n      enableTimeout: 60\n      enabled: false\n      envs:\n        - DEBUG=1\n      forceDestroy: true\n      forceDisable: true\n      grantAllPermissions: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#!/bin/bash\n\n```sh\n $ pulumi import docker:index/plugin:Plugin sample-volume-plugin \"$(docker plugin inspect -f {{.ID}} tiborvass/sample-volume-plugin:latest)\"\n```\n\n ",
      "properties": {
        "alias": {
          "type": "string",
          "description": "Docker Plugin alias\n"
        },
        "enableTimeout": {
          "type": "integer",
          "description": "HTTP client timeout to enable the plugin\n"
        },
        "enabled": {
          "type": "boolean",
          "description": "If `true` the plugin is enabled. Defaults to `true`\n"
        },
        "envs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
        },
        "forceDestroy": {
          "type": "boolean",
          "description": "If true, then the plugin is destroyed forcibly\n"
        },
        "forceDisable": {
          "type": "boolean",
          "description": "If true, then the plugin is disabled forcibly\n"
        },
        "grantAllPermissions": {
          "type": "boolean",
          "description": "If true, grant all permissions necessary to run the plugin\n"
        },
        "grantPermissions": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FPluginGrantPermission:PluginGrantPermission"
          },
          "description": "Grant specific permissions only\n"
        },
        "name": {
          "type": "string",
          "description": "Docker Plugin name\n"
        },
        "pluginReference": {
          "type": "string",
          "description": "Docker Plugin Reference\n"
        }
      },
      "type": "object",
      "required": [
        "alias",
        "envs",
        "name",
        "pluginReference"
      ],
      "inputProperties": {
        "alias": {
          "type": "string",
          "description": "Docker Plugin alias\n"
        },
        "enableTimeout": {
          "type": "integer",
          "description": "HTTP client timeout to enable the plugin\n"
        },
        "enabled": {
          "type": "boolean",
          "description": "If `true` the plugin is enabled. Defaults to `true`\n"
        },
        "envs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
        },
        "forceDestroy": {
          "type": "boolean",
          "description": "If true, then the plugin is destroyed forcibly\n"
        },
        "forceDisable": {
          "type": "boolean",
          "description": "If true, then the plugin is disabled forcibly\n"
        },
        "grantAllPermissions": {
          "type": "boolean",
          "description": "If true, grant all permissions necessary to run the plugin\n"
        },
        "grantPermissions": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FPluginGrantPermission:PluginGrantPermission"
          },
          "description": "Grant specific permissions only\n"
        },
        "name": {
          "type": "string",
          "description": "Docker Plugin name\n"
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Plugin resources.\n",
        "properties": {
          "alias": {
            "type": "string",
            "description": "Docker Plugin alias\n"
          },
          "enableTimeout": {
            "type": "integer",
            "description": "HTTP client timeout to enable the plugin\n"
          },
          "enabled": {
            "type": "boolean",
            "description": "If `true` the plugin is enabled. Defaults to `true`\n"
          },
          "envs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
          },
          "forceDestroy": {
            "type": "boolean",
            "description": "If true, then the plugin is destroyed forcibly\n"
          },
          "forceDisable": {
            "type": "boolean",
            "description": "If true, then the plugin is disabled forcibly\n"
          },
          "grantAllPermissions": {
            "type": "boolean",
            "description": "If true, grant all permissions necessary to run the plugin\n"
          },
          "grantPermissions": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FPluginGrantPermission:PluginGrantPermission"
            },
            "description": "Grant specific permissions only\n"
          },
          "name": {
            "type": "string",
            "description": "Docker Plugin name\n"
          },
          "pluginReference": {
            "type": "string",
            "description": "Docker Plugin Reference\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/registryImage:RegistryImage": {
      "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nManages the lifecycle of docker image/tag in a registry means it can store one or more version of specific docker images and identified by their tags.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nTo be able to update an image itself when an updated image arrives.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\nimport * as process from \"process\";\n\nconst helloworld = new docker.RegistryImage(\"helloworld\", {\n    build: {\n        context: `${process.cwd()}/absolutePathToContextFolder`,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nhelloworld = docker.RegistryImage(\"helloworld\", build=docker.RegistryImageBuildArgs(\n    context=f\"{path['cwd']}/absolutePathToContextFolder\",\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var helloworld = new Docker.RegistryImage(\"helloworld\", new()\n    {\n        Build = new Docker.Inputs.RegistryImageBuildArgs\n        {\n            Context = $\"{path.Cwd}/absolutePathToContextFolder\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewRegistryImage(ctx, \"helloworld\", \u0026docker.RegistryImageArgs{\n\t\t\tBuild: \u0026RegistryImageBuildArgs{\n\t\t\t\tContext: pulumi.String(fmt.Sprintf(\"%v/absolutePathToContextFolder\", path.Cwd)),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.RegistryImage;\nimport com.pulumi.docker.RegistryImageArgs;\nimport com.pulumi.docker.inputs.RegistryImageBuildArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var helloworld = new RegistryImage(\"helloworld\", RegistryImageArgs.builder()        \n            .build(RegistryImageBuildArgs.builder()\n                .context(String.format(\"%s/absolutePathToContextFolder\", path.cwd()))\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  helloworld:\n    type: docker:RegistryImage\n    properties:\n      build:\n        context: ${path.cwd}/absolutePathToContextFolder\n```\n{{% /example %}}\n{{% /examples %}}",
      "properties": {
        "build": {
          "$ref": "#/types/docker:index%2FRegistryImageBuild:RegistryImageBuild",
          "description": "Definition for building the image\n"
        },
        "insecureSkipVerify": {
          "type": "boolean",
          "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
        },
        "keepRemotely": {
          "type": "boolean",
          "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker registry on destroy operation. Defaults to `false`\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker image.\n"
        },
        "sha256Digest": {
          "type": "string",
          "description": "The sha256 digest of the image.\n"
        }
      },
      "type": "object",
      "required": [
        "name",
        "sha256Digest"
      ],
      "inputProperties": {
        "build": {
          "$ref": "#/types/docker:index%2FRegistryImageBuild:RegistryImageBuild",
          "description": "Definition for building the image\n"
        },
        "insecureSkipVerify": {
          "type": "boolean",
          "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
        },
        "keepRemotely": {
          "type": "boolean",
          "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker registry on destroy operation. Defaults to `false`\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker image.\n"
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering RegistryImage resources.\n",
        "properties": {
          "build": {
            "$ref": "#/types/docker:index%2FRegistryImageBuild:RegistryImageBuild",
            "description": "Definition for building the image\n"
          },
          "insecureSkipVerify": {
            "type": "boolean",
            "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
          },
          "keepRemotely": {
            "type": "boolean",
            "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker registry on destroy operation. Defaults to `false`\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker image.\n"
          },
          "sha256Digest": {
            "type": "string",
            "description": "The sha256 digest of the image.\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/remoteImage:RemoteImage": {
      "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nPulls a Docker image to a given Docker host from a Docker Registry.\n This resource will *not* pull new layers of the image automatically unless used in conjunction with docker.RegistryImage data source to update the `pull_triggers` field.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic\n\nFinds and downloads the latest `ubuntu:precise` image but does not check\nfor further updates of the image\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ubuntu = new docker.RemoteImage(\"ubuntu\", {\n    name: \"ubuntu:precise\",\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nubuntu = docker.RemoteImage(\"ubuntu\", name=\"ubuntu:precise\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntu = new Docker.RemoteImage(\"ubuntu\", new()\n    {\n        Name = \"ubuntu:precise\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewRemoteImage(ctx, \"ubuntu\", \u0026docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(\"ubuntu:precise\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.RemoteImage;\nimport com.pulumi.docker.RemoteImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ubuntu = new RemoteImage(\"ubuntu\", RemoteImageArgs.builder()        \n            .name(\"ubuntu:precise\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntu:\n    type: docker:RemoteImage\n    properties:\n      name: ubuntu:precise\n```\n{{% /example %}}\n{{% example %}}\n### Dynamic updates\n\nTo be able to update an image dynamically when the `sha256` sum changes,\nyou need to use it in combination with `docker.RegistryImage` as follows:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ubuntuRegistryImage = docker.getRegistryImage({\n    name: \"ubuntu:precise\",\n});\nconst ubuntuRemoteImage = new docker.RemoteImage(\"ubuntuRemoteImage\", {\n    name: ubuntuRegistryImage.then(ubuntuRegistryImage =\u003e ubuntuRegistryImage.name),\n    pullTriggers: [ubuntuRegistryImage.then(ubuntuRegistryImage =\u003e ubuntuRegistryImage.sha256Digest)],\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nubuntu_registry_image = docker.get_registry_image(name=\"ubuntu:precise\")\nubuntu_remote_image = docker.RemoteImage(\"ubuntuRemoteImage\",\n    name=ubuntu_registry_image.name,\n    pull_triggers=[ubuntu_registry_image.sha256_digest])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntuRegistryImage = Docker.GetRegistryImage.Invoke(new()\n    {\n        Name = \"ubuntu:precise\",\n    });\n\n    var ubuntuRemoteImage = new Docker.RemoteImage(\"ubuntuRemoteImage\", new()\n    {\n        Name = ubuntuRegistryImage.Apply(getRegistryImageResult =\u003e getRegistryImageResult.Name),\n        PullTriggers = new[]\n        {\n            ubuntuRegistryImage.Apply(getRegistryImageResult =\u003e getRegistryImageResult.Sha256Digest),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tubuntuRegistryImage, err := docker.LookupRegistryImage(ctx, \u0026GetRegistryImageArgs{\n\t\t\tName: \"ubuntu:precise\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.NewRemoteImage(ctx, \"ubuntuRemoteImage\", \u0026docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(ubuntuRegistryImage.Name),\n\t\t\tPullTriggers: pulumi.StringArray{\n\t\t\t\tpulumi.String(ubuntuRegistryImage.Sha256Digest),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.DockerFunctions;\nimport com.pulumi.docker.inputs.GetRegistryImageArgs;\nimport com.pulumi.docker.RemoteImage;\nimport com.pulumi.docker.RemoteImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var ubuntuRegistryImage = DockerFunctions.getRegistryImage(GetRegistryImageArgs.builder()\n            .name(\"ubuntu:precise\")\n            .build());\n\n        var ubuntuRemoteImage = new RemoteImage(\"ubuntuRemoteImage\", RemoteImageArgs.builder()        \n            .name(ubuntuRegistryImage.applyValue(getRegistryImageResult -\u003e getRegistryImageResult.name()))\n            .pullTriggers(ubuntuRegistryImage.applyValue(getRegistryImageResult -\u003e getRegistryImageResult.sha256Digest()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntuRemoteImage:\n    type: docker:RemoteImage\n    properties:\n      name: ${ubuntuRegistryImage.name}\n      pullTriggers:\n        - ${ubuntuRegistryImage.sha256Digest}\nvariables:\n  ubuntuRegistryImage:\n    Fn::Invoke:\n      Function: docker:getRegistryImage\n      Arguments:\n        name: ubuntu:precise\n```\n{{% /example %}}\n{{% /examples %}}",
      "properties": {
        "build": {
          "$ref": "#/types/docker:index%2FRemoteImageBuild:RemoteImageBuild",
          "description": "Configuration to build an image. Please see [docker build command reference](https://docs.docker.com/engine/reference/commandline/build/#options) too.\n"
        },
        "forceRemove": {
          "type": "boolean",
          "description": "If true, then the image is removed forcibly when the resource is destroyed.\n"
        },
        "keepLocally": {
          "type": "boolean",
          "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker local storage on destroy operation.\n"
        },
        "latest": {
          "type": "string",
          "description": "The ID of the image in the form of `sha256:\u003chash\u003e` image digest. Do not confuse it with the default `latest` tag.\n",
          "deprecationMessage": "Use repo_digest instead"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker image, including any tags or SHA256 repo digests.\n"
        },
        "output": {
          "type": "string",
          "deprecationMessage": "Is unused and will be removed."
        },
        "pullTrigger": {
          "type": "string",
          "description": "A value which cause an image pull when changed\n",
          "deprecationMessage": "Use field pull_triggers instead"
        },
        "pullTriggers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of values which cause an image pull when changed. This is used to store the image digest from the registry when using the docker*registry*image.\n"
        },
        "repoDigest": {
          "type": "string",
          "description": "The image sha256 digest in the form of `repo[:tag]@sha256:\u003chash\u003e`.\n"
        },
        "triggers": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of arbitrary strings that, when changed, will force the `docker.RemoteImage` resource to be replaced. This can be used to rebuild an image when contents of source code folders change\n"
        }
      },
      "type": "object",
      "required": [
        "latest",
        "name",
        "output",
        "repoDigest"
      ],
      "inputProperties": {
        "build": {
          "$ref": "#/types/docker:index%2FRemoteImageBuild:RemoteImageBuild",
          "description": "Configuration to build an image. Please see [docker build command reference](https://docs.docker.com/engine/reference/commandline/build/#options) too.\n"
        },
        "forceRemove": {
          "type": "boolean",
          "description": "If true, then the image is removed forcibly when the resource is destroyed.\n"
        },
        "keepLocally": {
          "type": "boolean",
          "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker local storage on destroy operation.\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker image, including any tags or SHA256 repo digests.\n"
        },
        "pullTrigger": {
          "type": "string",
          "description": "A value which cause an image pull when changed\n",
          "deprecationMessage": "Use field pull_triggers instead"
        },
        "pullTriggers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of values which cause an image pull when changed. This is used to store the image digest from the registry when using the docker*registry*image.\n"
        },
        "triggers": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of arbitrary strings that, when changed, will force the `docker.RemoteImage` resource to be replaced. This can be used to rebuild an image when contents of source code folders change\n"
        }
      },
      "requiredInputs": [
        "name"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering RemoteImage resources.\n",
        "properties": {
          "build": {
            "$ref": "#/types/docker:index%2FRemoteImageBuild:RemoteImageBuild",
            "description": "Configuration to build an image. Please see [docker build command reference](https://docs.docker.com/engine/reference/commandline/build/#options) too.\n"
          },
          "forceRemove": {
            "type": "boolean",
            "description": "If true, then the image is removed forcibly when the resource is destroyed.\n"
          },
          "keepLocally": {
            "type": "boolean",
            "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker local storage on destroy operation.\n"
          },
          "latest": {
            "type": "string",
            "description": "The ID of the image in the form of `sha256:\u003chash\u003e` image digest. Do not confuse it with the default `latest` tag.\n",
            "deprecationMessage": "Use repo_digest instead"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker image, including any tags or SHA256 repo digests.\n"
          },
          "output": {
            "type": "string",
            "deprecationMessage": "Is unused and will be removed."
          },
          "pullTrigger": {
            "type": "string",
            "description": "A value which cause an image pull when changed\n",
            "deprecationMessage": "Use field pull_triggers instead"
          },
          "pullTriggers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of values which cause an image pull when changed. This is used to store the image digest from the registry when using the docker*registry*image.\n"
          },
          "repoDigest": {
            "type": "string",
            "description": "The image sha256 digest in the form of `repo[:tag]@sha256:\u003chash\u003e`.\n"
          },
          "triggers": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "A map of arbitrary strings that, when changed, will force the `docker.RemoteImage` resource to be replaced. This can be used to rebuild an image when contents of source code folders change\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/secret:Secret": {
      "description": "\n\n\n## Import\n\n#!/bin/bash # Docker secret cannot be imported as the secret data, once set, is never exposed again. ",
      "properties": {
        "data": {
          "type": "string",
          "description": "Base64-url-safe-encoded secret data\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FSecretLabel:SecretLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "name": {
          "type": "string",
          "description": "User-defined name of the secret\n"
        }
      },
      "type": "object",
      "required": [
        "data",
        "name"
      ],
      "inputProperties": {
        "data": {
          "type": "string",
          "description": "Base64-url-safe-encoded secret data\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FSecretLabel:SecretLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "name": {
          "type": "string",
          "description": "User-defined name of the secret\n"
        }
      },
      "requiredInputs": [
        "data"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Secret resources.\n",
        "properties": {
          "data": {
            "type": "string",
            "description": "Base64-url-safe-encoded secret data\n"
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FSecretLabel:SecretLabel"
            },
            "description": "User-defined key/value metadata\n"
          },
          "name": {
            "type": "string",
            "description": "User-defined name of the secret\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/service:Service": {
      "description": "\n\n\n## Import\n\n### Example Assuming you created a `service` as follows #!/bin/bash docker service create --name foo -p 8080:80 nginx # prints th ID 4pcphbxkfn2rffhbhe6czytgi you provide the definition for the resource as follows terraform resource \"docker_service\" \"foo\" {\n\n name = \"foo\"\n\n task_spec {\n\n\n\n container_spec {\n\n\n\n\n\n image = \"nginx\"\n\n\n\n }\n\n }\n\n endpoint_spec {\n\n\n\n ports {\n\n\n\n\n\n target_port\n\n\n\n= \"80\"\n\n\n\n\n\n published_port = \"8080\"\n\n\n\n }\n\n } } then the import command is as follows #!/bin/bash\n\n```sh\n $ pulumi import docker:index/service:Service foo 4pcphbxkfn2rffhbhe6czytgi\n```\n\n ",
      "properties": {
        "auth": {
          "$ref": "#/types/docker:index%2FServiceAuth:ServiceAuth",
          "description": "Configuration for the authentication for pulling the images of the service\n"
        },
        "convergeConfig": {
          "$ref": "#/types/docker:index%2FServiceConvergeConfig:ServiceConvergeConfig",
          "description": "A configuration to ensure that a service converges aka reaches the desired that of all task up and running\n"
        },
        "endpointSpec": {
          "$ref": "#/types/docker:index%2FServiceEndpointSpec:ServiceEndpointSpec",
          "description": "Properties that can be configured to access and load balance a service\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FServiceLabel:ServiceLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "mode": {
          "$ref": "#/types/docker:index%2FServiceMode:ServiceMode",
          "description": "Scheduling mode for the service\n"
        },
        "name": {
          "type": "string",
          "description": "Name of the service\n"
        },
        "rollbackConfig": {
          "$ref": "#/types/docker:index%2FServiceRollbackConfig:ServiceRollbackConfig",
          "description": "Specification for the rollback strategy of the service\n"
        },
        "taskSpec": {
          "$ref": "#/types/docker:index%2FServiceTaskSpec:ServiceTaskSpec",
          "description": "User modifiable task configuration\n"
        },
        "updateConfig": {
          "$ref": "#/types/docker:index%2FServiceUpdateConfig:ServiceUpdateConfig",
          "description": "Specification for the update strategy of the service\n"
        }
      },
      "type": "object",
      "required": [
        "endpointSpec",
        "labels",
        "mode",
        "name",
        "taskSpec"
      ],
      "inputProperties": {
        "auth": {
          "$ref": "#/types/docker:index%2FServiceAuth:ServiceAuth",
          "description": "Configuration for the authentication for pulling the images of the service\n"
        },
        "convergeConfig": {
          "$ref": "#/types/docker:index%2FServiceConvergeConfig:ServiceConvergeConfig",
          "description": "A configuration to ensure that a service converges aka reaches the desired that of all task up and running\n"
        },
        "endpointSpec": {
          "$ref": "#/types/docker:index%2FServiceEndpointSpec:ServiceEndpointSpec",
          "description": "Properties that can be configured to access and load balance a service\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FServiceLabel:ServiceLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "mode": {
          "$ref": "#/types/docker:index%2FServiceMode:ServiceMode",
          "description": "Scheduling mode for the service\n"
        },
        "name": {
          "type": "string",
          "description": "Name of the service\n"
        },
        "rollbackConfig": {
          "$ref": "#/types/docker:index%2FServiceRollbackConfig:ServiceRollbackConfig",
          "description": "Specification for the rollback strategy of the service\n"
        },
        "taskSpec": {
          "$ref": "#/types/docker:index%2FServiceTaskSpec:ServiceTaskSpec",
          "description": "User modifiable task configuration\n"
        },
        "updateConfig": {
          "$ref": "#/types/docker:index%2FServiceUpdateConfig:ServiceUpdateConfig",
          "description": "Specification for the update strategy of the service\n"
        }
      },
      "requiredInputs": [
        "taskSpec"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Service resources.\n",
        "properties": {
          "auth": {
            "$ref": "#/types/docker:index%2FServiceAuth:ServiceAuth",
            "description": "Configuration for the authentication for pulling the images of the service\n"
          },
          "convergeConfig": {
            "$ref": "#/types/docker:index%2FServiceConvergeConfig:ServiceConvergeConfig",
            "description": "A configuration to ensure that a service converges aka reaches the desired that of all task up and running\n"
          },
          "endpointSpec": {
            "$ref": "#/types/docker:index%2FServiceEndpointSpec:ServiceEndpointSpec",
            "description": "Properties that can be configured to access and load balance a service\n"
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FServiceLabel:ServiceLabel"
            },
            "description": "User-defined key/value metadata\n"
          },
          "mode": {
            "$ref": "#/types/docker:index%2FServiceMode:ServiceMode",
            "description": "Scheduling mode for the service\n"
          },
          "name": {
            "type": "string",
            "description": "Name of the service\n"
          },
          "rollbackConfig": {
            "$ref": "#/types/docker:index%2FServiceRollbackConfig:ServiceRollbackConfig",
            "description": "Specification for the rollback strategy of the service\n"
          },
          "taskSpec": {
            "$ref": "#/types/docker:index%2FServiceTaskSpec:ServiceTaskSpec",
            "description": "User modifiable task configuration\n"
          },
          "updateConfig": {
            "$ref": "#/types/docker:index%2FServiceUpdateConfig:ServiceUpdateConfig",
            "description": "Specification for the update strategy of the service\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/serviceConfig:ServiceConfig": {
      "description": "\n\n\n## Import\n\n### Example Assuming you created a `config` as follows #!/bin/bash printf '{\"a\":\"b\"}' | docker config create foo - # prints the id\n\n08c26c477474478d971139f750984775a7f019dbe8a2e7f09d66a187c009e66d you provide the definition for the resource as follows terraform resource \"docker_config\" \"foo\" {\n\n name = \"foo\"\n\n data = base64encode(\"{\\\"a\\\"\\\"b\\\"}\") } then the import command is as follows #!/bin/bash\n\n```sh\n $ pulumi import docker:index/serviceConfig:ServiceConfig foo 08c26c477474478d971139f750984775a7f019dbe8a2e7f09d66a187c009e66d\n```\n\n ",
      "properties": {
        "data": {
          "type": "string",
          "description": "Base64-url-safe-encoded config data\n"
        },
        "name": {
          "type": "string",
          "description": "User-defined name of the config\n"
        }
      },
      "type": "object",
      "required": [
        "data",
        "name"
      ],
      "inputProperties": {
        "data": {
          "type": "string",
          "description": "Base64-url-safe-encoded config data\n"
        },
        "name": {
          "type": "string",
          "description": "User-defined name of the config\n"
        }
      },
      "requiredInputs": [
        "data"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering ServiceConfig resources.\n",
        "properties": {
          "data": {
            "type": "string",
            "description": "Base64-url-safe-encoded config data\n"
          },
          "name": {
            "type": "string",
            "description": "User-defined name of the config\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/tag:Tag": {
      "description": "Creates a docker tag. It has the exact same functionality as the `docker tag` command. Deleting the resource will neither delete the source nor target images. The source image must exist on the machine running the docker daemon.\n",
      "properties": {
        "sourceImage": {
          "type": "string",
          "description": "Name of the source image.\n"
        },
        "sourceImageId": {
          "type": "string",
          "description": "ImageID of the source image in the format of `sha256:\u003c\u003cID\u003e\u003e`\n"
        },
        "targetImage": {
          "type": "string",
          "description": "Name of the target image.\n"
        }
      },
      "type": "object",
      "required": [
        "sourceImage",
        "sourceImageId",
        "targetImage"
      ],
      "inputProperties": {
        "sourceImage": {
          "type": "string",
          "description": "Name of the source image.\n"
        },
        "targetImage": {
          "type": "string",
          "description": "Name of the target image.\n"
        }
      },
      "requiredInputs": [
        "sourceImage",
        "targetImage"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Tag resources.\n",
        "properties": {
          "sourceImage": {
            "type": "string",
            "description": "Name of the source image.\n"
          },
          "sourceImageId": {
            "type": "string",
            "description": "ImageID of the source image in the format of `sha256:\u003c\u003cID\u003e\u003e`\n"
          },
          "targetImage": {
            "type": "string",
            "description": "Name of the target image.\n"
          }
        },
        "type": "object"
      }
    },
    "docker:index/volume:Volume": {
      "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nCreates and destroys a volume in Docker. This can be used alongside docker.Container to prepare volumes that can be shared across containers.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst sharedVolume = new docker.Volume(\"shared_volume\", {});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nshared_volume = docker.Volume(\"sharedVolume\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sharedVolume = new Docker.Volume(\"sharedVolume\");\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewVolume(ctx, \"sharedVolume\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.Volume;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var sharedVolume = new Volume(\"sharedVolume\");\n\n    }\n}\n```\n```yaml\nresources:\n  sharedVolume:\n    type: docker:Volume\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n### Example Assuming you created a `volume` as follows #!/bin/bash docker volume create # prints the long ID 524b0457aa2a87dd2b75c74c3e4e53f406974249e63ab3ed9bf21e5644f9dc7d you provide the definition for the resource as follows terraform resource \"docker_volume\" \"foo\" {\n\n name = \"524b0457aa2a87dd2b75c74c3e4e53f406974249e63ab3ed9bf21e5644f9dc7d\" } then the import command is as follows #!/bin/bash\n\n```sh\n $ pulumi import docker:index/volume:Volume foo 524b0457aa2a87dd2b75c74c3e4e53f406974249e63ab3ed9bf21e5644f9dc7d\n```\n\n ",
      "properties": {
        "driver": {
          "type": "string",
          "description": "Driver type for the volume. Defaults to `local`.\n"
        },
        "driverOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Options specific to the driver.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FVolumeLabel:VolumeLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "mountpoint": {
          "type": "string",
          "description": "The mountpoint of the volume.\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker volume (will be generated if not provided).\n"
        }
      },
      "type": "object",
      "required": [
        "driver",
        "mountpoint",
        "name"
      ],
      "inputProperties": {
        "driver": {
          "type": "string",
          "description": "Driver type for the volume. Defaults to `local`.\n"
        },
        "driverOpts": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Options specific to the driver.\n"
        },
        "labels": {
          "type": "array",
          "items": {
            "$ref": "#/types/docker:index%2FVolumeLabel:VolumeLabel"
          },
          "description": "User-defined key/value metadata\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the Docker volume (will be generated if not provided).\n"
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Volume resources.\n",
        "properties": {
          "driver": {
            "type": "string",
            "description": "Driver type for the volume. Defaults to `local`.\n"
          },
          "driverOpts": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "Options specific to the driver.\n"
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FVolumeLabel:VolumeLabel"
            },
            "description": "User-defined key/value metadata\n"
          },
          "mountpoint": {
            "type": "string",
            "description": "The mountpoint of the volume.\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker volume (will be generated if not provided).\n"
          }
        },
        "type": "object"
      }
    }
  },
  "functions": {
    "docker:index/getNetwork:getNetwork": {
      "description": "`docker.Network` provides details about a specific Docker Network.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst main = pulumi.output(docker.getNetwork({\n    name: \"main\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nmain = docker.get_network(name=\"main\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Docker.GetNetwork.Invoke(new()\n    {\n        Name = \"main\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.LookupNetwork(ctx, \u0026GetNetworkArgs{\n\t\t\tName: \"main\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.DockerFunctions;\nimport com.pulumi.docker.inputs.GetNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = DockerFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"main\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    Fn::Invoke:\n      Function: docker:getNetwork\n      Arguments:\n        name: main\n```\n{{% /example %}}\n{{% /examples %}}",
      "inputs": {
        "description": "A collection of arguments for invoking getNetwork.\n",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the Docker network.\n"
          }
        },
        "type": "object",
        "required": [
          "name"
        ]
      },
      "outputs": {
        "description": "A collection of values returned by getNetwork.\n",
        "properties": {
          "driver": {
            "type": "string",
            "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network docs](https://docs.docker.com/network/#network-drivers) for more details.\n"
          },
          "id": {
            "type": "string",
            "description": "The ID of this resource.\n"
          },
          "internal": {
            "type": "boolean",
            "description": "If `true`, the network is internal.\n"
          },
          "ipamConfigs": {
            "type": "array",
            "items": {
              "$ref": "#/types/docker:index%2FgetNetworkIpamConfig:getNetworkIpamConfig"
            },
            "description": "The IPAM configuration options\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker network.\n"
          },
          "options": {
            "type": "object",
            "additionalProperties": {
              "$ref": "pulumi.json#/Any"
            },
            "description": "Only available with bridge networks. See [bridge options docs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n"
          },
          "scope": {
            "type": "string",
            "description": "Scope of the network. One of `swarm`, `global`, or `local`.\n"
          }
        },
        "type": "object",
        "required": [
          "driver",
          "id",
          "internal",
          "ipamConfigs",
          "name",
          "options",
          "scope"
        ]
      }
    },
    "docker:index/getPlugin:getPlugin": {
      "description": "Reads the local Docker plugin. The plugin must be installed locally.\n\n{{% examples %}}\n## Example Usage\n\n### With alias\ndata \"docker.Plugin\" \"by_alias\" {\n  alias = \"sample-volume-plugin:latest\"\n}\n{{% /examples %}}",
      "inputs": {
        "description": "A collection of arguments for invoking getPlugin.\n",
        "properties": {
          "alias": {
            "type": "string",
            "description": "The alias of the Docker plugin. If the tag is omitted, `:latest` is complemented to the attribute value.\n"
          },
          "id": {
            "type": "string",
            "description": "The ID of the plugin, which has precedence over the `alias` of both are given\n"
          }
        },
        "type": "object"
      },
      "outputs": {
        "description": "A collection of values returned by getPlugin.\n",
        "properties": {
          "alias": {
            "type": "string",
            "description": "The alias of the Docker plugin. If the tag is omitted, `:latest` is complemented to the attribute value.\n"
          },
          "enabled": {
            "type": "boolean",
            "description": "If `true` the plugin is enabled\n"
          },
          "envs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
          },
          "grantAllPermissions": {
            "type": "boolean",
            "description": "If true, grant all permissions necessary to run the plugin\n"
          },
          "id": {
            "type": "string",
            "description": "The ID of the plugin, which has precedence over the `alias` of both are given\n"
          },
          "name": {
            "type": "string",
            "description": "The plugin name. If the tag is omitted, `:latest` is complemented to the attribute value.\n"
          },
          "pluginReference": {
            "type": "string",
            "description": "The Docker Plugin Reference\n"
          }
        },
        "type": "object",
        "required": [
          "enabled",
          "envs",
          "grantAllPermissions",
          "name",
          "pluginReference"
        ]
      }
    },
    "docker:index/getRegistryImage:getRegistryImage": {
      "description": "Reads the image metadata from a Docker Registry. Used in conjunction with the docker.RemoteImage resource to keep an image up to date on the latest available version of the tag.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ubuntuRegistryImage = docker.getRegistryImage({\n    name: \"ubuntu:precise\",\n});\nconst ubuntuRemoteImage = new docker.RemoteImage(\"ubuntuRemoteImage\", {\n    name: ubuntuRegistryImage.then(ubuntuRegistryImage =\u003e ubuntuRegistryImage.name),\n    pullTriggers: [ubuntuRegistryImage.then(ubuntuRegistryImage =\u003e ubuntuRegistryImage.sha256Digest)],\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nubuntu_registry_image = docker.get_registry_image(name=\"ubuntu:precise\")\nubuntu_remote_image = docker.RemoteImage(\"ubuntuRemoteImage\",\n    name=ubuntu_registry_image.name,\n    pull_triggers=[ubuntu_registry_image.sha256_digest])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntuRegistryImage = Docker.GetRegistryImage.Invoke(new()\n    {\n        Name = \"ubuntu:precise\",\n    });\n\n    var ubuntuRemoteImage = new Docker.RemoteImage(\"ubuntuRemoteImage\", new()\n    {\n        Name = ubuntuRegistryImage.Apply(getRegistryImageResult =\u003e getRegistryImageResult.Name),\n        PullTriggers = new[]\n        {\n            ubuntuRegistryImage.Apply(getRegistryImageResult =\u003e getRegistryImageResult.Sha256Digest),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tubuntuRegistryImage, err := docker.LookupRegistryImage(ctx, \u0026GetRegistryImageArgs{\n\t\t\tName: \"ubuntu:precise\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.NewRemoteImage(ctx, \"ubuntuRemoteImage\", \u0026docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(ubuntuRegistryImage.Name),\n\t\t\tPullTriggers: pulumi.StringArray{\n\t\t\t\tpulumi.String(ubuntuRegistryImage.Sha256Digest),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.DockerFunctions;\nimport com.pulumi.docker.inputs.GetRegistryImageArgs;\nimport com.pulumi.docker.RemoteImage;\nimport com.pulumi.docker.RemoteImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var ubuntuRegistryImage = DockerFunctions.getRegistryImage(GetRegistryImageArgs.builder()\n            .name(\"ubuntu:precise\")\n            .build());\n\n        var ubuntuRemoteImage = new RemoteImage(\"ubuntuRemoteImage\", RemoteImageArgs.builder()        \n            .name(ubuntuRegistryImage.applyValue(getRegistryImageResult -\u003e getRegistryImageResult.name()))\n            .pullTriggers(ubuntuRegistryImage.applyValue(getRegistryImageResult -\u003e getRegistryImageResult.sha256Digest()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntuRemoteImage:\n    type: docker:RemoteImage\n    properties:\n      name: ${ubuntuRegistryImage.name}\n      pullTriggers:\n        - ${ubuntuRegistryImage.sha256Digest}\nvariables:\n  ubuntuRegistryImage:\n    Fn::Invoke:\n      Function: docker:getRegistryImage\n      Arguments:\n        name: ubuntu:precise\n```\n{{% /example %}}\n{{% /examples %}}",
      "inputs": {
        "description": "A collection of arguments for invoking getRegistryImage.\n",
        "properties": {
          "insecureSkipVerify": {
            "type": "boolean",
            "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker image, including any tags. e.g. `alpine:latest`\n"
          }
        },
        "type": "object",
        "required": [
          "name"
        ]
      },
      "outputs": {
        "description": "A collection of values returned by getRegistryImage.\n",
        "properties": {
          "id": {
            "type": "string",
            "description": "The provider-assigned unique ID for this managed resource.\n"
          },
          "insecureSkipVerify": {
            "type": "boolean",
            "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker image, including any tags. e.g. `alpine:latest`\n"
          },
          "sha256Digest": {
            "type": "string",
            "description": "The content digest of the image, as stored in the registry.\n"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "sha256Digest"
        ]
      }
    },
    "docker:index/getRemoteImage:getRemoteImage": {
      "description": "`docker.RemoteImage` provides details about a specific Docker Image which need to be presend on the Docker Host\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\n// uses the 'latest' tag\nconst latest = pulumi.output(docker.getRemoteImage({\n    name: \"nginx\",\n}));\n// uses a specific tag\nconst specific = pulumi.output(docker.getRemoteImage({\n    name: \"nginx:1.17.6\",\n}));\n// use the image digest\nconst digest = pulumi.output(docker.getRemoteImage({\n    name: \"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n}));\n// uses the tag and the image digest\nconst tagAndDigest = pulumi.output(docker.getRemoteImage({\n    name: \"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nlatest = docker.get_remote_image(name=\"nginx\")\nspecific = docker.get_remote_image(name=\"nginx:1.17.6\")\ndigest = docker.get_remote_image(name=\"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\")\ntag_and_digest = docker.get_remote_image(name=\"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var latest = Docker.GetRemoteImage.Invoke(new()\n    {\n        Name = \"nginx\",\n    });\n\n    var specific = Docker.GetRemoteImage.Invoke(new()\n    {\n        Name = \"nginx:1.17.6\",\n    });\n\n    var digest = Docker.GetRemoteImage.Invoke(new()\n    {\n        Name = \"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n    });\n\n    var tagAndDigest = Docker.GetRemoteImage.Invoke(new()\n    {\n        Name = \"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v3/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.LookupRemoteImage(ctx, \u0026GetRemoteImageArgs{\n\t\t\tName: \"nginx\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.LookupRemoteImage(ctx, \u0026GetRemoteImageArgs{\n\t\t\tName: \"nginx:1.17.6\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.LookupRemoteImage(ctx, \u0026GetRemoteImageArgs{\n\t\t\tName: \"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.LookupRemoteImage(ctx, \u0026GetRemoteImageArgs{\n\t\t\tName: \"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.DockerFunctions;\nimport com.pulumi.docker.inputs.GetRemoteImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var latest = DockerFunctions.getRemoteImage(GetRemoteImageArgs.builder()\n            .name(\"nginx\")\n            .build());\n\n        final var specific = DockerFunctions.getRemoteImage(GetRemoteImageArgs.builder()\n            .name(\"nginx:1.17.6\")\n            .build());\n\n        final var digest = DockerFunctions.getRemoteImage(GetRemoteImageArgs.builder()\n            .name(\"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\")\n            .build());\n\n        final var tagAndDigest = DockerFunctions.getRemoteImage(GetRemoteImageArgs.builder()\n            .name(\"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  latest:\n    Fn::Invoke:\n      Function: docker:getRemoteImage\n      Arguments:\n        name: nginx\n  specific:\n    Fn::Invoke:\n      Function: docker:getRemoteImage\n      Arguments:\n        name: nginx:1.17.6\n  digest:\n    Fn::Invoke:\n      Function: docker:getRemoteImage\n      Arguments:\n        name: nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\n  tagAndDigest:\n    Fn::Invoke:\n      Function: docker:getRemoteImage\n      Arguments:\n        name: nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\n```\n{{% /example %}}\n{{% /examples %}}",
      "inputs": {
        "description": "A collection of arguments for invoking getRemoteImage.\n",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the Docker image, including any tags or SHA256 repo digests.\n"
          }
        },
        "type": "object",
        "required": [
          "name"
        ]
      },
      "outputs": {
        "description": "A collection of values returned by getRemoteImage.\n",
        "properties": {
          "id": {
            "type": "string",
            "description": "The provider-assigned unique ID for this managed resource.\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the Docker image, including any tags or SHA256 repo digests.\n"
          },
          "repoDigest": {
            "type": "string",
            "description": "The image sha256 digest in the form of `repo[:tag]@sha256:\u003chash\u003e`. It may be empty in the edge case where the local image was pulled from a repo, tagged locally, and then referred to in the data source by that local name/tag.\n"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "repoDigest"
        ]
      }
    }
  }
}
