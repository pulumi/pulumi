// Code generated by test DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package example

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
	"simple-plain-schema/example/internal"
)

type Component struct {
	pulumi.ResourceState

	A   pulumix.Output[bool]                 `pulumi:"a"`
	B   pulumix.Output[*bool]                `pulumi:"b"`
	Bar pulumix.GPtrOutput[Foo, FooOutput]   `pulumi:"bar"`
	Baz pulumix.GArrayOutput[Foo, FooOutput] `pulumi:"baz"`
	C   pulumix.Output[int]                  `pulumi:"c"`
	D   pulumix.Output[*int]                 `pulumi:"d"`
	E   pulumix.Output[string]               `pulumi:"e"`
	F   pulumix.Output[*string]              `pulumi:"f"`
	Foo pulumix.GPtrOutput[Foo, FooOutput]   `pulumi:"foo"`
}

// NewComponent registers a new resource with the given unique name, arguments, and options.
func NewComponent(ctx *pulumi.Context,
	name string, args *ComponentArgs, opts ...pulumi.ResourceOption) (*Component, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Component
	err := ctx.RegisterRemoteComponentResource("example::Component", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type componentArgs struct {
	A      bool           `pulumi:"a"`
	B      *bool          `pulumi:"b"`
	Bar    *Foo           `pulumi:"bar"`
	Baz    []Foo          `pulumi:"baz"`
	BazMap map[string]Foo `pulumi:"bazMap"`
	C      int            `pulumi:"c"`
	D      *int           `pulumi:"d"`
	E      string         `pulumi:"e"`
	F      *string        `pulumi:"f"`
	Foo    *Foo           `pulumi:"foo"`
}

// The set of arguments for constructing a Component resource.
type ComponentArgs struct {
	A      bool
	B      *bool
	Bar    *Foo
	Baz    []Foo
	BazMap map[string]Foo
	C      int
	D      *int
	E      string
	F      *string
	Foo    pulumix.Input[*FooArgs]
}

func (ComponentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*componentArgs)(nil)).Elem()
}

type ComponentOutput struct{ *pulumi.OutputState }

func (ComponentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Component)(nil)).Elem()
}

func (o ComponentOutput) ToComponentOutput() ComponentOutput {
	return o
}

func (o ComponentOutput) ToComponentOutputWithContext(ctx context.Context) ComponentOutput {
	return o
}

func (o ComponentOutput) ToOutput(ctx context.Context) pulumix.Output[Component] {
	return pulumix.Output[Component]{
		OutputState: o.OutputState,
	}
}

func (o ComponentOutput) A() pulumix.Output[bool] {
	value := pulumix.Apply[Component](o, func(v Component) pulumix.Output[bool] { return v.A })
	return pulumix.Flatten[bool, pulumix.Output[bool]](value)
}

func (o ComponentOutput) B() pulumix.Output[*bool] {
	value := pulumix.Apply[Component](o, func(v Component) pulumix.Output[*bool] { return v.B })
	return pulumix.Flatten[*bool, pulumix.Output[*bool]](value)
}

func (o ComponentOutput) Bar() pulumix.GPtrOutput[Foo, FooOutput] {
	value := pulumix.Apply[Component](o, func(v Component) pulumix.GPtrOutput[Foo, FooOutput] { return v.Bar })
	unwrapped := pulumix.Flatten[*Foo, pulumix.GPtrOutput[Foo, FooOutput]](value)
	return pulumix.GPtrOutput[Foo, FooOutput]{OutputState: unwrapped.OutputState}
}

func (o ComponentOutput) Baz() pulumix.GArrayOutput[Foo, FooOutput] {
	value := pulumix.Apply[Component](o, func(v Component) pulumix.GArrayOutput[Foo, FooOutput] { return v.Baz })
	unwrapped := pulumix.Flatten[[]Foo, pulumix.GArrayOutput[Foo, FooOutput]](value)
	return pulumix.GArrayOutput[Foo, FooOutput]{OutputState: unwrapped.OutputState}
}

func (o ComponentOutput) C() pulumix.Output[int] {
	value := pulumix.Apply[Component](o, func(v Component) pulumix.Output[int] { return v.C })
	return pulumix.Flatten[int, pulumix.Output[int]](value)
}

func (o ComponentOutput) D() pulumix.Output[*int] {
	value := pulumix.Apply[Component](o, func(v Component) pulumix.Output[*int] { return v.D })
	return pulumix.Flatten[*int, pulumix.Output[*int]](value)
}

func (o ComponentOutput) E() pulumix.Output[string] {
	value := pulumix.Apply[Component](o, func(v Component) pulumix.Output[string] { return v.E })
	return pulumix.Flatten[string, pulumix.Output[string]](value)
}

func (o ComponentOutput) F() pulumix.Output[*string] {
	value := pulumix.Apply[Component](o, func(v Component) pulumix.Output[*string] { return v.F })
	return pulumix.Flatten[*string, pulumix.Output[*string]](value)
}

func (o ComponentOutput) Foo() pulumix.GPtrOutput[Foo, FooOutput] {
	value := pulumix.Apply[Component](o, func(v Component) pulumix.GPtrOutput[Foo, FooOutput] { return v.Foo })
	unwrapped := pulumix.Flatten[*Foo, pulumix.GPtrOutput[Foo, FooOutput]](value)
	return pulumix.GPtrOutput[Foo, FooOutput]{OutputState: unwrapped.OutputState}
}

func init() {
	pulumi.RegisterOutputType(ComponentOutput{})
}
