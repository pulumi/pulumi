// Licensed to Pulumi Corporation ("Pulumi") under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// Pulumi licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lumidl

import (
	"bufio"
	"fmt"
	"go/types"
	"os"
	"path/filepath"

	"github.com/pulumi/lumi/pkg/util/contract"
)

// writefmt wraps the bufio.Writer.WriteString function, but also performs fmt.Sprintf-style formatting.
func writefmt(w *bufio.Writer, msg string, args ...interface{}) {
	_, err := w.WriteString(fmt.Sprintf(msg, args...))
	contract.IgnoreError(err)
}

// writefmtln wraps the bufio.Writer.WriteString function, performing fmt.Sprintf-style formatting and appending \n.
func writefmtln(w *bufio.Writer, msg string, args ...interface{}) {
	writefmt(w, msg+"\n", args...)
}

// emitHeaderWarning emits the standard "WARNING" into a generated file.
func emitHeaderWarning(w *bufio.Writer) {
	writefmtln(w, "// *** WARNING: this file was generated by the Lumi IDL Compiler (LUMIDL). ***")
	writefmtln(w, "// *** Do not edit by hand unless you're certain you know what you are doing! ***")
	writefmtln(w, "")
}

// mirrorDirLayout ensures a target output directory contains the same layout as the input package.
func mirrorDirLayout(pkg *Package, out string) error {
	for relpath := range pkg.Files {
		// Make the target file by concatening the output with the relative path, and ensure the directory exists.
		path := filepath.Join(out, relpath)
		if err := ensurePath(path); err != nil {
			return err
		}
	}
	return nil
}

// ensurePath ensures that a target filepath exists (like `mkdir -p`), returning a non-nil error if any problem occurs.
func ensurePath(path string) error {
	dir := filepath.Dir(path)
	return os.MkdirAll(dir, 0700)
}

func forEachField(t TypeMember, action func(*types.Var, PropertyOptions)) int {
	return forEachStructField(t.Struct(), t.PropertyOptions(), action)
}

func forEachStructField(s *types.Struct, opts []PropertyOptions, action func(*types.Var, PropertyOptions)) int {
	n := 0
	for i, j := 0, 0; i < s.NumFields(); i++ {
		fld := s.Field(i)
		if fld.Anonymous() {
			// For anonymous types, recurse.
			named := fld.Type().(*types.Named)
			embedded := named.Underlying().(*types.Struct)
			k := forEachStructField(embedded, opts[j:], action)
			j += k
			n += k
		} else {
			// For actual fields, invoke the action, and bump the counters.
			if action != nil {
				action(s.Field(i), opts[j])
			}
			j++
			n++
		}
	}
	return n
}
