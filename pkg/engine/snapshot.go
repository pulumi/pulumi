// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package engine

import (
	"errors"
	"fmt"
	"io"
	"reflect"

	"github.com/go-test/deep"
	"github.com/pulumi/pulumi/pkg/v3/resource/deploy"
	"github.com/pulumi/pulumi/sdk/v3/go/common/resource"
)

// SnapshotManager manages an in-memory resource graph.
type SnapshotManager interface {
	io.Closer

	// Write updates the global snapshot with the provided base snapshot. This is used
	// for example after migrating providers.
	Write(base *deploy.Snapshot) error

	// BeginMutation signals to the SnapshotManager that the planner intends to mutate the global
	// snapshot. It provides the step that it intends to execute. Based on that step, BeginMutation
	// will record this intent in the global snapshot and return a `SnapshotMutation` that, when ended,
	// will complete the transaction.
	BeginMutation(step deploy.Step) (SnapshotMutation, error)

	// RegisterResourceOutputs registers the set of resource outputs generated by performing the
	// given step. These outputs are persisted in the snapshot.
	RegisterResourceOutputs(step deploy.Step) error
}

// SnapshotMutation represents an outstanding mutation that is yet to be completed. When the engine completes
// a mutation, it must call `End` in order to record the successful completion of the mutation.
type SnapshotMutation interface {
	// End terminates the transaction and commits the results to the snapshot, returning an error if this
	// failed to complete.
	End(step deploy.Step, successful bool) error
}

func SnapshotEqual(journal, manager *deploy.Snapshot) error {
	// Just want to check the same operations and resources are counted, but order might be slightly different.
	if journal == nil && manager == nil {
		return nil
	}
	if journal == nil {
		return errors.New("journal snapshot is nil")
	}
	if manager == nil {
		return errors.New("manager snapshot is nil")
	}

	// Manifests and SecretsManagers are known to differ because we don't thread them through for the Journal code.

	if len(journal.PendingOperations) != len(manager.PendingOperations) {
		return errors.New("journal and manager pending operations differ")
	}

	pendingOpsMap := make(map[resource.URN][]resource.Operation)

	for _, mop := range manager.PendingOperations {
		pendingOpsMap[mop.Resource.URN] = append(pendingOpsMap[mop.Resource.URN], mop)
	}
	for _, jop := range journal.PendingOperations {
		found := false
		for _, mop := range pendingOpsMap[jop.Resource.URN] {
			if reflect.DeepEqual(jop, mop) {
				found = true
				break
			}
		}
		if !found {
			return fmt.Errorf("journal and manager pending operations differ, %v not found in manager", jop)
		}
	}

	if len(journal.Resources) != len(manager.Resources) {
		var journalResources string
		for _, r := range journal.Resources {
			journalResources += fmt.Sprintf("%v %v, ", r.URN, r.Delete)
		}
		var managerResources string
		for _, r := range manager.Resources {
			managerResources += fmt.Sprintf("%v %v, ", r.URN, r.Delete)
		}
		return fmt.Errorf("journal and manager resources differ, %d in journal (have %v), %d in manager (have %v)",
			len(journal.Resources), journalResources, len(manager.Resources), managerResources)
	}

	resourcesMap := make(map[resource.URN][]*resource.State)

	for _, mr := range manager.Resources {
		resourcesMap[mr.URN] = append(resourcesMap[mr.URN], mr)
	}

	for _, jr := range journal.Resources {
		found := false
		var diffStr string
		for _, mr := range resourcesMap[jr.URN] {
			if diff := deep.Equal(jr, mr); diff != nil {
				if jr.URN == mr.URN {
					diffStr += fmt.Sprintf("%s\n", diff)
				}
			} else {
				found = true
				break
			}
		}
		if !found {
			var journalResources string
			for _, jr := range journal.Resources {
				journalResources += fmt.Sprintf("Journal resource: %v\n", jr)
			}
			var managerResources string
			for _, mr := range manager.Resources {
				managerResources += fmt.Sprintf("Manager resource: %v\n", mr)
			}
			return fmt.Errorf("journal and manager resources differ, %v not found in manager.\n"+
				"Journal: %v\nManager: %v\nDiffs: %v",
				jr, journalResources, managerResources, diffStr)
		}
	}

	return nil
}
